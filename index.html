<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="icon" type="image/png" href="https://i.imgur.com/L12s18T.png" />
      <title>Pokemon Battle Arena - Ultimate Edition</title>

      <!-- Progressive Web App -->
      <link rel="manifest" href="/manifest.json" />
      <meta name="theme-color" content="#58a8d8" />

      <!-- Import Pixel Font & Libraries -->
      <link rel="preconnect" href="https://fonts.googleapis.com" />
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
      <link
         href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
         rel="stylesheet"
      />
      <script src="https://cdn.tailwindcss.com"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
      <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

      <!-- Extended Pokemon and Moves Data -->
      <script src="extended-pokemon-data.js"></script>
      <script src="extended-moves-data.js"></script>

      <!-- Custom CSS -->
      <style>
         :root {
            --primary-color: #58a8d8;
            --secondary-color: #f8f8f8;
            --accent-color: #ffcc00;
            --text-color: #1a202c;
            --text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
            --battle-bg: #58a8d8;
         }

         body {
            font-family: "Press Start 2P", cursive;
            background-color: var(--primary-color);
            background-image: url("wallpaperflare.com_wallpaper.jpg");
            background-size: cover;
            background-position: center;
            transition: background 0.5s ease-in-out;
            color: var(--text-color);
            text-shadow: var(--text-shadow);
            margin: 0;
            padding: 0;
            overflow-x: hidden;
         }

         /* Weather Effects */
         .weather-rain {
            position: relative;
         }

         .weather-rain::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: linear-gradient(transparent 50%, rgba(174, 194, 224, 0.4) 50%);
            background-size: 100% 4px;
            animation: rain 0.3s linear infinite;
            pointer-events: none;
            z-index: 1;
         }

         @keyframes rain {
            0% {
               transform: translateY(0);
            }
            100% {
               transform: translateY(4px);
            }
         }

         .weather-sun {
            filter: brightness(1.2) contrast(1.1);
         }

         .weather-sandstorm {
            position: relative;
         }

         .weather-sandstorm::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(194, 154, 108, 0.3);
            animation: sandstorm 20s linear infinite;
            pointer-events: none;
            z-index: 1;
         }

         @keyframes sandstorm {
            0% {
               transform: translateX(0);
            }
            100% {
               transform: translateX(-100%);
            }
         }

         /* Status Effect Overlays */
         .status-burn {
            filter: hue-rotate(-20deg) brightness(1.1);
         }
         .status-poison {
            filter: hue-rotate(280deg) saturate(1.2);
         }
         .status-paralysis {
            filter: hue-rotate(60deg) brightness(0.9);
         }
         .status-freeze {
            filter: hue-rotate(180deg) brightness(1.3) contrast(1.2);
         }

         .status-sleep::after {
            content: "Z Z Z";
            position: absolute;
            top: -20px;
            right: 0;
            animation: sleep-z 2s ease-in-out infinite;
            font-size: 12px;
            color: #4a5568;
         }

         @keyframes sleep-z {
            0%,
            100% {
               transform: translateY(0) translateX(0);
               opacity: 0;
            }
            50% {
               transform: translateY(-20px) translateX(10px);
               opacity: 1;
            }
         }

         /* UI Components */
         .pixelated {
            image-rendering: pixelated;
            image-rendering: -webkit-optimize-contrast;
         }

         .text-box {
            background-color: #f8f8f8;
            border: 8px solid;
            border-image: url('data:image/svg+xml;charset=utf-8,%3Csvg width%3D"24" height%3D"24" viewBox%3D"0 0 24 24" fill%3D"none" xmlns%3D"http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg"%3E%3Cpath d%3D"M0 0h24v24H0z" fill%3D"%23fff"%2F%3E%3Cpath d%3D"M1 1h22v22H1z" fill%3D"none" stroke%3D"%23000" stroke-width%3D"2"%2F%3E%3Cpath d%3D"M8 1h8v2H8zM1 8h2v8H1zM8 21h8v2H8zM21 8h2v8h-2z" fill%3D"%23000"%2F%3E%3C%2Fsvg%3E')
               8;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
         }

         .action-button {
            border: 4px solid #000;
            box-shadow: inset 0 0 0 2px #989898, inset 0 0 0 4px #fff;
            transition: all 0.1s;
            cursor: pointer;
            position: relative;
            user-select: none;
         }

         .action-button:hover {
            transform: translateY(-2px);
            box-shadow: inset 0 0 0 2px #989898, inset 0 0 0 4px #fff, 0 4px 8px rgba(0, 0, 0, 0.3);
         }

         .action-button:active {
            transform: translateY(0);
         }

         .action-button:focus {
            outline: 3px solid #4299e1;
            outline-offset: 2px;
         }

         .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
         }

         /* HP Bars */
         .hp-bar-gradient-green {
            background: linear-gradient(to bottom, #30d830, #00a000);
         }
         .hp-bar-gradient-yellow {
            background: linear-gradient(to bottom, #f8d830, #f8a000);
         }
         .hp-bar-gradient-red {
            background: linear-gradient(to bottom, #f85030, #d02000);
         }

         /* Battle Platform */
         .battle-platform {
            width: 180px;
            height: 10px;
            background: linear-gradient(to bottom, #a8e060, #70a040);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         /* Damage Numbers */
         .damage-number {
            position: absolute;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 100;
            animation: damage-float 1.5s ease-out forwards;
         }

         @keyframes damage-float {
            0% {
               transform: translateY(0) scale(0.5);
               opacity: 0;
            }
            50% {
               transform: translateY(-30px) scale(1.2);
               opacity: 1;
            }
            100% {
               transform: translateY(-60px) scale(1);
               opacity: 0;
            }
         }

         .damage-critical {
            color: #ffd700;
            font-size: 2em;
         }
         .damage-super {
            color: #ff6b6b;
            font-size: 1.5em;
         }
         .damage-normal {
            color: #2d3748;
            font-size: 1.2em;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
         }
         .damage-weak {
            color: #4a5568;
            font-size: 1em;
         }
         .damage-heal {
            color: #4caf50;
            font-size: 1.2em;
         }

         /* Animations */
         @keyframes player-attack {
            0% {
               transform: translate(0, 0);
            }
            50% {
               transform: translate(50px, -20px) scale(1.1);
            }
            100% {
               transform: translate(0, 0);
            }
         }

         @keyframes enemy-attack {
            0% {
               transform: translate(0, 0);
            }
            50% {
               transform: translate(-50px, 20px) scale(1.1);
            }
            100% {
               transform: translate(0, 0);
            }
         }

         @keyframes damage-shake {
            0%,
            100% {
               transform: translateX(0);
            }
            25% {
               transform: translateX(-10px);
            }
            75% {
               transform: translateX(10px);
            }
         }

         @keyframes faint {
            0% {
               transform: translateY(0) rotate(0);
               opacity: 1;
            }
            100% {
               transform: translateY(50px) rotate(90deg);
               opacity: 0;
            }
         }

         @keyframes flash {
            0% {
               opacity: 0.5;
            }
            50% {
               opacity: 0.8;
            }
            100% {
               opacity: 0;
            }
         }

         @keyframes damage-shake {
            0% {
               transform: translateX(0);
            }
            25% {
               transform: translateX(-5px);
            }
            75% {
               transform: translateX(5px);
            }
            100% {
               transform: translateX(0);
            }
         }

         @keyframes critical-hit {
            0% {
               transform: scale(1) rotate(0deg);
            }
            25% {
               transform: scale(1.1) rotate(-2deg);
            }
            75% {
               transform: scale(1.1) rotate(2deg);
            }
            100% {
               transform: scale(1) rotate(0deg);
            }
         }

         .animate-damage-shake {
            animation: damage-shake 0.3s ease-in-out;
         }

         .animate-critical-hit {
            animation: critical-hit 0.5s ease-in-out;
         }

         @keyframes pokeball-shake {
            0%,
            100% {
               transform: rotate(0deg);
            }
            25% {
               transform: rotate(-10deg);
            }
            75% {
               transform: rotate(10deg);
            }
         }

         /* Class applications */
         .animate-player-attack {
            animation: player-attack 0.6s ease-in-out;
         }
         .animate-enemy-attack {
            animation: enemy-attack 0.6s ease-in-out;
         }
         .animate-damage {
            animation: damage-shake 0.3s ease-in-out;
         }
         .animate-faint {
            animation: faint 1s ease-in forwards;
         }
         .animate-pokeball-shake {
            animation: pokeball-shake 0.5s ease-in-out;
         }

         /* Team Display */
         .pokeball-mini {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(
               to bottom,
               #fecaca 0%,
               #f87171 48%,
               #6b7280 48%,
               #6b7280 52%,
               #ffffff 52%,
               #f3f4f6 100%
            );
            border: 2px solid #9ca3af;
            position: relative;
            display: inline-block;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
               inset 0 -1px 0 rgba(0, 0, 0, 0.1);
         }

         .pokeball-mini::after {
            content: "";
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #ffffff 0%, #f9fafb 40%, #e5e7eb 100%);
            border: 1px solid #9ca3af;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.9);
            z-index: 2;
         }

         .pokeball-mini::before {
            content: "";
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(
               to right,
               transparent 15%,
               #9ca3af 15%,
               #9ca3af 85%,
               transparent 85%
            );
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            z-index: 1;
         }

         .pokeball-mini:hover {
            transform: scale(1.15) translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.7),
               inset 0 -1px 0 rgba(0, 0, 0, 0.15);
         }

         /* Healthy Pokemon - Green glow */
         .pokeball-mini.healthy {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
               inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 8px rgba(34, 197, 94, 0.5);
         }

         /* Low HP Pokemon - Yellow/Orange glow */
         .pokeball-mini.low-hp {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
               inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 8px rgba(251, 146, 60, 0.6);
            animation: pokeball-warning 1.5s ease-in-out infinite;
         }

         /* Critical HP Pokemon - Red glow */
         .pokeball-mini.critical-hp {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
               inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 8px rgba(239, 68, 68, 0.7);
            animation: pokeball-critical 1s ease-in-out infinite;
         }

         /* Fainted Pokemon - Dark and cracked */
         .pokeball-mini.fainted {
            background: linear-gradient(
               to bottom,
               #6b7280 0%,
               #4b5563 48%,
               #1f2937 48%,
               #1f2937 52%,
               #9ca3af 52%,
               #6b7280 100%
            );
            filter: grayscale(100%) brightness(0.6);
            opacity: 0.7;
            transform: scale(0.85);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3),
               inset 0 -1px 0 rgba(0, 0, 0, 0.3);
         }

         .pokeball-mini.fainted::after {
            background: radial-gradient(circle, #e5e7eb 0%, #d1d5db 40%, #9ca3af 100%);
            border-color: #6b7280;
         }

         /* Active Pokemon - Blue pulse */
         .pokeball-mini.active {
            animation: pokeball-active 2s ease-in-out infinite;
         }

         @keyframes pokeball-active {
            0%,
            100% {
               box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 10px rgba(59, 130, 246, 0.5);
            }
            50% {
               box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 15px rgba(59, 130, 246, 0.8);
            }
         }

         @keyframes pokeball-warning {
            0%,
            100% {
               box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 8px rgba(251, 146, 60, 0.6);
            }
            50% {
               box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 12px rgba(251, 146, 60, 0.9);
            }
         }

         @keyframes pokeball-critical {
            0%,
            100% {
               box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 8px rgba(239, 68, 68, 0.7);
            }
            50% {
               box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.6),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1), 0 0 12px rgba(239, 68, 68, 1);
               transform: scale(0.9);
            }
         }

         .team-indicator-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(4px);
            border-radius: 12px;
            padding: 6px 10px;
            border: 2px solid rgba(156, 163, 175, 0.4);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
         }

         /* Type Colors */
         .type-normal {
            background-color: #a8a878;
         }
         .type-fire {
            background-color: #f08030;
         }
         .type-water {
            background-color: #6890f0;
         }
         .type-electric {
            background-color: #f8d030;
         }
         .type-grass {
            background-color: #78c850;
         }
         .type-ice {
            background-color: #98d8d8;
         }
         .type-fighting {
            background-color: #e53e3e;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
         }
         .type-poison {
            background-color: #b794f6;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
         }
         .type-ground {
            background-color: #e0c068;
         }
         .type-flying {
            background-color: #a890f0;
         }
         .type-psychic {
            background-color: #f85888;
         }
         .type-bug {
            background-color: #a8b820;
         }
         .type-rock {
            background-color: #b8a038;
         }
         .type-ghost {
            background-color: #9f7aea;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
         }
         .type-dragon {
            background-color: #9f7aea;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
         }
         .type-dark {
            background-color: #8b7355;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
         }
         .type-steel {
            background-color: #b8b8d0;
         }
         .type-fairy {
            background-color: #ee99ac;
         }

         /* Move Preview */
         .move-preview {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffcc00;
            border-radius: 8px;
            padding: 12px;
            color: #f7fafc;
            font-size: 10px;
            z-index: 1000;
            min-width: 200px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
         }

         .move-preview .effectiveness {
            font-weight: bold;
         }

         .move-preview .super-effective {
            color: #ff6b6b;
         }
         .move-preview .not-very-effective {
            color: #808080;
         }
         .move-preview .no-effect {
            color: #404040;
         }

         /* Settings Panel */
         .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            border: 4px solid #000;
            border-radius: 12px;
            padding: 24px;
            min-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
         }

         .settings-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            border-bottom: 2px solid #e0e0e0;
         }

         .settings-tab {
            padding: 8px 16px;
            background: none;
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.2s;
         }

         .settings-tab.active {
            border-bottom: 3px solid #4299e1;
            color: #4299e1;
         }

         /* Scrollbars */
         .custom-scrollbar::-webkit-scrollbar {
            width: 12px;
         }

         .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
         }

         .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
         }

         /* Enhanced Battle UI Styles */
         .battle-ui-panel {
            background: linear-gradient(
               135deg,
               rgba(255, 255, 255, 0.15) 0%,
               rgba(240, 240, 240, 0.12) 100%
            );
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(4px);
            position: relative;
            overflow: hidden;
         }

         .battle-ui-panel::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3498db, #2ecc71, #f1c40f, #e74c3c);
            animation: rainbow-glow 3s ease-in-out infinite alternate;
            border-radius: 16px 16px 0 0;
         }

         .move-button {
            background: linear-gradient(
               to bottom,
               #ffffff 0%,
               #f8fafc 20%,
               #f1f5f9 40%,
               #e2e8f0 60%,
               #cbd5e1 100%
            );
            border: 2px solid #64748b;
            border-radius: 8px;
            color: #334155;
            font-family: "Press Start 2P", monospace;
            font-size: 9px;
            font-weight: normal;
            padding: 10px 12px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.9),
               inset 0 -1px 0 rgba(100, 116, 139, 0.2);
            text-shadow: none;
         }

         .move-button:hover {
            background: linear-gradient(
               to bottom,
               #f8fafc 0%,
               #f1f5f9 20%,
               #e2e8f0 40%,
               #cbd5e1 60%,
               #94a3b8 100%
            );
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.95),
               inset 0 -1px 0 rgba(100, 116, 139, 0.3);
         }

         .move-button:hover::before {
            left: 100%;
         }

         .move-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8),
               inset 0 -1px 0 rgba(100, 116, 139, 0.4);
         }

         .move-button.disabled {
            background: linear-gradient(
               to bottom,
               #f1f5f9 0%,
               #e2e8f0 20%,
               #cbd5e1 40%,
               #94a3b8 60%,
               #64748b 100%
            );
            color: #94a3b8;
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.5);
         }

         .move-name {
            font-size: 10px;
            margin-bottom: 4px;
            text-shadow: none;
            line-height: 1.2;
            color: #334155;
         }

         .move-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 8px;
            margin-top: 4px;
         }

         .move-type-badge {
            padding: 1px 4px;
            border: 1px solid #475569;
            border-radius: 3px;
            font-weight: normal;
            font-size: 7px;
            text-shadow: none;
            text-transform: uppercase;
         }

         .move-pp {
            color: #475569;
            font-weight: normal;
            text-shadow: none;
            font-size: 8px;
         }

         .pokemon-info-card {
            background: linear-gradient(
               135deg,
               #f8fafc 0%,
               #e2e8f0 25%,
               #cbd5e1 50%,
               #e2e8f0 75%,
               #f1f5f9 100%
            );
            border: 3px solid #1e293b;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.8),
               inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            position: relative;
            min-width: 200px;
         }

         .pokemon-info-card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px 12px 0 0;
         }

         .hp-bar-container {
            background: #2c3e50;
            border-radius: 6px;
            height: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         .hp-bar-fill {
            height: 100%;
            transition: width 0.5s ease-in-out;
            position: relative;
            border-radius: 4px;
         }

         .hp-bar-fill::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
            border-radius: 4px 4px 0 0;
         }

         .hp-bar-gradient-green {
            background: linear-gradient(to right, #27ae60, #2ecc71);
         }

         .hp-bar-gradient-yellow {
            background: linear-gradient(to right, #f39c12, #f1c40f);
         }

         .hp-bar-gradient-red {
            background: linear-gradient(to right, #c0392b, #e74c3c);
         }

         .battle-menu-grid {
            gap: 12px;
         }

         .battle-action-button {
            padding: 10px 14px;
            border: 2px solid #64748b;
            border-radius: 8px;
            font-family: "Press Start 2P", monospace;
            font-size: 9px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.9),
               inset 0 -1px 0 rgba(100, 116, 139, 0.2);
            text-shadow: none;
         }

         .battle-action-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.95),
               inset 0 -1px 0 rgba(100, 116, 139, 0.3);
         }

         .battle-action-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8),
               inset 0 -1px 0 rgba(100, 116, 139, 0.4);
         }

         /* .battle-action-button.coach {
            background: linear-gradient(
               to bottom,
               #f8faff 0%,
               #ede9fe 20%,
               #ddd6fe 40%,
               #c4b5fd 60%,
               #a78bfa 100%
            );
            color: #4c1d95;
            font-weight: bold;
         } */

         /* .battle-action-button.switch {
            background: linear-gradient(
               to bottom,
               #fffef7 0%,
               #fef3c7 20%,
               #fde68a 40%,
               #fcd34d 60%,
               #f59e0b 100%
            );
            color: #78350f;
            font-weight: bold;
         }

         .battle-action-button.run {
            background: linear-gradient(
               to bottom,
               #fef2f2 0%,
               #fecaca 20%,
               #fca5a5 40%,
               #f87171 60%,
               #ef4444 100%
            );
            color: #7f1d1d;
         } */

         .status-effect-indicator {
            position: absolute;
            top: -6px;
            right: -6px;
            border: 2px solid #000000;
            color: #ffffff;
            font-family: "Press Start 2P", monospace;
            font-size: 6px;
            padding: 2px 4px;
            border-radius: 0;
            font-weight: normal;
            animation: pixel-blink 1s infinite;
            box-shadow: 2px 2px 0px #000000;
            text-shadow: 1px 1px 0px #000000;
         }

         .status-burn {
            background: #f97316;
         }
         .status-poison {
            background: #8b5cf6;
         }
         .status-paralysis {
            background: #eab308;
            color: #000000;
            text-shadow: 1px 1px 0px #ffffff;
         }
         .status-freeze {
            background: #06b6d4;
         }
         .status-sleep {
            background: #6b7280;
         }

         .battle-terrain {
            background: linear-gradient(
               to bottom,
               rgba(135, 206, 235, 0.15) 0%,
               rgba(152, 251, 152, 0.2) 30%,
               rgba(74, 222, 128, 0.25) 60%,
               rgba(34, 197, 94, 0.3) 100%
            );
            position: relative;
            backdrop-filter: blur(3px);
            border-radius: 16px;
            overflow: hidden;
         }

         .battle-terrain::before {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: repeating-linear-gradient(
               0deg,
               rgba(22, 101, 52, 0.2) 0px,
               rgba(22, 101, 52, 0.2) 4px,
               rgba(21, 128, 61, 0.3) 4px,
               rgba(21, 128, 61, 0.3) 8px
            );
            opacity: 0.8;
         }

         .weather-indicator {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: #000000;
            color: #ffffff;
            padding: 6px 12px;
            border: 2px solid #ffffff;
            font-family: "Press Start 2P", monospace;
            font-size: 10px;
            font-weight: normal;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
         }

         .weather-text {
            animation: pixel-pulse 2s ease-in-out infinite;
         }

         .turn-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: #ffffff;
            padding: 8px 12px;
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            font-family: "Press Start 2P", monospace;
            font-size: 9px;
            font-weight: normal;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: 15;
         }

         .effectiveness-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000000;
            color: #ffffff;
            padding: 8px 12px;
            border: 2px solid #ffffff;
            font-family: "Press Start 2P", monospace;
            font-size: 8px;
            white-space: nowrap;
            z-index: 1000;
            animation: pixel-bounce-in 0.2s ease-out;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.7);
            max-width: 300px;
            white-space: normal;
         }

         .move-preview-content {
            text-align: left;
            line-height: 1.4;
         }

         .super-effective {
            color: #4ade80;
            font-weight: normal;
         }

         .not-very-effective {
            color: #f87171;
            font-weight: normal;
         }

         .no-effect {
            color: #9ca3af;
            font-weight: normal;
         }

         @keyframes pixel-blink {
            0%,
            50% {
               opacity: 1;
            }
            51%,
            100% {
               opacity: 0.5;
            }
         }

         @keyframes pixel-pulse {
            0%,
            100% {
               opacity: 0.8;
            }
            50% {
               opacity: 1;
            }
         }

         @keyframes pixel-bounce-in {
            0% {
               opacity: 0;
               transform: translateX(-50%) translateY(10px) scale(0.9);
            }
            100% {
               opacity: 1;
               transform: translateX(-50%) translateY(0) scale(1);
            }
         }

         @keyframes rainbow-glow {
            0% {
               opacity: 0.7;
            }
            100% {
               opacity: 1;
            }
         }

         @keyframes shine {
            0% {
               transform: translateX(-100%) translateY(-100%) rotate(45deg);
            }
            100% {
               transform: translateX(100%) translateY(100%) rotate(45deg);
            }
         }

         /* Multiplayer UI */
         .room-code {
            font-size: 24px;
            letter-spacing: 8px;
            background: #f0f0f0;
            padding: 16px 24px;
            border-radius: 8px;
            border: 2px dashed #4299e1;
            margin: 16px 0;
         }

         /* Achievement Toast */
         .achievement-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #f7fafc;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            animation: slide-in-bottom 0.5s ease-out;
            z-index: 1001;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
         }

         @keyframes slide-in-bottom {
            from {
               transform: translateY(100px);
               opacity: 0;
            }
            to {
               transform: translateY(0);
               opacity: 1;
            }
         }

         /* Loading Screen */
         .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--primary-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
         }

         .loading-pokeball {
            width: 100px;
            height: 100px;
            animation: pokeball-shake 1s ease-in-out infinite;
         }

         /* Responsive Design */
         @media (max-width: 768px) {
            body {
               font-size: 10px;
            }

            .action-button {
               font-size: 10px;
               padding: 8px 12px;
            }

            .settings-panel {
               min-width: 90vw;
               max-width: 95vw;
            }

            .battle-scene {
               scale: 0.8;
            }
         }

         /* Accessibility */
         @media (prefers-reduced-motion: reduce) {
            * {
               animation-duration: 0.01ms !important;
               animation-iteration-count: 1 !important;
               transition-duration: 0.01ms !important;
            }
         }

         .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
         }
      </style>
   </head>
   <body>
      <div id="root"></div>

      <!-- React Libraries -->
      <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
      <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
      <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

      <!-- Main Game Code -->
      <script type="text/babel">
         const {
            useState,
            useEffect,
            useRef,
            useReducer,
            createContext,
            useContext,
            useMemo,
            useCallback,
            memo,
            Fragment,
            Suspense,
            lazy,
         } = React;

         const GAME_VERSION = "2.0.0";

         const GAME_STATES = {
            LOADING: "loading",
            MAIN_MENU: "mainMenu",
            TEAM_BUILDER: "teamBuilder",
            BATTLE_SETUP: "battleSetup",
            BATTLE: "battle",
            BATTLE_END: "battleEnd",
            MULTIPLAYER_LOBBY: "multiplayerLobby",
            SETTINGS: "settings",
         };

         const BATTLE_STATES = {
            INTRO: "intro",
            TURN_START: "turnStart",
            PLAYER_TURN: "playerTurn",
            ENEMY_TURN: "enemyTurn",
            EXECUTING_MOVE: "executingMove",
            TURN_END: "turnEnd",
            POKEMON_FAINTED: "pokemonFainted",
            SWITCHING: "switching",
            VICTORY: "victory",
            DEFEAT: "defeat",
         };

         const STATUS_EFFECTS = {
            NONE: "none",
            BURN: "burn",
            POISON: "poison",
            TOXIC: "toxic",
            PARALYSIS: "paralysis",
            FREEZE: "freeze",
            SLEEP: "sleep",
         };

         const WEATHER_TYPES = {
            CLEAR: "clear",
            RAIN: "rain",
            SUN: "sun",
            SANDSTORM: "sandstorm",
            HAIL: "hail",
         };

         const BATTLE_FORMATS = {
            SINGLES_6V6: {
               id: "singles_6v6",
               name: "Singles 6v6",
               teamSize: 6,
               battleSize: 1,
               clauses: ["species", "sleep"],
            },
            SINGLES_3V3: {
               id: "singles_3v3",
               name: "Singles 3v3",
               teamSize: 3,
               battleSize: 1,
               clauses: ["species"],
            },
            DOUBLES_4V4: {
               id: "doubles_4v4",
               name: "Doubles 4v4",
               teamSize: 4,
               battleSize: 2,
               clauses: ["species"],
            },
         };

         const TYPE_EFFECTIVENESS = {
            Normal: { Rock: 0.5, Ghost: 0, Steel: 0.5 },
            Fire: {
               Fire: 0.5,
               Water: 0.5,
               Grass: 2,
               Ice: 2,
               Bug: 2,
               Rock: 0.5,
               Dragon: 0.5,
               Steel: 2,
            },
            Water: { Fire: 2, Water: 0.5, Grass: 0.5, Ground: 2, Rock: 2, Dragon: 0.5 },
            Electric: { Water: 2, Electric: 0.5, Grass: 0.5, Ground: 0, Flying: 2, Dragon: 0.5 },
            Grass: {
               Fire: 0.5,
               Water: 2,
               Grass: 0.5,
               Poison: 0.5,
               Ground: 2,
               Flying: 0.5,
               Bug: 0.5,
               Rock: 2,
               Dragon: 0.5,
               Steel: 0.5,
            },
            Ice: {
               Fire: 0.5,
               Water: 0.5,
               Grass: 2,
               Ice: 0.5,
               Ground: 2,
               Flying: 2,
               Dragon: 2,
               Steel: 0.5,
            },
            Fighting: {
               Normal: 2,
               Ice: 2,
               Poison: 0.5,
               Flying: 0.5,
               Psychic: 0.5,
               Bug: 0.5,
               Rock: 2,
               Ghost: 0,
               Dark: 2,
               Steel: 2,
               Fairy: 0.5,
            },
            Poison: {
               Grass: 2,
               Poison: 0.5,
               Ground: 0.5,
               Rock: 0.5,
               Ghost: 0.5,
               Steel: 0,
               Fairy: 2,
            },
            Ground: {
               Fire: 2,
               Electric: 2,
               Grass: 0.5,
               Poison: 2,
               Flying: 0,
               Bug: 0.5,
               Rock: 2,
               Steel: 2,
            },
            Flying: { Electric: 0.5, Grass: 2, Fighting: 2, Bug: 2, Rock: 0.5, Steel: 0.5 },
            Psychic: { Fighting: 2, Poison: 2, Psychic: 0.5, Dark: 0, Steel: 0.5 },
            Bug: {
               Fire: 0.5,
               Grass: 2,
               Fighting: 0.5,
               Poison: 0.5,
               Flying: 0.5,
               Psychic: 2,
               Ghost: 0.5,
               Dark: 2,
               Steel: 0.5,
               Fairy: 0.5,
            },
            Rock: { Fire: 2, Ice: 2, Fighting: 0.5, Ground: 0.5, Flying: 2, Bug: 2, Steel: 0.5 },
            Ghost: { Normal: 0, Psychic: 2, Ghost: 2, Dark: 0.5 },
            Dragon: { Dragon: 2, Steel: 0.5, Fairy: 0 },
            Dark: { Fighting: 0.5, Psychic: 2, Ghost: 2, Dark: 0.5, Fairy: 0.5 },
            Steel: { Fire: 0.5, Water: 0.5, Electric: 0.5, Ice: 2, Rock: 2, Steel: 0.5, Fairy: 2 },
            Fairy: { Fire: 0.5, Fighting: 2, Poison: 0.5, Dragon: 2, Dark: 2, Steel: 0.5 },
         };

         const POKEMON_DATA = {
            Pikachu: {
               id: "pikachu",
               name: "Pikachu",
               types: ["Electric"],
               baseStats: {
                  hp: 35,
                  attack: 55,
                  defense: 40,
                  spAttack: 50,
                  spDefense: 50,
                  speed: 90,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/25.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/25.gif",
               learnset: [
                  { id: "thundershock", level: 1 },
                  { id: "quickattack", level: 1 },
                  { id: "thunderbolt", level: 15 },
                  { id: "irontail", level: 20 },
               ],
               abilities: ["static"],
            },
            Charmander: {
               id: "charmander",
               name: "Charmander",
               types: ["Fire"],
               baseStats: {
                  hp: 39,
                  attack: 52,
                  defense: 43,
                  spAttack: 60,
                  spDefense: 50,
                  speed: 65,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/4.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/4.gif",
               learnset: [
                  { id: "ember", level: 1 },
                  { id: "scratch", level: 1 },
                  { id: "smokescreen", level: 4 },
                  { id: "dragonbreath", level: 12 },
                  { id: "flamethrower", level: 20 },
               ],
               abilities: ["blaze"],
            },
            Bulbasaur: {
               id: "bulbasaur",
               name: "Bulbasaur",
               types: ["Grass", "Poison"],
               baseStats: {
                  hp: 45,
                  attack: 49,
                  defense: 49,
                  spAttack: 65,
                  spDefense: 65,
                  speed: 45,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/1.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/1.gif",
               learnset: [
                  { id: "vinewhip", level: 1 },
                  { id: "tackle", level: 1 },
                  { id: "razorleaf", level: 12 },
                  { id: "sleeppowder", level: 13 },
                  { id: "sludgebomb", level: 20 },
               ],
               abilities: ["overgrow"],
            },
            Squirtle: {
               id: "squirtle",
               name: "Squirtle",
               types: ["Water"],
               baseStats: {
                  hp: 44,
                  attack: 48,
                  defense: 65,
                  spAttack: 50,
                  spDefense: 64,
                  speed: 43,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/7.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/7.gif",
               learnset: [
                  { id: "watergun", level: 1 },
                  { id: "tackle", level: 1 },
                  { id: "bite", level: 12 },
                  { id: "icebeam", level: 20 },
                  { id: "surf", level: 25 },
               ],
               abilities: ["torrent"],
            },
            // Evolved Forms
            Charizard: {
               id: "charizard",
               name: "Charizard",
               types: ["Fire", "Flying"],
               baseStats: {
                  hp: 78,
                  attack: 84,
                  defense: 78,
                  spAttack: 109,
                  spDefense: 85,
                  speed: 100,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/6.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/6.gif",
               learnset: [
                  { id: "flamethrower", level: 1 },
                  { id: "dragonclaw", level: 1 },
                  { id: "airslash", level: 1 },
                  { id: "fireblast", level: 50 },
                  { id: "dragonpulse", level: 40 },
               ],
               abilities: ["blaze", "solarpower"],
            },
            Blastoise: {
               id: "blastoise",
               name: "Blastoise",
               types: ["Water"],
               baseStats: {
                  hp: 79,
                  attack: 83,
                  defense: 100,
                  spAttack: 85,
                  spDefense: 105,
                  speed: 78,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/9.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/9.gif",
               learnset: [
                  { id: "hydropump", level: 1 },
                  { id: "icebeam", level: 1 },
                  { id: "surf", level: 1 },
                  { id: "flashcannon", level: 40 },
                  { id: "earthquake", level: 45 },
               ],
               abilities: ["torrent", "raindish"],
            },
            Venusaur: {
               id: "venusaur",
               name: "Venusaur",
               types: ["Grass", "Poison"],
               baseStats: {
                  hp: 80,
                  attack: 82,
                  defense: 83,
                  spAttack: 100,
                  spDefense: 100,
                  speed: 80,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/3.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/3.gif",
               learnset: [
                  { id: "solarbeam", level: 1 },
                  { id: "sludgebomb", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "sleeppowder", level: 1 },
                  { id: "synthesis", level: 40 },
               ],
               abilities: ["overgrow", "chlorophyll"],
            },
            // Other Popular Pokemon
            Lucario: {
               id: "lucario",
               name: "Lucario",
               types: ["Fighting", "Steel"],
               baseStats: {
                  hp: 70,
                  attack: 110,
                  defense: 70,
                  spAttack: 115,
                  spDefense: 70,
                  speed: 90,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/448.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/448.gif",
               learnset: [
                  { id: "aurasphere", level: 1 },
                  { id: "closecombat", level: 1 },
                  { id: "flashcannon", level: 1 },
                  { id: "extremespeed", level: 1 },
                  { id: "dragonpulse", level: 40 },
               ],
               abilities: ["steadfast", "innerfocus", "adaptability"],
            },
            Garchomp: {
               id: "garchomp",
               name: "Garchomp",
               types: ["Dragon", "Ground"],
               baseStats: {
                  hp: 108,
                  attack: 130,
                  defense: 95,
                  spAttack: 80,
                  spDefense: 85,
                  speed: 102,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/445.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/445.gif",
               learnset: [
                  { id: "dragonrush", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "stoneedge", level: 1 },
                  { id: "swordsdance", level: 1 },
                  { id: "outrage", level: 55 },
               ],
               abilities: ["sandrush", "roughskin"],
            },
            Gengar: {
               id: "gengar",
               name: "Gengar",
               types: ["Ghost", "Poison"],
               baseStats: {
                  hp: 60,
                  attack: 65,
                  defense: 60,
                  spAttack: 130,
                  spDefense: 75,
                  speed: 110,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/94.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/94.gif",
               learnset: [
                  { id: "shadowball", level: 1 },
                  { id: "sludgebomb", level: 1 },
                  { id: "thunderbolt", level: 1 },
                  { id: "hypnosis", level: 1 },
                  { id: "focusblast", level: 40 },
               ],
               abilities: ["levitate"],
            },
            Dragonite: {
               id: "dragonite",
               name: "Dragonite",
               types: ["Dragon", "Flying"],
               baseStats: {
                  hp: 91,
                  attack: 134,
                  defense: 95,
                  spAttack: 100,
                  spDefense: 100,
                  speed: 80,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/149.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/149.gif",
               learnset: [
                  { id: "dragonrush", level: 1 },
                  { id: "hurricane", level: 1 },
                  { id: "extremespeed", level: 1 },
                  { id: "dragondance", level: 1 },
                  { id: "outrage", level: 50 },
               ],
               abilities: ["innerfocus", "multiscale"],
            },
            Alakazam: {
               id: "alakazam",
               name: "Alakazam",
               types: ["Psychic"],
               baseStats: {
                  hp: 55,
                  attack: 50,
                  defense: 45,
                  spAttack: 135,
                  spDefense: 95,
                  speed: 120,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/65.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/65.gif",
               learnset: [
                  { id: "psychic", level: 1 },
                  { id: "shadowball", level: 1 },
                  { id: "focusblast", level: 1 },
                  { id: "thunderwave", level: 1 },
                  { id: "calmmind", level: 40 },
               ],
               abilities: ["synchronize", "innerfocus", "magicguard"],
            },
            Gyarados: {
               id: "gyarados",
               name: "Gyarados",
               types: ["Water", "Flying"],
               baseStats: {
                  hp: 95,
                  attack: 125,
                  defense: 79,
                  spAttack: 60,
                  spDefense: 100,
                  speed: 81,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/130.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/130.gif",
               learnset: [
                  { id: "waterfall", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "stoneedge", level: 1 },
                  { id: "dragondance", level: 1 },
                  { id: "icefang", level: 40 },
               ],
               abilities: ["intimidate", "moxie"],
            },
            Metagross: {
               id: "metagross",
               name: "Metagross",
               types: ["Steel", "Psychic"],
               baseStats: {
                  hp: 80,
                  attack: 135,
                  defense: 130,
                  spAttack: 95,
                  spDefense: 90,
                  speed: 70,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/376.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/376.gif",
               learnset: [
                  { id: "meteormash", level: 1 },
                  { id: "zenheadbutt", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "agility", level: 1 },
                  { id: "bulletpunch", level: 40 },
               ],
               abilities: ["clearbody", "lightmetal"],
            },
            Umbreon: {
               id: "umbreon",
               name: "Umbreon",
               types: ["Dark"],
               baseStats: {
                  hp: 95,
                  attack: 65,
                  defense: 110,
                  spAttack: 60,
                  spDefense: 130,
                  speed: 65,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/197.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/197.gif",
               learnset: [
                  { id: "foulplay", level: 1 },
                  { id: "wish", level: 1 },
                  { id: "protect", level: 1 },
                  { id: "toxic", level: 1 },
                  { id: "moonlight", level: 40 },
               ],
               abilities: ["synchronize", "innerfocus"],
            },
            Machamp: {
               id: "machamp",
               name: "Machamp",
               types: ["Fighting"],
               baseStats: {
                  hp: 90,
                  attack: 130,
                  defense: 80,
                  spAttack: 65,
                  spDefense: 85,
                  speed: 55,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/68.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/68.gif",
               learnset: [
                  { id: "closecombat", level: 1 },
                  { id: "dynamicpunch", level: 1 },
                  { id: "stoneedge", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "bulletpunch", level: 30 },
               ],
               abilities: ["guts", "noguard"],
            },
            Lapras: {
               id: "lapras",
               name: "Lapras",
               types: ["Water", "Ice"],
               baseStats: {
                  hp: 130,
                  attack: 85,
                  defense: 80,
                  spAttack: 85,
                  spDefense: 95,
                  speed: 60,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/131.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/131.gif",
               learnset: [
                  { id: "surf", level: 1 },
                  { id: "icebeam", level: 1 },
                  { id: "psychic", level: 1 },
                  { id: "thunderbolt", level: 1 },
                  { id: "hydropump", level: 40 },
               ],
               abilities: ["waterabsorb", "shellarmor"],
            },
            Snorlax: {
               id: "snorlax",
               name: "Snorlax",
               types: ["Normal"],
               baseStats: {
                  hp: 160,
                  attack: 110,
                  defense: 65,
                  spAttack: 65,
                  spDefense: 110,
                  speed: 30,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/143.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/143.gif",
               learnset: [
                  { id: "bodyslam", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "rest", level: 1 },
                  { id: "crunch", level: 1 },
                  { id: "gigaimpact", level: 50 },
               ],
               abilities: ["immunity", "thickfat"],
            },
            Arcanine: {
               id: "arcanine",
               name: "Arcanine",
               types: ["Fire"],
               baseStats: {
                  hp: 90,
                  attack: 110,
                  defense: 80,
                  spAttack: 100,
                  spDefense: 80,
                  speed: 95,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/59.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/59.gif",
               learnset: [
                  { id: "flamethrower", level: 1 },
                  { id: "extremespeed", level: 1 },
                  { id: "crunch", level: 1 },
                  { id: "thunderfang", level: 1 },
                  { id: "fireblast", level: 45 },
               ],
               abilities: ["intimidate", "flashfire"],
            },
            Crobat: {
               id: "crobat",
               name: "Crobat",
               types: ["Poison", "Flying"],
               baseStats: {
                  hp: 85,
                  attack: 90,
                  defense: 80,
                  spAttack: 70,
                  spDefense: 80,
                  speed: 130,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/169.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/169.gif",
               learnset: [
                  { id: "airslash", level: 1 },
                  { id: "sludgebomb", level: 1 },
                  { id: "uturn", level: 1 },
                  { id: "hypnosis", level: 1 },
                  { id: "crosspoison", level: 35 },
               ],
               abilities: ["innerfocus", "infiltrator"],
            },
            Tyranitar: {
               id: "tyranitar",
               name: "Tyranitar",
               types: ["Rock", "Dark"],
               baseStats: {
                  hp: 100,
                  attack: 134,
                  defense: 110,
                  spAttack: 95,
                  spDefense: 100,
                  speed: 61,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/248.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/248.gif",
               learnset: [
                  { id: "stoneedge", level: 1 },
                  { id: "crunch", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "fireblast", level: 1 },
                  { id: "dragondance", level: 40 },
               ],
               abilities: ["sandstream", "unnerve"],
            },
            Blaziken: {
               id: "blaziken",
               name: "Blaziken",
               types: ["Fire", "Fighting"],
               baseStats: {
                  hp: 80,
                  attack: 120,
                  defense: 70,
                  spAttack: 110,
                  spDefense: 70,
                  speed: 80,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/257.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/257.gif",
               learnset: [
                  { id: "blazekick", level: 1 },
                  { id: "skyuppercut", level: 1 },
                  { id: "flamethrower", level: 1 },
                  { id: "swordsdance", level: 1 },
                  { id: "overheat", level: 50 },
               ],
               abilities: ["blaze", "speedboost"],
            },
            Swampert: {
               id: "swampert",
               name: "Swampert",
               types: ["Water", "Ground"],
               baseStats: {
                  hp: 100,
                  attack: 110,
                  defense: 90,
                  spAttack: 85,
                  spDefense: 90,
                  speed: 60,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/260.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/260.gif",
               learnset: [
                  { id: "earthquake", level: 1 },
                  { id: "surf", level: 1 },
                  { id: "icebeam", level: 1 },
                  { id: "stoneedge", level: 1 },
                  { id: "muddywater", level: 40 },
               ],
               abilities: ["torrent", "damp"],
            },
            Salamence: {
               id: "salamence",
               name: "Salamence",
               types: ["Dragon", "Flying"],
               baseStats: {
                  hp: 95,
                  attack: 135,
                  defense: 80,
                  spAttack: 110,
                  spDefense: 80,
                  speed: 100,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/373.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/373.gif",
               learnset: [
                  { id: "dragonrush", level: 1 },
                  { id: "hurricane", level: 1 },
                  { id: "fireblast", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "dragondance", level: 45 },
               ],
               abilities: ["intimidate", "moxie"],
            },
            Aggron: {
               id: "aggron",
               name: "Aggron",
               types: ["Steel", "Rock"],
               baseStats: {
                  hp: 70,
                  attack: 110,
                  defense: 180,
                  spAttack: 60,
                  spDefense: 60,
                  speed: 50,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/306.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/306.gif",
               learnset: [
                  { id: "headsmash", level: 1 },
                  { id: "ironhead", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "stoneedge", level: 1 },
                  { id: "heavyslam", level: 40 },
               ],
               abilities: ["sturdy", "rockhead"],
            },
            Milotic: {
               id: "milotic",
               name: "Milotic",
               types: ["Water"],
               baseStats: {
                  hp: 95,
                  attack: 60,
                  defense: 79,
                  spAttack: 100,
                  spDefense: 125,
                  speed: 81,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/350.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/350.gif",
               learnset: [
                  { id: "surf", level: 1 },
                  { id: "icebeam", level: 1 },
                  { id: "recover", level: 1 },
                  { id: "dragontail", level: 1 },
                  { id: "hydropump", level: 45 },
               ],
               abilities: ["marvelscale", "competitive"],
            },
            Electivire: {
               id: "electivire",
               name: "Electivire",
               types: ["Electric"],
               baseStats: {
                  hp: 75,
                  attack: 123,
                  defense: 67,
                  spAttack: 95,
                  spDefense: 85,
                  speed: 95,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/466.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/466.gif",
               learnset: [
                  { id: "thunderpunch", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "icepunch", level: 1 },
                  { id: "firepunch", level: 1 },
                  { id: "gigaimpact", level: 50 },
               ],
               abilities: ["motorrive", "vitalspirit"],
            },
            Magnezone: {
               id: "magnezone",
               name: "Magnezone",
               types: ["Electric", "Steel"],
               baseStats: {
                  hp: 70,
                  attack: 70,
                  defense: 115,
                  spAttack: 130,
                  spDefense: 90,
                  speed: 60,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/462.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/462.gif",
               learnset: [
                  { id: "thunderbolt", level: 1 },
                  { id: "flashcannon", level: 1 },
                  { id: "triattack", level: 1 },
                  { id: "voltswitch", level: 1 },
                  { id: "zapcannon", level: 45 },
               ],
               abilities: ["magnetpull", "sturdy"],
            },
            Roserade: {
               id: "roserade",
               name: "Roserade",
               types: ["Grass", "Poison"],
               baseStats: {
                  hp: 60,
                  attack: 70,
                  defense: 65,
                  spAttack: 125,
                  spDefense: 105,
                  speed: 90,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/407.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/407.gif",
               learnset: [
                  { id: "energyball", level: 1 },
                  { id: "sludgebomb", level: 1 },
                  { id: "shadowball", level: 1 },
                  { id: "sleeppowder", level: 1 },
                  { id: "leafstorm", level: 50 },
               ],
               abilities: ["naturalcure", "poisonpoint"],
            },
            Gliscor: {
               id: "gliscor",
               name: "Gliscor",
               types: ["Ground", "Flying"],
               baseStats: {
                  hp: 75,
                  attack: 95,
                  defense: 125,
                  spAttack: 45,
                  spDefense: 75,
                  speed: 95,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/472.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/472.gif",
               learnset: [
                  { id: "earthquake", level: 1 },
                  { id: "acrobatics", level: 1 },
                  { id: "toxic", level: 1 },
                  { id: "uturn", level: 1 },
                  { id: "guillotine", level: 55 },
               ],
               abilities: ["hypercutter", "sandveil", "poisonheal"],
            },
            Togekiss: {
               id: "togekiss",
               name: "Togekiss",
               types: ["Fairy", "Flying"],
               baseStats: {
                  hp: 85,
                  attack: 50,
                  defense: 95,
                  spAttack: 120,
                  spDefense: 115,
                  speed: 80,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/468.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/468.gif",
               learnset: [
                  { id: "airslash", level: 1 },
                  { id: "dazzlinggleam", level: 1 },
                  { id: "thunderwave", level: 1 },
                  { id: "roost", level: 1 },
                  { id: "skyattack", level: 50 },
               ],
               abilities: ["hustle", "serenegrace", "superluck"],
            },
            // More Generation 1 Pokemon
            Raichu: {
               id: "raichu",
               name: "Raichu",
               types: ["Electric"],
               baseStats: {
                  hp: 60,
                  attack: 90,
                  defense: 55,
                  spAttack: 90,
                  spDefense: 80,
                  speed: 110,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/26.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/26.gif",
               learnset: [
                  { id: "thunderbolt", level: 1 },
                  { id: "thunder", level: 1 },
                  { id: "seismictoss", level: 1 },
                  { id: "doublekick", level: 1 },
                  { id: "voltswitch", level: 30 },
               ],
               abilities: ["static", "lightningrod"],
            },
            Nidoking: {
               id: "nidoking",
               name: "Nidoking",
               types: ["Poison", "Ground"],
               baseStats: {
                  hp: 81,
                  attack: 102,
                  defense: 77,
                  spAttack: 85,
                  spDefense: 75,
                  speed: 85,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/34.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/34.gif",
               learnset: [
                  { id: "earthquake", level: 1 },
                  { id: "megahorn", level: 1 },
                  { id: "sludgewave", level: 1 },
                  { id: "thunderbolt", level: 1 },
                  { id: "fireblast", level: 40 },
               ],
               abilities: ["poisonpoint", "rivalry", "sheerforce"],
            },
            Golem: {
               id: "golem",
               name: "Golem",
               types: ["Rock", "Ground"],
               baseStats: {
                  hp: 80,
                  attack: 120,
                  defense: 130,
                  spAttack: 55,
                  spDefense: 65,
                  speed: 45,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/76.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/76.gif",
               learnset: [
                  { id: "stoneedge", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "explosion", level: 1 },
                  { id: "rockslide", level: 1 },
                  { id: "thunderpunch", level: 35 },
               ],
               abilities: ["rockhead", "sturdy", "sandveil"],
            },
            Starmie: {
               id: "starmie",
               name: "Starmie",
               types: ["Water", "Psychic"],
               baseStats: {
                  hp: 60,
                  attack: 75,
                  defense: 85,
                  spAttack: 100,
                  spDefense: 85,
                  speed: 115,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/121.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/121.gif",
               learnset: [
                  { id: "surf", level: 1 },
                  { id: "psychic", level: 1 },
                  { id: "thunderbolt", level: 1 },
                  { id: "icebeam", level: 1 },
                  { id: "rapidspin", level: 25 },
               ],
               abilities: ["illuminate", "naturalcure", "analytic"],
            },
            Jolteon: {
               id: "jolteon",
               name: "Jolteon",
               types: ["Electric"],
               baseStats: {
                  hp: 65,
                  attack: 65,
                  defense: 60,
                  spAttack: 110,
                  spDefense: 95,
                  speed: 130,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/135.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/135.gif",
               learnset: [
                  { id: "thunderbolt", level: 1 },
                  { id: "shadowball", level: 1 },
                  { id: "voltswitch", level: 1 },
                  { id: "thunder", level: 1 },
                  { id: "discharge", level: 40 },
               ],
               abilities: ["voltabsorb", "quickfeet"],
            },
            Flareon: {
               id: "flareon",
               name: "Flareon",
               types: ["Fire"],
               baseStats: {
                  hp: 65,
                  attack: 130,
                  defense: 60,
                  spAttack: 95,
                  spDefense: 110,
                  speed: 65,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/136.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/136.gif",
               learnset: [
                  { id: "flamethrower", level: 1 },
                  { id: "flareblitz", level: 1 },
                  { id: "superpower", level: 1 },
                  { id: "shadowball", level: 1 },
                  { id: "lavaplume", level: 45 },
               ],
               abilities: ["flashfire", "guts"],
            },
            Vaporeon: {
               id: "vaporeon",
               name: "Vaporeon",
               types: ["Water"],
               baseStats: {
                  hp: 130,
                  attack: 65,
                  defense: 60,
                  spAttack: 110,
                  spDefense: 95,
                  speed: 65,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/134.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/134.gif",
               learnset: [
                  { id: "surf", level: 1 },
                  { id: "icebeam", level: 1 },
                  { id: "shadowball", level: 1 },
                  { id: "wish", level: 1 },
                  { id: "scald", level: 40 },
               ],
               abilities: ["waterabsorb", "hydration"],
            },
            Feraligatr: {
               id: "feraligatr",
               name: "Feraligatr",
               types: ["Water"],
               baseStats: {
                  hp: 85,
                  attack: 105,
                  defense: 100,
                  spAttack: 79,
                  spDefense: 83,
                  speed: 78,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/160.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/160.gif",
               learnset: [
                  { id: "aquajet", level: 1 },
                  { id: "crunch", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "icepunch", level: 1 },
                  { id: "dragondance", level: 45 },
               ],
               abilities: ["torrent", "sheerforce"],
            },
            Typhlosion: {
               id: "typhlosion",
               name: "Typhlosion",
               types: ["Fire"],
               baseStats: {
                  hp: 78,
                  attack: 84,
                  defense: 78,
                  spAttack: 109,
                  spDefense: 85,
                  speed: 100,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/157.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/157.gif",
               learnset: [
                  { id: "eruption", level: 1 },
                  { id: "flamethrower", level: 1 },
                  { id: "thunderpunch", level: 1 },
                  { id: "solarbeam", level: 1 },
                  { id: "focusblast", level: 50 },
               ],
               abilities: ["blaze", "flashfire"],
            },
            Heracross: {
               id: "heracross",
               name: "Heracross",
               types: ["Bug", "Fighting"],
               baseStats: {
                  hp: 80,
                  attack: 125,
                  defense: 75,
                  spAttack: 40,
                  spDefense: 95,
                  speed: 85,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/214.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/214.gif",
               learnset: [
                  { id: "megahorn", level: 1 },
                  { id: "closecombat", level: 1 },
                  { id: "stoneedge", level: 1 },
                  { id: "nightslash", level: 1 },
                  { id: "swordsdance", level: 35 },
               ],
               abilities: ["swarm", "guts", "moxie"],
            },
            Skarmory: {
               id: "skarmory",
               name: "Skarmory",
               types: ["Steel", "Flying"],
               baseStats: {
                  hp: 65,
                  attack: 80,
                  defense: 140,
                  spAttack: 40,
                  spDefense: 70,
                  speed: 70,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/227.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/227.gif",
               learnset: [
                  { id: "bravebird", level: 1 },
                  { id: "steelwing", level: 1 },
                  { id: "spikes", level: 1 },
                  { id: "whirlwind", level: 1 },
                  { id: "roost", level: 30 },
               ],
               abilities: ["keeneye", "sturdy", "weakarmor"],
            },
            Sceptile: {
               id: "sceptile",
               name: "Sceptile",
               types: ["Grass"],
               baseStats: {
                  hp: 70,
                  attack: 85,
                  defense: 65,
                  spAttack: 105,
                  spDefense: 85,
                  speed: 120,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/254.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/254.gif",
               learnset: [
                  { id: "leafblade", level: 1 },
                  { id: "dragonpulse", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "focusblast", level: 1 },
                  { id: "leafstorm", level: 50 },
               ],
               abilities: ["overgrow", "unburden"],
            },
            Flygon: {
               id: "flygon",
               name: "Flygon",
               types: ["Ground", "Dragon"],
               baseStats: {
                  hp: 80,
                  attack: 100,
                  defense: 80,
                  spAttack: 80,
                  spDefense: 80,
                  speed: 100,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/330.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/330.gif",
               learnset: [
                  { id: "earthquake", level: 1 },
                  { id: "dragonrush", level: 1 },
                  { id: "fireblast", level: 1 },
                  { id: "uturn", level: 1 },
                  { id: "boomburst", level: 55 },
               ],
               abilities: ["levitate"],
            },
            Absol: {
               id: "absol",
               name: "Absol",
               types: ["Dark"],
               baseStats: {
                  hp: 65,
                  attack: 130,
                  defense: 60,
                  spAttack: 75,
                  spDefense: 60,
                  speed: 75,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/359.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/359.gif",
               learnset: [
                  { id: "nightslash", level: 1 },
                  { id: "psychocut", level: 1 },
                  { id: "swordsdance", level: 1 },
                  { id: "superpower", level: 1 },
                  { id: "megahorn", level: 45 },
               ],
               abilities: ["pressure", "superluck", "justified"],
            },
            Garchomp: {
               id: "garchomp",
               name: "Garchomp",
               types: ["Dragon", "Ground"],
               baseStats: {
                  hp: 108,
                  attack: 130,
                  defense: 95,
                  spAttack: 80,
                  spDefense: 85,
                  speed: 102,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/445.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/445.gif",
               learnset: [
                  { id: "dragonrush", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "stoneedge", level: 1 },
                  { id: "swordsdance", level: 1 },
                  { id: "outrage", level: 55 },
               ],
               abilities: ["sandrush", "roughskin"],
            },
            Dialga: {
               id: "dialga",
               name: "Dialga",
               types: ["Steel", "Dragon"],
               baseStats: {
                  hp: 100,
                  attack: 120,
                  defense: 120,
                  spAttack: 150,
                  spDefense: 100,
                  speed: 90,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/483.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/483.gif",
               learnset: [
                  { id: "roaroftime", level: 1 },
                  { id: "dragonpulse", level: 1 },
                  { id: "flashcannon", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "thunder", level: 50 },
               ],
               abilities: ["pressure", "telepathy"],
            },
            Palkia: {
               id: "palkia",
               name: "Palkia",
               types: ["Water", "Dragon"],
               baseStats: {
                  hp: 90,
                  attack: 120,
                  defense: 100,
                  spAttack: 150,
                  spDefense: 120,
                  speed: 100,
               },
               sprite:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/484.gif",
               spriteBack:
                  "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/back/484.gif",
               learnset: [
                  { id: "spacialrend", level: 1 },
                  { id: "hydropump", level: 1 },
                  { id: "dragonpulse", level: 1 },
                  { id: "earthquake", level: 1 },
                  { id: "fireblast", level: 50 },
               ],
               abilities: ["pressure", "telepathy"],
            },
         };

         // Merge extended Pokemon data if available
         if (typeof EXTENDED_POKEMON_DATA !== "undefined") {
            Object.assign(POKEMON_DATA, EXTENDED_POKEMON_DATA);
            console.log(
               "Extended Pokemon data loaded! Total Pokemon:",
               Object.keys(POKEMON_DATA).length
            );
         }

         const MOVES_DATA = {
            tackle: {
               id: "tackle",
               name: "Tackle",
               type: "Normal",
               category: "physical",
               power: 40,
               accuracy: 100,
               pp: 35,
               priority: 0,
               description: "A physical attack.",
               animation: "contact",
            },
            quickattack: {
               id: "quickattack",
               name: "Quick Attack",
               type: "Normal",
               category: "physical",
               power: 40,
               accuracy: 100,
               pp: 30,
               priority: 1,
               description: "Always strikes first.",
               animation: "quick",
            },
            extremespeed: {
               id: "extremespeed",
               name: "Extreme Speed",
               type: "Normal",
               category: "physical",
               power: 80,
               accuracy: 100,
               pp: 5,
               priority: 2,
               description: "An extremely fast attack.",
               animation: "quick",
            },
            ember: {
               id: "ember",
               name: "Ember",
               type: "Fire",
               category: "special",
               power: 40,
               accuracy: 100,
               pp: 25,
               priority: 0,
               description: "May burn the target.",
               animation: "fire",
               secondary: { chance: 10, status: "burn" },
            },
            flamethrower: {
               id: "flamethrower",
               name: "Flamethrower",
               type: "Fire",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May burn the target.",
               animation: "fire",
               secondary: { chance: 10, status: "burn" },
            },
            watergun: {
               id: "watergun",
               name: "Water Gun",
               type: "Water",
               category: "special",
               power: 40,
               accuracy: 100,
               pp: 25,
               priority: 0,
               description: "Squirts water at the target.",
               animation: "water",
            },
            surf: {
               id: "surf",
               name: "Surf",
               type: "Water",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "A powerful water attack.",
               animation: "water",
               targets: "allAdjacent",
            },
            waterfall: {
               id: "waterfall",
               name: "Waterfall",
               type: "Water",
               category: "physical",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May make the target flinch.",
               animation: "contact",
               secondary: { chance: 20, volatileStatus: "flinch" },
            },
            thundershock: {
               id: "thundershock",
               name: "Thunder Shock",
               type: "Electric",
               category: "special",
               power: 40,
               accuracy: 100,
               pp: 30,
               priority: 0,
               description: "May paralyze the target.",
               animation: "electric",
               secondary: { chance: 10, status: "paralysis" },
            },
            thunderbolt: {
               id: "thunderbolt",
               name: "Thunderbolt",
               type: "Electric",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May paralyze the target.",
               animation: "electric",
               secondary: { chance: 10, status: "paralysis" },
            },
            thunder: {
               id: "thunder",
               name: "Thunder",
               type: "Electric",
               category: "special",
               power: 110,
               accuracy: 70,
               pp: 10,
               priority: 0,
               description: "May paralyze. Never misses in rain.",
               animation: "electric",
               secondary: { chance: 30, status: "paralysis" },
            },
            thunderwave: {
               id: "thunderwave",
               name: "Thunder Wave",
               type: "Electric",
               category: "status",
               power: null,
               accuracy: 90,
               pp: 20,
               priority: 0,
               description: "Paralyzes the target.",
               animation: "electric",
               status: "paralysis",
            },
            vinewhip: {
               id: "vinewhip",
               name: "Vine Whip",
               type: "Grass",
               category: "physical",
               power: 45,
               accuracy: 100,
               pp: 25,
               priority: 0,
               description: "Whips the target with vines.",
               animation: "grass",
            },
            razorleaf: {
               id: "razorleaf",
               name: "Razor Leaf",
               type: "Grass",
               category: "physical",
               power: 55,
               accuracy: 95,
               pp: 25,
               priority: 0,
               description: "High critical hit ratio.",
               animation: "grass",
               critRatio: 2,
            },
            solarbeam: {
               id: "solarbeam",
               name: "Solar Beam",
               type: "Grass",
               category: "special",
               power: 120,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Charges turn 1, attacks turn 2.",
               animation: "grass",
               flags: { charge: true, sunshine: true },
            },
            sleeppowder: {
               id: "sleeppowder",
               name: "Sleep Powder",
               type: "Grass",
               category: "status",
               power: null,
               accuracy: 75,
               pp: 15,
               priority: 0,
               description: "Puts the target to sleep.",
               animation: "powder",
               status: "sleep",
            },
            synthesis: {
               id: "synthesis",
               name: "Synthesis",
               type: "Grass",
               category: "status",
               power: null,
               accuracy: null,
               pp: 5,
               priority: 0,
               description: "Restores HP. More in sun.",
               animation: "heal",
               flags: { heal: true },
            },
            icebeam: {
               id: "icebeam",
               name: "Ice Beam",
               type: "Ice",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "May freeze the target.",
               animation: "ice",
               secondary: { chance: 10, status: "freeze" },
            },
            blizzard: {
               id: "blizzard",
               name: "Blizzard",
               type: "Ice",
               category: "special",
               power: 110,
               accuracy: 70,
               pp: 5,
               priority: 0,
               description: "May freeze. Never misses in hail.",
               animation: "ice",
               secondary: { chance: 10, status: "freeze" },
            },
            icefang: {
               id: "icefang",
               name: "Ice Fang",
               type: "Ice",
               category: "physical",
               power: 65,
               accuracy: 95,
               pp: 15,
               priority: 0,
               description: "May freeze or flinch.",
               animation: "bite",
               secondary: { chance: 10, status: "freeze" },
            },
            closecombat: {
               id: "closecombat",
               name: "Close Combat",
               type: "Fighting",
               category: "physical",
               power: 120,
               accuracy: 100,
               pp: 5,
               priority: 0,
               description: "Lowers user's defenses.",
               animation: "contact",
               selfBoost: { defense: -1, spDefense: -1 },
            },
            aurasphere: {
               id: "aurasphere",
               name: "Aura Sphere",
               type: "Fighting",
               category: "special",
               power: 80,
               accuracy: null,
               pp: 20,
               priority: 0,
               description: "Never misses.",
               animation: "pulse",
            },
            focusblast: {
               id: "focusblast",
               name: "Focus Blast",
               type: "Fighting",
               category: "special",
               power: 120,
               accuracy: 70,
               pp: 5,
               priority: 0,
               description: "May lower Sp. Def.",
               animation: "pulse",
               secondary: { chance: 10, boost: { spDefense: -1 } },
            },
            sludgebomb: {
               id: "sludgebomb",
               name: "Sludge Bomb",
               type: "Poison",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "May poison the target.",
               animation: "poison",
               secondary: { chance: 30, status: "poison" },
            },
            toxic: {
               id: "toxic",
               name: "Toxic",
               type: "Poison",
               category: "status",
               power: null,
               accuracy: 90,
               pp: 10,
               priority: 0,
               description: "Badly poisons the target.",
               animation: "poison",
               status: "toxic",
            },
            earthquake: {
               id: "earthquake",
               name: "Earthquake",
               type: "Ground",
               category: "physical",
               power: 100,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Damages all Pokemon.",
               animation: "ground",
               targets: "allAdjacent",
            },
            airslash: {
               id: "airslash",
               name: "Air Slash",
               type: "Flying",
               category: "special",
               power: 75,
               accuracy: 95,
               pp: 15,
               priority: 0,
               description: "May cause flinching.",
               animation: "wind",
               secondary: { chance: 30, volatileStatus: "flinch" },
            },
            hurricane: {
               id: "hurricane",
               name: "Hurricane",
               type: "Flying",
               category: "special",
               power: 110,
               accuracy: 70,
               pp: 10,
               priority: 0,
               description: "May confuse. Never misses in rain.",
               animation: "wind",
               secondary: { chance: 30, volatileStatus: "confusion" },
            },
            psychic: {
               id: "psychic",
               name: "Psychic",
               type: "Psychic",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "May lower Sp. Def.",
               animation: "psychic",
               secondary: { chance: 10, boost: { spDefense: -1 } },
            },
            zenheadbutt: {
               id: "zenheadbutt",
               name: "Zen Headbutt",
               type: "Psychic",
               category: "physical",
               power: 80,
               accuracy: 90,
               pp: 15,
               priority: 0,
               description: "May cause flinching.",
               animation: "contact",
               secondary: { chance: 20, volatileStatus: "flinch" },
            },
            calmmind: {
               id: "calmmind",
               name: "Calm Mind",
               type: "Psychic",
               category: "status",
               power: null,
               accuracy: null,
               pp: 20,
               priority: 0,
               description: "Raises Sp. Atk and Sp. Def.",
               animation: "buff",
               selfBoost: { spAttack: 1, spDefense: 1 },
            },
            stoneedge: {
               id: "stoneedge",
               name: "Stone Edge",
               type: "Rock",
               category: "physical",
               power: 100,
               accuracy: 80,
               pp: 5,
               priority: 0,
               description: "High critical hit ratio.",
               animation: "rock",
               critRatio: 2,
            },
            shadowball: {
               id: "shadowball",
               name: "Shadow Ball",
               type: "Ghost",
               category: "special",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May lower Sp. Def.",
               animation: "shadow",
               secondary: { chance: 20, boost: { spDefense: -1 } },
            },
            dragonrush: {
               id: "dragonrush",
               name: "Dragon Rush",
               type: "Dragon",
               category: "physical",
               power: 100,
               accuracy: 75,
               pp: 10,
               priority: 0,
               description: "May cause flinching.",
               animation: "dragon",
               secondary: { chance: 20, volatileStatus: "flinch" },
            },
            dragonclaw: {
               id: "dragonclaw",
               name: "Dragon Claw",
               type: "Dragon",
               category: "physical",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "Slashes with claws.",
               animation: "claw",
            },
            dragonpulse: {
               id: "dragonpulse",
               name: "Dragon Pulse",
               type: "Dragon",
               category: "special",
               power: 85,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Attacks with a shock wave.",
               animation: "pulse",
            },
            dragonbreath: {
               id: "dragonbreath",
               name: "Dragon Breath",
               type: "Dragon",
               category: "special",
               power: 60,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "May paralyze the target.",
               animation: "dragon",
               secondary: { chance: 30, status: "paralysis" },
            },
            outrage: {
               id: "outrage",
               name: "Outrage",
               type: "Dragon",
               category: "physical",
               power: 120,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Attacks 2-3 turns, then confuses user.",
               animation: "contact",
               flags: { lockedmove: true },
            },
            dragondance: {
               id: "dragondance",
               name: "Dragon Dance",
               type: "Dragon",
               category: "status",
               power: null,
               accuracy: null,
               pp: 20,
               priority: 0,
               description: "Raises Attack and Speed.",
               animation: "dance",
               selfBoost: { attack: 1, speed: 1 },
            },
            bite: {
               id: "bite",
               name: "Bite",
               type: "Dark",
               category: "physical",
               power: 60,
               accuracy: 100,
               pp: 25,
               priority: 0,
               description: "May cause flinching.",
               animation: "bite",
               secondary: { chance: 30, volatileStatus: "flinch" },
            },
            foulplay: {
               id: "foulplay",
               name: "Foul Play",
               type: "Dark",
               category: "physical",
               power: 95,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "Uses target's Attack stat.",
               animation: "contact",
               flags: { useTargetAttack: true },
            },
            irontail: {
               id: "irontail",
               name: "Iron Tail",
               type: "Steel",
               category: "physical",
               power: 100,
               accuracy: 75,
               pp: 15,
               priority: 0,
               description: "May lower Defense.",
               animation: "contact",
               secondary: { chance: 30, boost: { defense: -1 } },
            },
            flashcannon: {
               id: "flashcannon",
               name: "Flash Cannon",
               type: "Steel",
               category: "special",
               power: 80,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "May lower Sp. Def.",
               animation: "beam",
               secondary: { chance: 10, boost: { spDefense: -1 } },
            },
            meteormash: {
               id: "meteormash",
               name: "Meteor Mash",
               type: "Steel",
               category: "physical",
               power: 90,
               accuracy: 90,
               pp: 10,
               priority: 0,
               description: "May raise Attack.",
               animation: "contact",
               secondary: { chance: 20, selfBoost: { attack: 1 } },
            },
            bulletpunch: {
               id: "bulletpunch",
               name: "Bullet Punch",
               type: "Steel",
               category: "physical",
               power: 40,
               accuracy: 100,
               pp: 30,
               priority: 1,
               description: "Always strikes first.",
               animation: "contact",
            },
            protect: {
               id: "protect",
               name: "Protect",
               type: "Normal",
               category: "status",
               power: null,
               accuracy: null,
               pp: 10,
               priority: 4,
               description: "Protects from attacks.",
               animation: "protect",
               flags: { protect: true },
            },
            swordsdance: {
               id: "swordsdance",
               name: "Swords Dance",
               type: "Normal",
               category: "status",
               power: null,
               accuracy: null,
               pp: 20,
               priority: 0,
               description: "Sharply raises Attack.",
               animation: "dance",
               selfBoost: { attack: 2 },
            },
            agility: {
               id: "agility",
               name: "Agility",
               type: "Psychic",
               category: "status",
               power: null,
               accuracy: null,
               pp: 30,
               priority: 0,
               description: "Sharply raises Speed.",
               animation: "buff",
               selfBoost: { speed: 2 },
            },
            wish: {
               id: "wish",
               name: "Wish",
               type: "Normal",
               category: "status",
               power: null,
               accuracy: null,
               pp: 10,
               priority: 0,
               description: "Heals next turn.",
               animation: "heal",
               flags: { wish: true },
            },
            moonlight: {
               id: "moonlight",
               name: "Moonlight",
               type: "Fairy",
               category: "status",
               power: null,
               accuracy: null,
               pp: 5,
               priority: 0,
               description: "Restores HP.",
               animation: "heal",
               flags: { heal: true },
            },
            hypnosis: {
               id: "hypnosis",
               name: "Hypnosis",
               type: "Psychic",
               category: "status",
               power: null,
               accuracy: 60,
               pp: 20,
               priority: 0,
               description: "Puts the target to sleep.",
               animation: "hypnosis",
               status: "sleep",
            },
            smokescreen: {
               id: "smokescreen",
               name: "Smokescreen",
               type: "Normal",
               category: "status",
               power: null,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "Lowers accuracy.",
               animation: "smoke",
               boost: { accuracy: -1 },
            },
            // Additional Physical Moves
            bodyslam: {
               id: "bodyslam",
               name: "Body Slam",
               type: "Normal",
               category: "physical",
               power: 85,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May cause paralysis.",
               animation: "contact",
               secondary: { chance: 30, status: "paralysis" },
            },
            doubleEdge: {
               id: "doubleedge",
               name: "Double-Edge",
               type: "Normal",
               category: "physical",
               power: 120,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "User takes 1/3 recoil damage.",
               animation: "contact",
               recoil: 0.33,
            },
            headsmash: {
               id: "headsmash",
               name: "Head Smash",
               type: "Rock",
               category: "physical",
               power: 150,
               accuracy: 80,
               pp: 5,
               priority: 0,
               description: "User takes 1/2 recoil damage.",
               animation: "contact",
               recoil: 0.5,
            },
            gigaimpact: {
               id: "gigaimpact",
               name: "Giga Impact",
               type: "Normal",
               category: "physical",
               power: 150,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "User must recharge next turn.",
               animation: "contact",
               flags: { recharge: true },
            },
            // Fighting Moves
            dynamicpunch: {
               id: "dynamicpunch",
               name: "Dynamic Punch",
               type: "Fighting",
               category: "physical",
               power: 100,
               accuracy: 50,
               pp: 5,
               priority: 0,
               description: "Always confuses target if it hits.",
               animation: "punch",
               secondary: { chance: 100, status: "confusion" },
            },
            skyuppercut: {
               id: "skyuppercut",
               name: "Sky Uppercut",
               type: "Fighting",
               category: "physical",
               power: 85,
               accuracy: 90,
               pp: 15,
               priority: 0,
               description: "Can hit flying Pokemon.",
               animation: "punch",
               flags: { punch: true },
            },
            blazekick: {
               id: "blazekick",
               name: "Blaze Kick",
               type: "Fire",
               category: "physical",
               power: 85,
               accuracy: 90,
               pp: 10,
               priority: 0,
               description: "High critical hit ratio. May burn.",
               animation: "kick",
               critRatio: 2,
               secondary: { chance: 10, status: "burn" },
            },
            // Elemental Punches
            thunderpunch: {
               id: "thunderpunch",
               name: "Thunder Punch",
               type: "Electric",
               category: "physical",
               power: 75,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May cause paralysis.",
               animation: "punch",
               secondary: { chance: 10, status: "paralysis" },
            },
            icepunch: {
               id: "icepunch",
               name: "Ice Punch",
               type: "Ice",
               category: "physical",
               power: 75,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May cause freeze.",
               animation: "punch",
               secondary: { chance: 10, status: "freeze" },
            },
            firepunch: {
               id: "firepunch",
               name: "Fire Punch",
               type: "Fire",
               category: "physical",
               power: 75,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May cause burn.",
               animation: "punch",
               secondary: { chance: 10, status: "burn" },
            },
            // Fang Moves
            thunderfang: {
               id: "thunderfang",
               name: "Thunder Fang",
               type: "Electric",
               category: "physical",
               power: 65,
               accuracy: 95,
               pp: 15,
               priority: 0,
               description: "May cause paralysis or flinch.",
               animation: "bite",
               secondary: { chance: 10, status: "paralysis" },
            },
            icefang: {
               id: "icefang",
               name: "Ice Fang",
               type: "Ice",
               category: "physical",
               power: 65,
               accuracy: 95,
               pp: 15,
               priority: 0,
               description: "May cause freeze or flinch.",
               animation: "bite",
               secondary: { chance: 10, status: "freeze" },
            },
            // Special Signature Moves
            overheat: {
               id: "overheat",
               name: "Overheat",
               type: "Fire",
               category: "special",
               power: 130,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "Lowers user's Sp. Attack by 2 stages.",
               animation: "fire",
               selfBoost: { spAttack: -2 },
            },
            leafstorm: {
               id: "leafstorm",
               name: "Leaf Storm",
               type: "Grass",
               category: "special",
               power: 130,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "Lowers user's Sp. Attack by 2 stages.",
               animation: "grass",
               selfBoost: { spAttack: -2 },
            },
            muddywater: {
               id: "muddywater",
               name: "Muddy Water",
               type: "Water",
               category: "special",
               power: 90,
               accuracy: 85,
               pp: 10,
               priority: 0,
               description: "May lower accuracy.",
               animation: "water",
               secondary: { chance: 30, boost: { accuracy: -1 } },
            },
            // Steel Moves
            ironhead: {
               id: "ironhead",
               name: "Iron Head",
               type: "Steel",
               category: "physical",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May cause flinch.",
               animation: "contact",
               secondary: { chance: 30, volatileStatus: "flinch" },
            },
            meteormash: {
               id: "meteormash",
               name: "Meteor Mash",
               type: "Steel",
               category: "physical",
               power: 90,
               accuracy: 90,
               pp: 10,
               priority: 0,
               description: "May raise user's Attack.",
               animation: "punch",
               secondary: { chance: 20, selfBoost: { attack: 1 } },
            },
            bulletpunch: {
               id: "bulletpunch",
               name: "Bullet Punch",
               type: "Steel",
               category: "physical",
               power: 40,
               accuracy: 100,
               pp: 30,
               priority: 1,
               description: "Always strikes first.",
               animation: "punch",
               flags: { punch: true },
            },
            heavyslam: {
               id: "heavyslam",
               name: "Heavy Slam",
               type: "Steel",
               category: "physical",
               power: 80,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "More damage if user is heavier.",
               animation: "contact",
            },
            // Psychic Moves
            zenheadbutt: {
               id: "zenheadbutt",
               name: "Zen Headbutt",
               type: "Psychic",
               category: "physical",
               power: 80,
               accuracy: 90,
               pp: 15,
               priority: 0,
               description: "May cause flinch.",
               animation: "contact",
               secondary: { chance: 20, volatileStatus: "flinch" },
            },
            // Flying Moves
            acrobatics: {
               id: "acrobatics",
               name: "Acrobatics",
               type: "Flying",
               category: "physical",
               power: 55,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "Double power if user has no item.",
               animation: "flying",
            },
            skyattack: {
               id: "skyattack",
               name: "Sky Attack",
               type: "Flying",
               category: "physical",
               power: 140,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "Charges on first turn, attacks on second.",
               animation: "flying",
               flags: { charge: true },
               critRatio: 2,
            },
            // Grass Moves
            energyball: {
               id: "energyball",
               name: "Energy Ball",
               type: "Grass",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "May lower Sp. Defense.",
               animation: "grass",
               secondary: { chance: 10, boost: { spDefense: -1 } },
            },
            // Dark Moves
            foulplay: {
               id: "foulplay",
               name: "Foul Play",
               type: "Dark",
               category: "physical",
               power: 95,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "Uses target's Attack stat.",
               animation: "dark",
            },
            // Poison Moves
            crosspoison: {
               id: "crosspoison",
               name: "Cross Poison",
               type: "Poison",
               category: "physical",
               power: 70,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "High critical hit ratio. May poison.",
               animation: "slash",
               critRatio: 2,
               secondary: { chance: 10, status: "poison" },
            },
            // Electric Moves
            voltswitch: {
               id: "voltswitch",
               name: "Volt Switch",
               type: "Electric",
               category: "special",
               power: 70,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "User switches out after attacking.",
               animation: "electric",
               flags: { voltTurn: true },
            },
            zapcannon: {
               id: "zapcannon",
               name: "Zap Cannon",
               type: "Electric",
               category: "special",
               power: 120,
               accuracy: 50,
               pp: 5,
               priority: 0,
               description: "Always paralyzes if it hits.",
               animation: "electric",
               secondary: { chance: 100, status: "paralysis" },
            },
            // Fairy Moves
            dazzlinggleam: {
               id: "dazzlinggleam",
               name: "Dazzling Gleam",
               type: "Fairy",
               category: "special",
               power: 80,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Hits all adjacent opponents.",
               animation: "fairy",
            },
            // Multi-hit Moves
            triattack: {
               id: "triattack",
               name: "Tri Attack",
               type: "Normal",
               category: "special",
               power: 80,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "May burn, freeze, or paralyze.",
               animation: "beam",
               secondary: { chance: 20, status: "random" },
            },
            // Recovery Moves
            recover: {
               id: "recover",
               name: "Recover",
               type: "Normal",
               category: "status",
               power: null,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Restores 50% of max HP.",
               animation: "heal",
               flags: { heal: true },
            },
            rest: {
               id: "rest",
               name: "Rest",
               type: "Psychic",
               category: "status",
               power: null,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Fully heals HP and cures status, but causes sleep.",
               animation: "sleep",
               flags: { fullHeal: true, sleep: true },
            },
            roost: {
               id: "roost",
               name: "Roost",
               type: "Flying",
               category: "status",
               power: null,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Restores 50% of max HP.",
               animation: "heal",
               flags: { heal: true },
            },
            // Utility Moves
            uturn: {
               id: "uturn",
               name: "U-turn",
               type: "Bug",
               category: "physical",
               power: 70,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "User switches out after attacking.",
               animation: "contact",
               flags: { voltTurn: true },
            },
            dragontail: {
               id: "dragontail",
               name: "Dragon Tail",
               type: "Dragon",
               category: "physical",
               power: 60,
               accuracy: 90,
               pp: 10,
               priority: -6,
               description: "Forces opponent to switch out.",
               animation: "tail",
               flags: { forceSwitch: true },
            },
            guillotine: {
               id: "guillotine",
               name: "Guillotine",
               type: "Normal",
               category: "physical",
               power: null,
               accuracy: 30,
               pp: 5,
               priority: 0,
               description: "One-hit KO move.",
               animation: "slash",
               flags: { ohko: true },
            },
            // Additional Physical Moves
            seismictoss: {
               id: "seismictoss",
               name: "Seismic Toss",
               type: "Fighting",
               category: "physical",
               power: null,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "Damage equals user's level.",
               animation: "contact",
               flags: { levelDamage: true },
            },
            doublekick: {
               id: "doublekick",
               name: "Double Kick",
               type: "Fighting",
               category: "physical",
               power: 30,
               accuracy: 100,
               pp: 30,
               priority: 0,
               description: "Hits twice.",
               animation: "kick",
               flags: { multihit: 2 },
            },
            rockslide: {
               id: "rockslide",
               name: "Rock Slide",
               type: "Rock",
               category: "physical",
               power: 75,
               accuracy: 90,
               pp: 10,
               priority: 0,
               description: "May cause flinching.",
               animation: "rock",
               secondary: { chance: 30, volatileStatus: "flinch" },
            },
            explosion: {
               id: "explosion",
               name: "Explosion",
               type: "Normal",
               category: "physical",
               power: 250,
               accuracy: 100,
               pp: 5,
               priority: 0,
               description: "User faints. High power.",
               animation: "explosion",
               flags: { explosion: true },
            },
            megahorn: {
               id: "megahorn",
               name: "Megahorn",
               type: "Bug",
               category: "physical",
               power: 120,
               accuracy: 85,
               pp: 10,
               priority: 0,
               description: "Powerful horn attack.",
               animation: "contact",
            },
            leafblade: {
               id: "leafblade",
               name: "Leaf Blade",
               type: "Grass",
               category: "physical",
               power: 90,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "High critical hit ratio.",
               animation: "slash",
               critRatio: 2,
            },
            nightslash: {
               id: "nightslash",
               name: "Night Slash",
               type: "Dark",
               category: "physical",
               power: 70,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "High critical hit ratio.",
               animation: "slash",
               critRatio: 2,
            },
            psychocut: {
               id: "psychocut",
               name: "Psycho Cut",
               type: "Psychic",
               category: "physical",
               power: 70,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "High critical hit ratio.",
               animation: "slash",
               critRatio: 2,
            },
            // Special Signature Moves
            eruption: {
               id: "eruption",
               name: "Eruption",
               type: "Fire",
               category: "special",
               power: 150,
               accuracy: 100,
               pp: 5,
               priority: 0,
               description: "Power depends on user's HP.",
               animation: "fire",
               flags: { variablePower: true },
            },
            roaroftime: {
               id: "roaroftime",
               name: "Roar of Time",
               type: "Dragon",
               category: "special",
               power: 150,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "User must recharge next turn.",
               animation: "dragon",
               flags: { recharge: true },
            },
            spacialrend: {
               id: "spacialrend",
               name: "Spacial Rend",
               type: "Dragon",
               category: "special",
               power: 100,
               accuracy: 95,
               pp: 5,
               priority: 0,
               description: "High critical hit ratio.",
               animation: "dragon",
               critRatio: 2,
            },
            flareblitz: {
               id: "flareblitz",
               name: "Flare Blitz",
               type: "Fire",
               category: "physical",
               power: 120,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "User takes recoil. May burn target.",
               animation: "contact",
               recoil: 0.33,
               secondary: { chance: 10, status: "burn" },
            },
            bravebird: {
               id: "bravebird",
               name: "Brave Bird",
               type: "Flying",
               category: "physical",
               power: 120,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "User takes recoil damage.",
               animation: "flying",
               recoil: 0.33,
            },
            aquajet: {
               id: "aquajet",
               name: "Aqua Jet",
               type: "Water",
               category: "physical",
               power: 40,
               accuracy: 100,
               pp: 20,
               priority: 1,
               description: "Always strikes first.",
               animation: "water",
            },
            // Special Elemental Moves
            discharge: {
               id: "discharge",
               name: "Discharge",
               type: "Electric",
               category: "special",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May paralyze. Hits all adjacent Pokemon.",
               animation: "electric",
               secondary: { chance: 30, status: "paralysis" },
               targets: "allAdjacent",
            },
            lavaplume: {
               id: "lavaplume",
               name: "Lava Plume",
               type: "Fire",
               category: "special",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May burn. Hits all adjacent Pokemon.",
               animation: "fire",
               secondary: { chance: 30, status: "burn" },
               targets: "allAdjacent",
            },
            scald: {
               id: "scald",
               name: "Scald",
               type: "Water",
               category: "special",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May burn the target.",
               animation: "water",
               secondary: { chance: 30, status: "burn" },
            },
            sludgewave: {
               id: "sludgewave",
               name: "Sludge Wave",
               type: "Poison",
               category: "special",
               power: 95,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "May poison. Hits all adjacent Pokemon.",
               animation: "poison",
               secondary: { chance: 10, status: "poison" },
               targets: "allAdjacent",
            },
            // Steel and Rock Moves
            steelwing: {
               id: "steelwing",
               name: "Steel Wing",
               type: "Steel",
               category: "physical",
               power: 70,
               accuracy: 90,
               pp: 25,
               priority: 0,
               description: "May raise user's Defense.",
               animation: "wing",
               secondary: { chance: 10, selfBoost: { defense: 1 } },
            },
            // Sound Moves
            boomburst: {
               id: "boomburst",
               name: "Boomburst",
               type: "Normal",
               category: "special",
               power: 140,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Affects all Pokemon. Sound-based.",
               animation: "sound",
               targets: "allAdjacent",
               flags: { sound: true },
            },
            // Utility Moves
            rapidspin: {
               id: "rapidspin",
               name: "Rapid Spin",
               type: "Normal",
               category: "physical",
               power: 50,
               accuracy: 100,
               pp: 40,
               priority: 0,
               description: "Removes hazards and increases speed.",
               animation: "spin",
               selfBoost: { speed: 1 },
               flags: { removeHazards: true },
            },
            spikes: {
               id: "spikes",
               name: "Spikes",
               type: "Ground",
               category: "status",
               power: null,
               accuracy: null,
               pp: 20,
               priority: 0,
               description: "Damages switching Pokemon.",
               animation: "ground",
               flags: { hazard: true },
            },
            whirlwind: {
               id: "whirlwind",
               name: "Whirlwind",
               type: "Normal",
               category: "status",
               power: null,
               accuracy: null,
               pp: 20,
               priority: -6,
               description: "Forces opponent to switch.",
               animation: "wind",
               flags: { forceSwitch: true },
            },
            superpower: {
               id: "superpower",
               name: "Superpower",
               type: "Fighting",
               category: "physical",
               power: 120,
               accuracy: 100,
               pp: 5,
               priority: 0,
               description: "Lowers user's Attack and Defense.",
               animation: "contact",
               selfBoost: { attack: -1, defense: -1 },
            },
            crunch: {
               id: "crunch",
               name: "Crunch",
               type: "Dark",
               category: "physical",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May lower Defense.",
               animation: "bite",
               secondary: { chance: 20, boost: { defense: -1 } },
            },
            // Missing Essential Moves
            fireblast: {
               id: "fireblast",
               name: "Fire Blast",
               type: "Fire",
               category: "special",
               power: 110,
               accuracy: 85,
               pp: 5,
               priority: 0,
               description: "May burn the target.",
               animation: "fire",
               secondary: { chance: 10, status: "burn" },
            },
            hydropump: {
               id: "hydropump",
               name: "Hydro Pump",
               type: "Water",
               category: "special",
               power: 110,
               accuracy: 80,
               pp: 5,
               priority: 0,
               description: "High power water attack.",
               animation: "water",
            },
            thunderpunch: {
               id: "thunderpunch",
               name: "Thunder Punch",
               type: "Electric",
               category: "physical",
               power: 75,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May paralyze the target.",
               animation: "punch",
               secondary: { chance: 10, status: "paralysis" },
            },
            firepunch: {
               id: "firepunch",
               name: "Fire Punch",
               type: "Fire",
               category: "physical",
               power: 75,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May burn the target.",
               animation: "punch",
               secondary: { chance: 10, status: "burn" },
            },
            icepunch: {
               id: "icepunch",
               name: "Ice Punch",
               type: "Ice",
               category: "physical",
               power: 75,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May freeze the target.",
               animation: "punch",
               secondary: { chance: 10, status: "freeze" },
            },
            voltswitch: {
               id: "voltswitch",
               name: "Volt Switch",
               type: "Electric",
               category: "special",
               power: 70,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "User switches out after attacking.",
               animation: "electric",
               flags: { switchOut: true },
            },
            crosspoison: {
               id: "crosspoison",
               name: "Cross Poison",
               type: "Poison",
               category: "physical",
               power: 70,
               accuracy: 100,
               pp: 20,
               priority: 0,
               description: "High critical hit ratio. May poison.",
               animation: "slash",
               critRatio: 2,
               secondary: { chance: 10, status: "poison" },
            },
            muddywater: {
               id: "muddywater",
               name: "Muddy Water",
               type: "Water",
               category: "special",
               power: 90,
               accuracy: 85,
               pp: 10,
               priority: 0,
               description: "May lower accuracy.",
               animation: "water",
               secondary: { chance: 30, boost: { accuracy: -1 } },
            },
            heavyslam: {
               id: "heavyslam",
               name: "Heavy Slam",
               type: "Steel",
               category: "physical",
               power: null,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "Power depends on weight difference.",
               animation: "contact",
               flags: { variablePower: true },
            },
            gigaimpact: {
               id: "gigaimpact",
               name: "Giga Impact",
               type: "Normal",
               category: "physical",
               power: 150,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "User must recharge next turn.",
               animation: "contact",
               flags: { recharge: true },
            },
            overheat: {
               id: "overheat",
               name: "Overheat",
               type: "Fire",
               category: "special",
               power: 130,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "Lowers user's Special Attack.",
               animation: "fire",
               selfBoost: { spAttack: -2 },
            },
            zapcannon: {
               id: "zapcannon",
               name: "Zap Cannon",
               type: "Electric",
               category: "special",
               power: 120,
               accuracy: 50,
               pp: 5,
               priority: 0,
               description: "Always paralyzes if it hits.",
               animation: "electric",
               secondary: { chance: 100, status: "paralysis" },
            },
            leafstorm: {
               id: "leafstorm",
               name: "Leaf Storm",
               type: "Grass",
               category: "special",
               power: 130,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "Lowers user's Special Attack.",
               animation: "grass",
               selfBoost: { spAttack: -2 },
            },
            // Core Battle Moves
            surf: {
               id: "surf",
               name: "Surf",
               type: "Water",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "Hits all adjacent Pokemon.",
               animation: "water",
               targets: "allAdjacent",
            },
            icebeam: {
               id: "icebeam",
               name: "Ice Beam",
               type: "Ice",
               category: "special",
               power: 90,
               accuracy: 100,
               pp: 10,
               priority: 0,
               description: "May freeze the target.",
               animation: "ice",
               secondary: { chance: 10, status: "freeze" },
            },
            shadowball: {
               id: "shadowball",
               name: "Shadow Ball",
               type: "Ghost",
               category: "special",
               power: 80,
               accuracy: 100,
               pp: 15,
               priority: 0,
               description: "May lower Special Defense.",
               animation: "ghost",
               secondary: { chance: 20, boost: { spDefense: -1 } },
            },
            wish: {
               id: "wish",
               name: "Wish",
               type: "Normal",
               category: "status",
               power: null,
               accuracy: null,
               pp: 10,
               priority: 0,
               description: "Restores HP on the next turn.",
               animation: "heal",
               flags: { delayedHeal: true },
            },
            icefang: {
               id: "icefang",
               name: "Ice Fang",
               type: "Ice",
               category: "physical",
               power: 65,
               accuracy: 95,
               pp: 15,
               priority: 0,
               description: "May freeze or cause flinching.",
               animation: "bite",
               secondary: { chance: 10, status: "freeze" },
            },
            swordsdance: {
               id: "swordsdance",
               name: "Swords Dance",
               type: "Normal",
               category: "status",
               power: null,
               accuracy: null,
               pp: 20,
               priority: 0,
               description: "Sharply raises Attack.",
               animation: "boost",
               selfBoost: { attack: 2 },
            },
            calmmind: {
               id: "calmmind",
               name: "Calm Mind",
               type: "Psychic",
               category: "status",
               power: null,
               accuracy: null,
               pp: 20,
               priority: 0,
               description: "Raises Special Attack and Special Defense.",
               animation: "boost",
               selfBoost: { spAttack: 1, spDefense: 1 },
            },
            synthesis: {
               id: "synthesis",
               name: "Synthesis",
               type: "Grass",
               category: "status",
               power: null,
               accuracy: null,
               pp: 5,
               priority: 0,
               description: "Restores HP. Amount varies with weather.",
               animation: "heal",
               flags: { healing: true },
            },
            roost: {
               id: "roost",
               name: "Roost",
               type: "Flying",
               category: "status",
               power: null,
               accuracy: null,
               pp: 10,
               priority: 0,
               description: "Restores HP.",
               animation: "heal",
               flags: { healing: true },
            },
            skyattack: {
               id: "skyattack",
               name: "Sky Attack",
               type: "Flying",
               category: "physical",
               power: 140,
               accuracy: 90,
               pp: 5,
               priority: 0,
               description: "Two-turn attack with high critical hit ratio.",
               animation: "flying",
               critRatio: 2,
               flags: { twoTurn: true },
            },
            moonlight: {
               id: "moonlight",
               name: "Moonlight",
               type: "Fairy",
               category: "status",
               power: null,
               accuracy: null,
               pp: 5,
               priority: 0,
               description: "Restores HP. Amount varies with weather.",
               animation: "heal",
               flags: { healing: true },
            },
         };

         const ABILITIES_DATA = {
            drought: {
               id: "drought",
               name: "Drought",
               description: "Turns the sunlight harsh when entering battle.",
               onSwitchIn: (battle, pokemon) => {
                  battle.setWeather(WEATHER_TYPES.SUN, 5);
                  return `${pokemon.name}'s Drought intensified the sun's rays!`;
               },
            },
            drizzle: {
               id: "drizzle",
               name: "Drizzle",
               description: "Makes it rain when entering battle.",
               onSwitchIn: (battle, pokemon) => {
                  battle.setWeather(WEATHER_TYPES.RAIN, 5);
                  return `${pokemon.name}'s Drizzle made it rain!`;
               },
            },
            sandstream: {
               id: "sandstream",
               name: "Sand Stream",
               description: "Summons a sandstorm when entering battle.",
               onSwitchIn: (battle, pokemon) => {
                  battle.setWeather(WEATHER_TYPES.SANDSTORM, 5);
                  return `${pokemon.name}'s Sand Stream whipped up a sandstorm!`;
               },
            },
            intimidate: {
               id: "intimidate",
               name: "Intimidate",
               description: "Lowers the foe's Attack stat.",
               onSwitchIn: (battle, pokemon) => {
                  const targets = battle.getOpponents(pokemon);
                  const messages = [];
                  targets.forEach((target) => {
                     if (
                        target.ability?.id !== "clearbody" &&
                        target.ability?.id !== "hypercutter"
                     ) {
                        target.boostStat("attack", -1);
                        messages.push(`${target.name}'s Attack fell!`);
                     }
                  });
                  return messages;
               },
            },
            speedboost: {
               id: "speedboost",
               name: "Speed Boost",
               description: "Raises Speed at the end of each turn.",
               onTurnEnd: (battle, pokemon) => {
                  pokemon.boostStat("speed", 1);
                  return `${pokemon.name}'s Speed Boost raised its Speed!`;
               },
            },
            // Damage Modifying Abilities
            levitate: {
               id: "levitate",
               name: "Levitate",
               description: "Gives immunity to Ground-type moves.",
               onBeforeReceiveDamage: (damage, move, attacker, defender) => {
                  if (move.type === "Ground") {
                     return {
                        damage: 0,
                        message: `${defender.name} avoids Ground moves with Levitate!`,
                     };
                  }
                  return { damage };
               },
            },
            adaptability: {
               id: "adaptability",
               name: "Adaptability",
               description: "Powers up moves of the same type.",
               onCalculateDamage: (damage, move, pokemon) => {
                  if (pokemon.types.includes(move.type)) {
                     return damage * 1.33; // STAB becomes 2x instead of 1.5x
                  }
                  return damage;
               },
            },
            // Status Abilities
            static: {
               id: "static",
               name: "Static",
               description: "Contact may paralyze the attacker.",
               onAfterBeingHit: (battle, pokemon, attacker, move) => {
                  if (move.flags?.contact && Math.random() < 0.3) {
                     attacker.setStatus("paralysis");
                     return `${attacker.name} was paralyzed by ${pokemon.name}'s Static!`;
                  }
               },
            },
            // Defensive Abilities
            multiscale: {
               id: "multiscale",
               name: "Multiscale",
               description: "Reduces damage when HP is full.",
               onBeforeReceiveDamage: (damage, move, attacker, defender) => {
                  if (defender.hp === defender.maxHp) {
                     return {
                        damage: Math.floor(damage * 0.5),
                        message: `${defender.name}'s Multiscale reduced the damage!`,
                     };
                  }
                  return { damage };
               },
            },
            // Utility Abilities
            regenerator: {
               id: "regenerator",
               name: "Regenerator",
               description: "Restores HP when switching out.",
               onSwitchOut: (battle, pokemon) => {
                  const healAmount = Math.floor(pokemon.maxHp / 3);
                  pokemon.heal(healAmount);
                  return `${pokemon.name} restored HP with Regenerator!`;
               },
            },
            // Type-changing Abilities
            protean: {
               id: "protean",
               name: "Protean",
               description: "Changes type to match the move used.",
               onBeforeMove: (battle, pokemon, move) => {
                  if (move.type && !pokemon.types.includes(move.type)) {
                     pokemon.types = [move.type];
                     return `${pokemon.name} became ${move.type} type!`;
                  }
               },
            },
            // Priority Abilities
            prankster: {
               id: "prankster",
               name: "Prankster",
               description: "Gives priority to status moves.",
               onModifyPriority: (priority, move) => {
                  if (move.category === "status") {
                     return priority + 1;
                  }
                  return priority;
               },
            },
            // Damage Boost Abilities
            sheerforce: {
               id: "sheerforce",
               name: "Sheer Force",
               description: "Removes secondary effects to increase move power.",
               onModifyMove: (move) => {
                  if (move.secondary || move.secondaries) {
                     move.power = Math.floor(move.power * 1.3);
                     delete move.secondary;
                     delete move.secondaries;
                  }
                  return move;
               },
            },
            // Weather-based Abilities
            chlorophyll: {
               id: "chlorophyll",
               name: "Chlorophyll",
               description: "Doubles Speed in harsh sunlight.",
               onModifyStat: (stat, value, pokemon, battle) => {
                  if (stat === "speed" && battle.weather === WEATHER_TYPES.SUN) {
                     return value * 2;
                  }
                  return value;
               },
            },
            swiftswim: {
               id: "swiftswim",
               name: "Swift Swim",
               description: "Doubles Speed in rain.",
               onModifyStat: (stat, value, pokemon, battle) => {
                  if (stat === "speed" && battle.weather === WEATHER_TYPES.RAIN) {
                     return value * 2;
                  }
                  return value;
               },
            },
            sandrush: {
               id: "sandrush",
               name: "Sand Rush",
               description: "Doubles Speed in a sandstorm.",
               onModifyStat: (stat, value, pokemon, battle) => {
                  if (stat === "speed" && battle.weather === WEATHER_TYPES.SANDSTORM) {
                     return value * 2;
                  }
                  return value;
               },
            },
            // Defensive Abilities
            sturdy: {
               id: "sturdy",
               name: "Sturdy",
               description: "Cannot be knocked out with one hit when at full HP.",
               onBeforeReceiveDamage: (damage, move, attacker, defender) => {
                  if (defender.hp === defender.maxHp && damage >= defender.hp) {
                     return {
                        damage: defender.hp - 1,
                        message: `${defender.name} endured the hit with Sturdy!`,
                     };
                  }
                  return { damage };
               },
            },
            // Starter Abilities
            overgrow: {
               id: "overgrow",
               name: "Overgrow",
               description: "Powers up Grass moves when HP is low.",
               onCalculateDamage: (damage, move, pokemon) => {
                  if (move.type === "Grass" && pokemon.hp <= pokemon.maxHp / 3) {
                     return damage * 1.5;
                  }
                  return damage;
               },
            },
            blaze: {
               id: "blaze",
               name: "Blaze",
               description: "Powers up Fire moves when HP is low.",
               onCalculateDamage: (damage, move, pokemon) => {
                  if (move.type === "Fire" && pokemon.hp <= pokemon.maxHp / 3) {
                     return damage * 1.5;
                  }
                  return damage;
               },
            },
            torrent: {
               id: "torrent",
               name: "Torrent",
               description: "Powers up Water moves when HP is low.",
               onCalculateDamage: (damage, move, pokemon) => {
                  if (move.type === "Water" && pokemon.hp <= pokemon.maxHp / 3) {
                     return damage * 1.5;
                  }
                  return damage;
               },
            },
            // Other Common Abilities
            synchronize: {
               id: "synchronize",
               name: "Synchronize",
               description: "Passes status problems to the foe.",
               onAfterStatusInflicted: (battle, pokemon, status, source) => {
                  if (source && ["burn", "poison", "paralysis"].includes(status)) {
                     source.setStatus(status);
                     return `${source.name} was affected by ${pokemon.name}'s Synchronize!`;
                  }
               },
            },
            innerfocus: {
               id: "innerfocus",
               name: "Inner Focus",
               description: "Prevents flinching.",
               onBeforeVolatileStatus: (status, pokemon) => {
                  if (status === "flinch") {
                     return {
                        prevented: true,
                        message: `${pokemon.name}'s Inner Focus prevents flinching!`,
                     };
                  }
               },
            },
            clearbody: {
               id: "clearbody",
               name: "Clear Body",
               description: "Prevents stat reduction.",
               onBeforeStatChange: (stat, stages, pokemon, source) => {
                  if (stages < 0 && source !== pokemon) {
                     return {
                        prevented: true,
                        message: `${pokemon.name}'s Clear Body prevents stat loss!`,
                     };
                  }
               },
            },
            moxie: {
               id: "moxie",
               name: "Moxie",
               description: "Boosts Attack after knocking out a Pokemon.",
               onAfterKnockout: (battle, pokemon) => {
                  pokemon.boostStat("attack", 1);
                  return `${pokemon.name}'s Moxie raised its Attack!`;
               },
            },
            magicguard: {
               id: "magicguard",
               name: "Magic Guard",
               description: "Only takes damage from attacks.",
               onResidualDamage: (damage, source) => {
                  if (source !== "attack") {
                     return 0;
                  }
                  return damage;
               },
            },
            roughskin: {
               id: "roughskin",
               name: "Rough Skin",
               description: "Inflicts damage on contact.",
               onAfterBeingHit: (battle, pokemon, attacker, move) => {
                  if (move.flags?.contact) {
                     const damage = Math.floor(attacker.maxHp / 8);
                     attacker.takeDamage(damage);
                     return `${attacker.name} was hurt by ${pokemon.name}'s Rough Skin!`;
                  }
               },
            },
            solarpower: {
               id: "solarpower",
               name: "Solar Power",
               description: "Boosts Sp. Atk in sun but loses HP.",
               onModifyStat: (stat, value, pokemon, battle) => {
                  if (stat === "spAttack" && battle.weather === WEATHER_TYPES.SUN) {
                     return value * 1.5;
                  }
                  return value;
               },
               onWeather: (battle, pokemon) => {
                  if (battle.weather === WEATHER_TYPES.SUN) {
                     const damage = Math.floor(pokemon.maxHp / 8);
                     pokemon.takeDamage(damage);
                     return `${pokemon.name} was hurt by the harsh sunlight!`;
                  }
               },
            },
            raindish: {
               id: "raindish",
               name: "Rain Dish",
               description: "Restores HP in rain.",
               onWeather: (battle, pokemon) => {
                  if (battle.weather === WEATHER_TYPES.RAIN) {
                     const heal = Math.floor(pokemon.maxHp / 16);
                     pokemon.heal(heal);
                     return `${pokemon.name} restored HP with Rain Dish!`;
                  }
               },
            },
            steadfast: {
               id: "steadfast",
               name: "Steadfast",
               description: "Raises Speed when flinched.",
               onFlinch: (battle, pokemon) => {
                  pokemon.boostStat("speed", 1);
                  return `${pokemon.name}'s Steadfast raised its Speed!`;
               },
            },
            lightmetal: {
               id: "lightmetal",
               name: "Light Metal",
               description: "Halves the Pokemon's weight.",
               // Weight-based move calculations would go here
            },
         };

         const ITEMS_DATA = {
            oranberry: {
               id: "oranberry",
               name: "Oran Berry",
               category: "berry",
               effect: "heal",
               trigger: "hp_below",
               threshold: 0.5,
               value: 10,
               consumable: true,
               description: "Restores 10 HP when below 50% HP.",
            },
            sitrusberry: {
               id: "sitrusberry",
               name: "Sitrus Berry",
               category: "berry",
               effect: "heal_percent",
               trigger: "hp_below",
               threshold: 0.5,
               value: 0.25,
               consumable: true,
               description: "Restores 25% HP when below 50% HP.",
            },
            lumberry: {
               id: "lumberry",
               name: "Lum Berry",
               category: "berry",
               effect: "cure_status",
               trigger: "has_status",
               consumable: true,
               description: "Cures any status condition.",
            },
            // Battle Items
            leftovers: {
               id: "leftovers",
               name: "Leftovers",
               category: "held",
               effect: "restore_hp_turn_end",
               value: 0.0625,
               description: "Restores 1/16 HP each turn.",
            },
            lifeorb: {
               id: "lifeorb",
               name: "Life Orb",
               category: "held",
               effect: "boost_damage",
               value: 1.3,
               recoil: 0.1,
               description: "Boosts damage by 30% but causes recoil.",
            },
            choiceband: {
               id: "choiceband",
               name: "Choice Band",
               category: "held",
               effect: "boost_stat",
               stat: "attack",
               value: 1.5,
               restriction: "lock_move",
               description: "Boosts Attack by 50% but locks into one move.",
            },
            choicespecs: {
               id: "choicespecs",
               name: "Choice Specs",
               category: "held",
               effect: "boost_stat",
               stat: "spAttack",
               value: 1.5,
               restriction: "lock_move",
               description: "Boosts Sp. Atk by 50% but locks into one move.",
            },
            choicescarf: {
               id: "choicescarf",
               name: "Choice Scarf",
               category: "held",
               effect: "boost_stat",
               stat: "speed",
               value: 1.5,
               restriction: "lock_move",
               description: "Boosts Speed by 50% but locks into one move.",
            },
            focussash: {
               id: "focussash",
               name: "Focus Sash",
               category: "held",
               effect: "survive_ohko",
               consumable: true,
               description: "Survive one KO hit with 1 HP if at full health.",
            },
            rockyhelmet: {
               id: "rockyhelmet",
               name: "Rocky Helmet",
               category: "held",
               effect: "contact_damage",
               value: 0.167,
               description: "Damages attackers using contact moves.",
            },
            // Type-boosting Items
            charcoal: {
               id: "charcoal",
               name: "Charcoal",
               category: "held",
               effect: "boost_type",
               type: "Fire",
               value: 1.2,
               description: "Boosts Fire-type moves by 20%.",
            },
            mysticwater: {
               id: "mysticwater",
               name: "Mystic Water",
               category: "held",
               effect: "boost_type",
               type: "Water",
               value: 1.2,
               description: "Boosts Water-type moves by 20%.",
            },
            miracleseed: {
               id: "miracleseed",
               name: "Miracle Seed",
               category: "held",
               effect: "boost_type",
               type: "Grass",
               value: 1.2,
               description: "Boosts Grass-type moves by 20%.",
            },
         };

         const GameContext = createContext(null);
         const BattleContext = createContext(null);
         const SettingsContext = createContext(null);
         const MultiplayerContext = createContext(null);

         class MultiplayerManager {
            constructor() {
               this.socket = null;
               this.connected = false;
               this.currentRoom = null;
               this.playerId = null;
               this.playerName = null;
               this.isHost = false;
               this.serverUrl = "http://localhost:3001";
               this.eventHandlers = new Map();
            }

            connect() {
               return new Promise((resolve, reject) => {
                  try {
                     this.socket = io(this.serverUrl);

                     this.socket.on("connect", () => {
                        console.log(" Connected to multiplayer server");
                        this.connected = true;
                        this.playerId = this.socket.id;
                        resolve();
                     });

                     this.socket.on("disconnect", () => {
                        console.log(" Disconnected from multiplayer server");
                        this.connected = false;
                        this.currentRoom = null;
                     });

                     this.socket.on("connect_error", (error) => {
                        console.error(" Connection error:", error);
                        reject(error);
                     });

                     // Register all event handlers
                     this.setupEventHandlers();
                  } catch (error) {
                     reject(error);
                  }
               });
            }

            setupEventHandlers() {
               // Room events
               this.socket.on("room_created", (data) => {
                  this.emit("room_created", data);
               });

               this.socket.on("room_joined", (data) => {
                  if (data.success) {
                     this.currentRoom = data.room;
                  }
                  this.emit("room_joined", data);
               });

               this.socket.on("player_joined", (data) => {
                  this.currentRoom = data.room;
                  this.emit("player_joined", data);
               });

               this.socket.on("player_status_updated", (data) => {
                  this.currentRoom = data.room;
                  this.emit("player_status_updated", data);
               });

               // Battle events
               this.socket.on("battle_start", (data) => {
                  this.currentRoom = data.room;
                  this.emit("battle_start", data);
               });

               this.socket.on("opponent_move", (data) => {
                  this.emit("opponent_move", data);
               });

               this.socket.on("battle_finished", (data) => {
                  this.emit("battle_finished", data);
               });

               this.socket.on("turn_timeout", (data) => {
                  this.emit("turn_timeout", data);
               });

               // Chat events
               this.socket.on("chat_message", (data) => {
                  this.emit("chat_message", data);
               });

               // Disconnect events
               this.socket.on("player_disconnected", (data) => {
                  this.currentRoom = data.room;
                  this.emit("player_disconnected", data);
               });
            }

            // Event system
            on(event, handler) {
               if (!this.eventHandlers.has(event)) {
                  this.eventHandlers.set(event, []);
               }
               this.eventHandlers.get(event).push(handler);
            }

            off(event, handler) {
               if (this.eventHandlers.has(event)) {
                  const handlers = this.eventHandlers.get(event);
                  const index = handlers.indexOf(handler);
                  if (index > -1) {
                     handlers.splice(index, 1);
                  }
               }
            }

            emit(event, data) {
               if (this.eventHandlers.has(event)) {
                  this.eventHandlers.get(event).forEach((handler) => handler(data));
               }
            }

            // Room methods
            createRoom(playerName) {
               this.playerName = playerName;
               this.isHost = true;
               this.socket.emit("create_room", { playerName });
            }

            joinRoom(roomCode, playerName) {
               this.playerName = playerName;
               this.isHost = false;
               this.socket.emit("join_room", { roomCode, playerName });
            }

            quickMatch(playerName) {
               this.playerName = playerName;
               this.socket.emit("quick_match", { playerName });
            }

            setReady(ready, team = null) {
               this.socket.emit("player_ready", { ready, team });
            }

            // Battle methods
            sendMove(move, battleData = null) {
               this.socket.emit("battle_move", { move, battleData });
            }

            endBattle(winner, battleData = null) {
               this.socket.emit("battle_end", { winner, battleData });
            }

            // Chat methods
            sendMessage(message) {
               this.socket.emit("chat_message", { message });
            }

            // Room management
            leaveRoom() {
               this.socket.emit("leave_room");
               this.currentRoom = null;
               this.isHost = false;
            }

            disconnect() {
               if (this.socket) {
                  this.socket.disconnect();
                  this.connected = false;
                  this.currentRoom = null;
                  this.playerId = null;
               }
            }

            // Getters
            isConnected() {
               return this.connected && this.socket && this.socket.connected;
            }

            getRoom() {
               return this.currentRoom;
            }

            getPlayerId() {
               return this.playerId;
            }

            isPlayerHost() {
               return this.isHost;
            }
         }

         // Global multiplayer manager instance
         const multiplayerManager = new MultiplayerManager();

         class SoundManager {
            constructor() {
               this.volume = 0.5;
               this.muted = false;
               this.initialized = false;
               this.sounds = new Map();
            }

            async init() {
               if (!this.initialized) {
                  try {
                     await Tone.start();
                     this.initialized = true;
                     this.setupSounds();
                  } catch (error) {
                     console.warn("Audio initialization failed:", error);
                  }
               }
            }

            setupSounds() {
               // Battle sounds
               this.sounds.set(
                  "hit",
                  new Tone.Synth({
                     oscillator: { type: "sawtooth" },
                     envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 },
                  }).toDestination()
               );

               this.sounds.set("superEffective", new Tone.PolySynth().toDestination());
               this.sounds.set(
                  "notVeryEffective",
                  new Tone.Synth({
                     oscillator: { type: "sine" },
                     envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 },
                  }).toDestination()
               );

               // UI sounds
               this.sounds.set(
                  "select",
                  new Tone.Synth({
                     oscillator: { type: "triangle" },
                     envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 },
                  }).toDestination()
               );

               this.sounds.set(
                  "confirm",
                  new Tone.Synth({
                     oscillator: { type: "square" },
                     envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 },
                  }).toDestination()
               );

               // Pokemon sounds
               this.sounds.set(
                  "faint",
                  new Tone.Synth({
                     oscillator: { type: "sawtooth" },
                     envelope: { attack: 0.1, decay: 0.8, sustain: 0, release: 0.5 },
                  }).toDestination()
               );

               this.sounds.set(
                  "switchIn",
                  new Tone.Synth({
                     oscillator: { type: "triangle" },
                     envelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.3 },
                  }).toDestination()
               );
            }

            async play(soundName, options = {}) {
               if (this.muted) return;

               // Try to initialize if not already done
               if (!this.initialized) {
                  await this.init();
               }

               if (!this.initialized) return;

               const sound = this.sounds.get(soundName);
               if (!sound) return;

               try {
                  switch (soundName) {
                     case "hit":
                        sound.triggerAttackRelease("G3", "16n");
                        break;
                     case "superEffective":
                        sound.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                        break;
                     case "notVeryEffective":
                        sound.triggerAttackRelease("C3", "8n");
                        break;
                     case "select":
                        sound.triggerAttackRelease("C5", "32n");
                        break;
                     case "confirm":
                        sound.triggerAttackRelease("G5", "16n");
                        break;
                     case "faint":
                        sound.triggerAttackRelease("E2", "1n");
                        break;
                     case "switchIn":
                        sound.triggerAttackRelease("A4", "8n");
                        break;
                  }
               } catch (error) {
                  console.error("Sound playback error:", error);
               }
            }

            setVolume(value) {
               this.volume = value;
               if (this.initialized && Tone.Destination) {
                  Tone.Destination.volume.value = this.muted ? -Infinity : Tone.gainToDb(value);
               }
            }

            toggleMute() {
               this.muted = !this.muted;
               if (this.initialized && Tone.Destination) {
                  Tone.Destination.volume.value = this.muted
                     ? -Infinity
                     : Tone.gainToDb(this.volume);
               }
            }
         }

         const soundManager = new SoundManager();

         // Merge extended moves data if available
         if (typeof EXTENDED_MOVES_DATA !== "undefined") {
            Object.assign(MOVES_DATA, EXTENDED_MOVES_DATA);
            console.log("Extended moves data loaded! Total moves:", Object.keys(MOVES_DATA).length);
         }

         class BattlePatternTracker {
            constructor() {
               this.moveHistory = [];
               this.switchPatterns = new Map();
               this.movePreferences = new Map();
               this.reactionPatterns = new Map();
            }

            recordPlayerAction(action, context) {
               this.moveHistory.push({
                  action,
                  context: {
                     playerHP: context.playerPokemon.hp / context.playerPokemon.maxHp,
                     enemyHP: context.enemyPokemon.hp / context.enemyPokemon.maxHp,
                     playerTypes: context.playerPokemon.types,
                     enemyTypes: context.enemyPokemon.types,
                     weather: context.weather,
                     turn: context.turn,
                     timestamp: Date.now(),
                  },
               });

               // Analyze patterns
               if (action.type === "move") {
                  this.analyzeMovePattern(action, context);
               } else if (action.type === "switch") {
                  this.analyzeSwitchPattern(action, context);
               }

               // Keep history manageable
               if (this.moveHistory.length > 100) {
                  this.moveHistory = this.moveHistory.slice(-50);
               }
            }

            analyzeMovePattern(action, context) {
               const situation = this.getSituationKey(context);
               if (!this.movePreferences.has(situation)) {
                  this.movePreferences.set(situation, new Map());
               }

               const moveStats = this.movePreferences.get(situation);
               const moveType = action.move.type;
               moveStats.set(moveType, (moveStats.get(moveType) || 0) + 1);
            }

            analyzeSwitchPattern(action, context) {
               const trigger = this.getSwitchTrigger(context);
               if (!this.switchPatterns.has(trigger)) {
                  this.switchPatterns.set(trigger, 0);
               }
               this.switchPatterns.set(trigger, this.switchPatterns.get(trigger) + 1);
            }

            getSituationKey(context) {
               const playerHPRange = Math.floor(
                  (context.playerPokemon.hp / context.playerPokemon.maxHp) * 4
               );
               const enemyHPRange = Math.floor(
                  (context.enemyPokemon.hp / context.enemyPokemon.maxHp) * 4
               );
               return `${playerHPRange}-${enemyHPRange}-${context.weather}`;
            }

            getSwitchTrigger(context) {
               if (context.playerPokemon.hp < context.playerPokemon.maxHp * 0.25) return "low-hp";
               if (context.lastMoveEffectiveness < 0.5) return "bad-matchup";
               if (context.enemySetup > 2) return "enemy-setup";
               return "other";
            }

            predictPlayerMove(context) {
               const situation = this.getSituationKey(context);
               const movePrefs = this.movePreferences.get(situation);

               if (!movePrefs || movePrefs.size === 0) {
                  return null;
               }

               // Find most likely move type
               let maxCount = 0;
               let likelyType = null;

               for (const [type, count] of movePrefs.entries()) {
                  if (count > maxCount) {
                     maxCount = count;
                     likelyType = type;
                  }
               }

               return likelyType;
            }

            getPlayerSwitchProbability(context) {
               const trigger = this.getSwitchTrigger(context);
               const switchCount = this.switchPatterns.get(trigger) || 0;
               const totalSituations = Math.max(
                  1,
                  Array.from(this.switchPatterns.values()).reduce((a, b) => a + b, 0)
               );

               return switchCount / totalSituations;
            }
         }

         // Enhanced AI with Multiple Strategies
         class EnhancedAIBattleEngine {
            constructor(personality = "balanced", difficulty = 1.0) {
               this.personality = personality;
               this.difficulty = difficulty;
               this.patternTracker = new BattlePatternTracker();
               this.strategy = this.selectStrategy();
               this.setupCounter = 0;
               this.lastPlayerMove = null;
               this.predictedPlayerAction = null;
            }

            selectStrategy() {
               const strategies = {
                  aggressive: ["hyper-offense", "momentum", "all-out-attack"],
                  defensive: ["stall", "toxic-stall", "setup-wall"],
                  balanced: ["balance", "bulky-offense", "weather-team"],
                  strategic: ["setup-sweep", "baton-pass", "hazard-stack"],
                  unpredictable: ["random", "mind-games", "anti-meta"],
               };

               const options = strategies[this.personality];
               return options[Math.floor(Math.random() * options.length)];
            }

            async decideTurn(battleState) {
               // Record last player action if available
               if (battleState.lastPlayerAction) {
                  this.patternTracker.recordPlayerAction(battleState.lastPlayerAction, battleState);
               }

               // Predict player's next move
               this.predictedPlayerAction = this.predictPlayerAction(battleState);

               // Simulate thinking with variable time based on difficulty
               const thinkTime = 500 + Math.random() * 1500 * (2 - this.difficulty);
               await new Promise((resolve) => setTimeout(resolve, thinkTime));

               // Decision making based on strategy
               switch (this.strategy) {
                  case "hyper-offense":
                     return this.hyperOffenseStrategy(battleState);
                  case "stall":
                     return this.stallStrategy(battleState);
                  case "setup-sweep":
                     return this.setupSweepStrategy(battleState);
                  case "weather-team":
                     return this.weatherStrategy(battleState);
                  case "mind-games":
                     return this.mindGamesStrategy(battleState);
                  default:
                     return this.balancedStrategy(battleState);
               }
            }

            predictPlayerAction(battleState) {
               const prediction = {
                  type: null,
                  move: null,
                  switchTarget: null,
                  confidence: 0,
               };

               // Check if player is likely to switch
               const switchProb = this.patternTracker.getPlayerSwitchProbability({
                  ...battleState,
                  lastMoveEffectiveness: this.lastMoveEffectiveness,
               });

               if (switchProb > 0.6) {
                  prediction.type = "switch";
                  prediction.confidence = switchProb;

                  // Predict which Pokemon they'll switch to
                  const bestCounter = this.predictBestPlayerSwitch(battleState);
                  if (bestCounter) {
                     prediction.switchTarget = bestCounter;
                  }
               } else {
                  // Predict move
                  prediction.type = "move";
                  const likelyMoveType = this.patternTracker.predictPlayerMove(battleState);

                  if (likelyMoveType) {
                     // Find player's move of that type
                     const playerMoves = battleState.playerPokemon.moves;
                     const matchingMove = playerMoves.find(
                        (m) => m.type === likelyMoveType && m.pp > 0
                     );

                     if (matchingMove) {
                        prediction.move = matchingMove;
                        prediction.confidence = 0.7;
                     }
                  }
               }

               return prediction;
            }

            predictBestPlayerSwitch(battleState) {
               // Analyze which Pokemon in player's team counters our current Pokemon best
               let bestScore = -Infinity;
               let bestPokemon = null;

               battleState.playerTeam.forEach((pokemon, index) => {
                  if (pokemon.hp <= 0 || index === battleState.currentPlayerIndex) return;

                  let score = 0;

                  // Type advantage
                  const offensive = this.calculateBestTypeMatchup(
                     pokemon.types,
                     battleState.enemyPokemon.types
                  );
                  const defensive = this.calculateWorstTypeMatchup(
                     pokemon.types,
                     battleState.enemyPokemon.types
                  );

                  score += offensive * 30 + (1 / defensive) * 20;

                  // Speed advantage
                  if (
                     pokemon.getBoostedStat("speed") >
                     battleState.enemyPokemon.getBoostedStat("speed")
                  ) {
                     score += 15;
                  }

                  if (score > bestScore) {
                     bestScore = score;
                     bestPokemon = pokemon;
                  }
               });

               return bestPokemon;
            }

            // Strategy Implementations
            hyperOffenseStrategy(battleState) {
               const myPokemon = battleState.enemyPokemon;
               const oppPokemon = battleState.playerPokemon;

               // Always go for maximum damage
               const moves = this.scoreMoves(myPokemon, oppPokemon, battleState);

               // Heavily favor damaging moves
               moves.forEach((m) => {
                  if (m.move.power) {
                     m.score *= 1.5;
                     // Bonus for high base power
                     if (m.move.power >= 100) m.score *= 1.3;
                  } else {
                     // Penalize status moves in hyper offense
                     m.score *= 0.3;
                  }
               });

               moves.sort((a, b) => b.score - a.score);
               return { action: "move", move: moves[0].move };
            }

            stallStrategy(battleState) {
               const myPokemon = battleState.enemyPokemon;
               const oppPokemon = battleState.playerPokemon;

               // Check if we should switch to a defensive Pokemon
               if (this.shouldSwitchDefensive(battleState)) {
                  const target = this.chooseDefensiveSwitch(battleState);
                  if (target !== null) {
                     return { action: "switch", target };
                  }
               }

               const moves = this.scoreMoves(myPokemon, oppPokemon, battleState);

               // Favor status and healing moves
               moves.forEach((m) => {
                  if (m.move.status === "toxic" || m.move.status === "poison") {
                     m.score *= 2.5;
                  }
                  if (m.move.flags?.heal) {
                     m.score *= 2.0;
                  }
                  if (m.move.flags?.protect) {
                     m.score *= 1.8;
                  }
                  // Penalize high-power moves in stall
                  if (m.move.power > 100) {
                     m.score *= 0.7;
                  }
               });

               moves.sort((a, b) => b.score - a.score);
               return { action: "move", move: moves[0].move };
            }

            setupSweepStrategy(battleState) {
               const myPokemon = battleState.enemyPokemon;
               const oppPokemon = battleState.playerPokemon;

               // Setup phase
               if (this.setupCounter < 2 && myPokemon.hp > myPokemon.maxHp * 0.6) {
                  const setupMoves = myPokemon.moves.filter(
                     (m) =>
                        m.selfBoost &&
                        (m.selfBoost.attack > 1 ||
                           m.selfBoost.spAttack > 1 ||
                           m.selfBoost.speed > 1)
                  );

                  if (setupMoves.length > 0) {
                     this.setupCounter++;
                     return { action: "move", move: setupMoves[0] };
                  }
               }

               // Sweep phase
               const moves = this.scoreMoves(myPokemon, oppPokemon, battleState);

               // Heavily favor high-power moves after setup
               if (this.setupCounter >= 2) {
                  moves.forEach((m) => {
                     if (m.move.power) {
                        m.score *= 2.0;
                     }
                  });
               }

               moves.sort((a, b) => b.score - a.score);
               return { action: "move", move: moves[0].move };
            }

            weatherStrategy(battleState) {
               const myPokemon = battleState.enemyPokemon;
               const oppPokemon = battleState.playerPokemon;

               // Set up weather if not active
               if (battleState.weather === WEATHER_TYPES.CLEAR) {
                  const weatherMoves = myPokemon.moves.filter((m) => m.weather);
                  if (weatherMoves.length > 0) {
                     return { action: "move", move: weatherMoves[0] };
                  }
               }

               const moves = this.scoreMoves(myPokemon, oppPokemon, battleState);

               // Favor moves that benefit from current weather
               moves.forEach((m) => {
                  if (battleState.weather === WEATHER_TYPES.SUN && m.move.type === "Fire") {
                     m.score *= 1.5;
                  }
                  if (battleState.weather === WEATHER_TYPES.RAIN && m.move.type === "Water") {
                     m.score *= 1.5;
                  }
               });

               moves.sort((a, b) => b.score - a.score);
               return { action: "move", move: moves[0].move };
            }

            mindGamesStrategy(battleState) {
               // This strategy tries to be unpredictable and counter predictions

               // If we predicted the player's action with high confidence, counter it
               if (this.predictedPlayerAction && this.predictedPlayerAction.confidence > 0.6) {
                  if (this.predictedPlayerAction.type === "switch") {
                     // Player is likely switching - use setup or hazards
                     const setupMoves = battleState.enemyPokemon.moves.filter((m) => m.selfBoost);
                     if (setupMoves.length > 0) {
                        return { action: "move", move: setupMoves[0] };
                     }
                  } else if (
                     this.predictedPlayerAction.type === "move" &&
                     this.predictedPlayerAction.move
                  ) {
                     // Counter the predicted move
                     const counter = this.findCounterMove(
                        battleState.enemyPokemon,
                        this.predictedPlayerAction.move
                     );
                     if (counter) {
                        return { action: "move", move: counter };
                     }
                  }
               }

               // Otherwise, make an unexpected play
               const moves = this.scoreMoves(
                  battleState.enemyPokemon,
                  battleState.playerPokemon,
                  battleState
               );

               // Sometimes pick the second or third best move to be unpredictable
               moves.sort((a, b) => b.score - a.score);
               const randomChoice = Math.random();

               if (randomChoice < 0.3 && moves.length > 1) {
                  return { action: "move", move: moves[1].move };
               } else if (randomChoice < 0.1 && moves.length > 2) {
                  return { action: "move", move: moves[2].move };
               }

               return { action: "move", move: moves[0].move };
            }

            balancedStrategy(battleState) {
               // Check if should switch
               if (
                  this.shouldSwitch(
                     battleState.enemyPokemon,
                     battleState.playerPokemon,
                     battleState
                  )
               ) {
                  const switchTarget = this.chooseSwitchTarget(battleState);
                  if (switchTarget !== null) {
                     return { action: "switch", target: switchTarget };
                  }
               }

               // Choose best move
               const moves = this.scoreMoves(
                  battleState.enemyPokemon,
                  battleState.playerPokemon,
                  battleState
               );
               moves.sort((a, b) => b.score - a.score);
               return { action: "move", move: moves[0].move };
            }

            shouldSwitch(myPokemon, oppPokemon, battleState) {
               // Don't switch if last Pokemon
               const availablePokemon = battleState.enemyTeam.filter(
                  (p) => p.hp > 0 && p !== myPokemon
               );
               if (availablePokemon.length === 0) return false;

               // Calculate type disadvantage
               const typeMatchup = this.calculateWorstTypeMatchup(
                  myPokemon.types,
                  oppPokemon.types
               );

               // Switch if severe type disadvantage
               if (typeMatchup < 0.5) return Math.random() < 0.7;

               // Switch if low HP and not faster
               if (
                  myPokemon.hp < myPokemon.maxHp * 0.25 &&
                  this.getEffectiveSpeed(myPokemon) < this.getEffectiveSpeed(oppPokemon)
               ) {
                  return Math.random() < 0.8;
               }

               return false;
            }

            chooseSwitchTarget(battleState) {
               const availablePokemon = battleState.enemyTeam
                  .map((p, i) => ({ pokemon: p, index: i }))
                  .filter(
                     ({ pokemon, index }) =>
                        pokemon.hp > 0 && index !== battleState.currentEnemyIndex
                  );

               if (availablePokemon.length === 0) return null;

               // Score each Pokemon
               const scores = availablePokemon.map(({ pokemon, index }) => {
                  let score = 0;

                  // Type advantage
                  const typeMatchup = this.calculateBestTypeMatchup(
                     pokemon.types,
                     battleState.playerPokemon.types
                  );
                  score += typeMatchup * 50;

                  // HP percentage
                  score += (pokemon.hp / pokemon.maxHp) * 30;

                  // Speed advantage
                  if (
                     this.getEffectiveSpeed(pokemon) >
                     this.getEffectiveSpeed(battleState.playerPokemon)
                  ) {
                     score += 20;
                  }

                  return { index, score };
               });

               // Choose best scoring Pokemon
               scores.sort((a, b) => b.score - a.score);
               return scores[0].index;
            }

            findCounterMove(myPokemon, predictedMove) {
               // Find a move that counters the predicted move

               // If they're using a physical move, consider defensive options
               if (predictedMove.category === "physical") {
                  const defensive = myPokemon.moves.find(
                     (m) => m.selfBoost?.defense > 0 || m.flags?.protect
                  );
                  if (defensive) return defensive;
               }

               // If they're using a setup move, try to phaze or status them
               if (predictedMove.selfBoost) {
                  const disruptive = myPokemon.moves.find((m) => m.status || m.flags?.forceSwitch);
                  if (disruptive) return disruptive;
               }

               // Counter type-wise
               const counterType = this.getCounterType(predictedMove.type);
               const counterMove = myPokemon.moves.find((m) => m.type === counterType);
               if (counterMove) return counterMove;

               return null;
            }

            getCounterType(type) {
               // Returns a type that resists the given type
               const resistances = {
                  Fire: "Water",
                  Water: "Grass",
                  Grass: "Fire",
                  Electric: "Ground",
                  Ground: "Flying",
                  Flying: "Electric",
                  Fighting: "Psychic",
                  Psychic: "Dark",
                  Dark: "Fighting",
                  Dragon: "Fairy",
                  Fairy: "Steel",
                  Steel: "Fire",
               };

               return resistances[type] || "Normal";
            }

            scoreMoves(myPokemon, oppPokemon, battleState) {
               const availableMoves = myPokemon.moves.filter((m) => m.pp > 0);

               return availableMoves.map((move) => {
                  let score = this.calculateMoveScore(move, myPokemon, oppPokemon, battleState);

                  // Apply difficulty scaling
                  score *= 0.7 + this.difficulty * 0.3;

                  // Add some controlled randomness
                  score *= 0.9 + Math.random() * 0.2;

                  return { move, score };
               });
            }

            calculateMoveScore(move, myPokemon, oppPokemon, battleState) {
               let score = 0;

               // Base power consideration
               if (move.power) {
                  score += move.power * 0.5;

                  // Type effectiveness
                  const effectiveness = calculateTypeEffectiveness(move.type, oppPokemon.types);
                  score *= effectiveness;

                  // STAB
                  if (myPokemon.types.includes(move.type)) {
                     score *= 1.5;
                  }

                  // Can we KO?
                  const damage = this.estimateDamage(move, myPokemon, oppPokemon, effectiveness);
                  if (damage >= oppPokemon.hp) {
                     score *= 3; // Huge bonus for KO
                  } else if (damage >= oppPokemon.hp * 0.5) {
                     score *= 1.5;
                  }

                  // Priority moves when low HP or when opponent is faster
                  if (move.priority > 0) {
                     if (myPokemon.hp < myPokemon.maxHp * 0.3) {
                        score *= 2;
                     }
                     if (oppPokemon.getBoostedStat("speed") > myPokemon.getBoostedStat("speed")) {
                        score *= 1.5;
                     }
                  }
               }

               // Status move evaluation
               if (move.category === "status") {
                  score = this.evaluateStatusMove(move, myPokemon, oppPokemon, battleState);

                  // Extra considerations based on prediction
                  if (this.predictedPlayerAction?.type === "switch") {
                     // Player might switch - setup is good
                     if (move.selfBoost) score *= 1.5;
                     if (move.flags?.hazard) score *= 1.8;
                  }
               }

               // Weather synergy
               score = this.applyWeatherBonus(score, move, battleState);

               // Accuracy
               score *= (move.accuracy || 100) / 100;

               return score;
            }

            evaluateStatusMove(move, myPokemon, oppPokemon, battleState) {
               let score = 30;

               // Setup moves
               if (move.selfBoost) {
                  // More valuable when healthy
                  const hpPercent = myPokemon.hp / myPokemon.maxHp;
                  score += hpPercent * 40;

                  // Value based on what stats are boosted
                  Object.entries(move.selfBoost).forEach(([stat, boost]) => {
                     score += boost * 20;

                     // Extra value for speed if we're slower
                     if (
                        stat === "speed" &&
                        myPokemon.getBoostedStat("speed") < oppPokemon.getBoostedStat("speed")
                     ) {
                        score += boost * 15;
                     }
                  });

                  // Consider if we've already setup
                  const currentBoosts = Object.values(myPokemon.statStages).reduce(
                     (a, b) => a + b,
                     0
                  );
                  if (currentBoosts > 3) {
                     score *= 0.5; // Diminishing returns
                  }
               }

               // Status conditions
               if (move.status && !oppPokemon.status) {
                  score += 50;

                  // Value different statuses
                  switch (move.status) {
                     case "sleep":
                     case "freeze":
                        score += 30;
                        break;
                     case "paralysis":
                        if (
                           oppPokemon.getBoostedStat("speed") > myPokemon.getBoostedStat("speed")
                        ) {
                           score += 40;
                        }
                        break;
                     case "toxic":
                        // Better against bulky Pokemon
                        if (oppPokemon.stats.hp > 90) {
                           score += 25;
                        }
                        break;
                     case "burn":
                        // Better against physical attackers
                        if (oppPokemon.stats.attack > oppPokemon.stats.spAttack) {
                           score += 20;
                        }
                        break;
                  }
               }

               // Healing
               if (move.flags?.heal) {
                  const missingHp = myPokemon.maxHp - myPokemon.hp;
                  score += (missingHp / myPokemon.maxHp) * 100;

                  // Less valuable if opponent can 2HKO us
                  const avgOppDamage = this.estimateAverageOpponentDamage(oppPokemon, myPokemon);
                  if (avgOppDamage > myPokemon.maxHp * 0.5) {
                     score *= 0.6;
                  }
               }

               // Protection
               if (move.flags?.protect) {
                  // More valuable when expecting strong attack
                  if (myPokemon.hp < myPokemon.maxHp * 0.5) {
                     score += 40;
                  }

                  // Good for scouting
                  if (battleState.turn < 3) {
                     score += 20;
                  }

                  // Less valuable if used recently
                  if (myPokemon.protectCount > 0) {
                     score *= Math.pow(0.5, myPokemon.protectCount);
                  }
               }

               return score;
            }

            estimateDamage(move, attacker, defender, effectiveness) {
               if (!move.power) return 0;

               const level = attacker.level;
               const attack =
                  move.category === "physical"
                     ? attacker.getBoostedStat("attack")
                     : attacker.getBoostedStat("spAttack");
               const defense =
                  move.category === "physical"
                     ? defender.getBoostedStat("defense")
                     : defender.getBoostedStat("spDefense");

               let damage = (((2 * level) / 5 + 2) * move.power * attack) / defense / 50 + 2;

               // Type effectiveness
               damage *= effectiveness;

               // STAB
               if (attacker.types.includes(move.type)) {
                  damage *= 1.5;
               }

               // Average damage roll
               damage *= 0.925;

               return Math.floor(damage);
            }

            estimateAverageOpponentDamage(oppPokemon, myPokemon) {
               let totalDamage = 0;
               let moveCount = 0;

               oppPokemon.moves.forEach((move) => {
                  if (move.power && move.pp > 0) {
                     const effectiveness = calculateTypeEffectiveness(move.type, myPokemon.types);
                     const damage = this.estimateDamage(move, oppPokemon, myPokemon, effectiveness);
                     totalDamage += damage;
                     moveCount++;
                  }
               });

               return moveCount > 0 ? totalDamage / moveCount : 0;
            }

            shouldSwitchDefensive(battleState) {
               const myPokemon = battleState.enemyPokemon;
               const oppPokemon = battleState.playerPokemon;

               // Don't switch if last Pokemon
               const availablePokemon = battleState.enemyTeam.filter(
                  (p) => p.hp > 0 && p !== myPokemon
               );
               if (availablePokemon.length === 0) return false;

               // Switch if bad type matchup
               const typeMatchup = this.calculateWorstTypeMatchup(
                  myPokemon.types,
                  oppPokemon.types
               );
               if (typeMatchup < 0.5) return true;

               // Switch if opponent has setup too much
               const oppBoosts = Object.values(oppPokemon.statStages).reduce((a, b) => a + b, 0);
               if (oppBoosts >= 4) return true;

               return false;
            }

            chooseDefensiveSwitch(battleState) {
               const availablePokemon = battleState.enemyTeam
                  .map((p, i) => ({ pokemon: p, index: i }))
                  .filter(
                     ({ pokemon, index }) =>
                        pokemon.hp > 0 && index !== battleState.currentEnemyIndex
                  );

               if (availablePokemon.length === 0) return null;

               // Score each Pokemon defensively
               const scores = availablePokemon.map(({ pokemon, index }) => {
                  let score = 0;

                  // Defensive type matchup
                  const defenseMatchup = this.calculateWorstTypeMatchup(
                     pokemon.types,
                     battleState.playerPokemon.types
                  );
                  score += (1 / defenseMatchup) * 50;

                  // Bulk
                  const bulkScore =
                     (pokemon.stats.hp + pokemon.stats.defense + pokemon.stats.spDefense) / 3;
                  score += bulkScore * 0.3;

                  // HP percentage
                  score += (pokemon.hp / pokemon.maxHp) * 30;

                  // Healing moves available
                  if (pokemon.moves.some((m) => m.flags?.heal)) {
                     score += 20;
                  }

                  return { index, score };
               });

               scores.sort((a, b) => b.score - a.score);
               return scores[0].index;
            }

            applyWeatherBonus(score, move, battleState) {
               switch (battleState.weather) {
                  case WEATHER_TYPES.SUN:
                     if (move.type === "Fire") score *= 1.5;
                     if (move.type === "Water") score *= 0.5;
                     if (move.id === "solarbeam") score *= 2; // No charge turn
                     break;
                  case WEATHER_TYPES.RAIN:
                     if (move.type === "Water") score *= 1.5;
                     if (move.type === "Fire") score *= 0.5;
                     if (move.id === "thunder") score *= 1.3; // 100% accuracy
                     break;
                  case WEATHER_TYPES.SANDSTORM:
                     if (move.type === "Rock") score *= 1.2;
                     break;
                  case WEATHER_TYPES.HAIL:
                     if (move.id === "blizzard") score *= 1.3; // 100% accuracy
                     break;
               }
               return score;
            }

            // Helper methods from original class
            calculateWorstTypeMatchup(myTypes, oppTypes) {
               let worst = 1;
               oppTypes.forEach((oppType) => {
                  myTypes.forEach((myType) => {
                     const effectiveness = TYPE_EFFECTIVENESS[oppType]?.[myType] ?? 1;
                     worst = Math.min(worst, effectiveness);
                  });
               });
               return worst;
            }

            calculateBestTypeMatchup(myTypes, oppTypes) {
               let best = 1;
               myTypes.forEach((myType) => {
                  oppTypes.forEach((oppType) => {
                     const effectiveness = TYPE_EFFECTIVENESS[myType]?.[oppType] ?? 1;
                     best = Math.max(best, effectiveness);
                  });
               });
               return best;
            }

            getEffectiveSpeed(pokemon) {
               let speed = pokemon.stats.speed;

               // Apply stat stages
               if (pokemon.statStages?.speed) {
                  const stage = pokemon.statStages.speed;
                  speed *= stage >= 0 ? (2 + stage) / 2 : 2 / (2 - stage);
               }

               // Apply paralysis
               if (pokemon.status === "paralysis") {
                  speed *= 0.5;
               }

               // Apply ability effects (simplified)
               if (
                  pokemon.ability?.id === "swiftswim" &&
                  pokemon.battle?.weather === WEATHER_TYPES.RAIN
               ) {
                  speed *= 2;
               }

               return Math.floor(speed);
            }

            recordMove(move, result) {
               this.moveHistory = this.moveHistory || [];
               this.moveHistory.push({
                  move,
                  result,
                  timestamp: Date.now(),
               });

               // Keep only last 50 moves
               if (this.moveHistory.length > 50) {
                  this.moveHistory.shift();
               }
            }
         }

         // Backward compatibility alias
         class AIBattleEngine extends EnhancedAIBattleEngine {}

         // ==================== BATTLE CALCULATIONS ====================
         function calculateTypeEffectiveness(moveType, defenderTypes) {
            let multiplier = 1;

            defenderTypes.forEach((defType) => {
               if (
                  TYPE_EFFECTIVENESS[moveType] &&
                  TYPE_EFFECTIVENESS[moveType][defType] !== undefined
               ) {
                  multiplier *= TYPE_EFFECTIVENESS[moveType][defType];
               }
            });

            return multiplier;
         }

         function calculateDamage(attacker, defender, move, battle) {
            // Skip damage calculation for status moves
            if (!move.power || move.category === "status") {
               return {
                  damage: 0,
                  effectiveness: 1,
                  critical: false,
                  messages: [],
               };
            }

            // Get stats
            const attackStat =
               move.category === "physical"
                  ? attacker.getBoostedStat("attack")
                  : attacker.getBoostedStat("spAttack");
            const defenseStat =
               move.category === "physical"
                  ? defender.getBoostedStat("defense")
                  : defender.getBoostedStat("spDefense");

            // Base damage calculation
            let damage = Math.floor(
               (((2 * attacker.level) / 5 + 2) * move.power * attackStat) / defenseStat / 50 + 2
            );

            // Type effectiveness
            const effectiveness = calculateTypeEffectiveness(move.type, defender.types);
            damage *= effectiveness;

            // STAB (Same Type Attack Bonus)
            if (attacker.types.includes(move.type)) {
               damage *= 1.5;
            }

            // Critical hit check
            let critChance = 0.0625; // 1/16
            if (move.critRatio) critChance *= move.critRatio;
            const critical = Math.random() < critChance;
            if (critical) damage *= 1.5;

            // Weather effects
            if (battle.weather === WEATHER_TYPES.SUN) {
               if (move.type === "Fire") damage *= 1.5;
               if (move.type === "Water") damage *= 0.5;
            } else if (battle.weather === WEATHER_TYPES.RAIN) {
               if (move.type === "Water") damage *= 1.5;
               if (move.type === "Fire") damage *= 0.5;
            }

            // Random factor (85-100%)
            damage *= 0.85 + Math.random() * 0.15;

            // Apply ability modifiers
            if (attacker.ability) {
               damage = applyAbilityDamageModifier(damage, move, attacker, defender, "attacker");
            }
            if (defender.ability) {
               damage = applyAbilityDamageModifier(damage, move, defender, attacker, "defender");
            }

            // Apply item modifiers
            if (attacker.heldItem) {
               damage = applyItemDamageModifier(damage, move, attacker, "attacker");
            }
            if (defender.heldItem) {
               damage = applyItemDamageModifier(damage, move, defender, "defender");
            }

            // Minimum damage is 1
            damage = Math.max(1, Math.floor(damage));

            return {
               damage,
               effectiveness,
               critical,
               messages: [],
            };
         }

         function applyAbilityDamageModifier(damage, move, pokemon, opponent, role) {
            // Check if pokemon has an ability
            if (!pokemon.ability || !pokemon.ability.id) {
               return damage;
            }

            const ability = ABILITIES_DATA[pokemon.ability.id];

            // Check if ability data exists
            if (!ability) {
               return damage;
            }

            if (role === "attacker") {
               // Adaptability
               if (ability.id === "adaptability" && pokemon.types.includes(move.type)) {
                  damage *= 1.33;
               }
               // Sheer Force
               if (ability.id === "sheerforce" && (move.secondary || move.secondaries)) {
                  damage *= 1.3;
               }
            } else {
               // Levitate
               if (ability.id === "levitate" && move.type === "Ground") {
                  damage = 0;
               }
               // Multiscale
               if (ability.id === "multiscale" && pokemon.hp === pokemon.maxHp) {
                  damage *= 0.5;
               }
            }

            return damage;
         }

         function applyItemDamageModifier(damage, move, pokemon, role) {
            const item = ITEMS_DATA[pokemon.heldItem?.id];
            if (!item) return damage;

            if (role === "attacker") {
               // Life Orb
               if (item.id === "lifeorb") {
                  damage *= 1.3;
               }
               // Choice Band/Specs
               if (item.id === "choiceband" && move.category === "physical") {
                  damage *= 1.5;
               }
               if (item.id === "choicespecs" && move.category === "special") {
                  damage *= 1.5;
               }
               // Type-boosting items
               if (item.effect === "boost_type" && item.type === move.type) {
                  damage *= item.value;
               }
            }

            return damage;
         }

         // ==================== POKEMON CLASS ====================
         class Pokemon {
            constructor(speciesData, level = 50) {
               this.id = Math.random().toString(36).substr(2, 9);
               this.species = speciesData.id;
               this.name = speciesData.name;
               this.types = [...speciesData.types];
               this.level = level;
               this.baseStats = { ...speciesData.baseStats };

               // Calculate actual stats
               this.calculateStats();

               // Initialize HP
               this.maxHp = this.stats.hp;
               this.hp = this.maxHp;

               // Status
               this.status = null;
               this.volatileStatus = new Set();

               // Stat stages
               this.statStages = {
                  attack: 0,
                  defense: 0,
                  spAttack: 0,
                  spDefense: 0,
                  speed: 0,
                  accuracy: 0,
                  evasion: 0,
               };

               // Moves
               this.moves = this.learnMoves(speciesData.learnset);

               // Ability
               this.ability = this.selectAbility(speciesData.abilities);

               // Item
               this.heldItem = null;

               // Battle stats
               this.battleStats = {
                  damageDealt: 0,
                  damageTaken: 0,
                  turnsActive: 0,
                  knockouts: 0,
               };

               // Sprites
               this.sprite = speciesData.sprite;
               this.spriteBack = speciesData.spriteBack;

               // Battle reference
               this.battle = null;
            }

            calculateStats() {
               this.stats = {};

               // HP calculation
               this.stats.hp = Math.floor(
                  ((2 * this.baseStats.hp + 31 + 0) * this.level) / 100 + this.level + 10
               );

               // Other stats
               ["attack", "defense", "spAttack", "spDefense", "speed"].forEach((stat) => {
                  this.stats[stat] = Math.floor(
                     ((2 * this.baseStats[stat] + 31 + 0) * this.level) / 100 + 5
                  );
               });
            }

            learnMoves(learnset) {
               // Get up to 4 moves that the Pokemon can learn at its level
               const availableMoves = learnset
                  .filter((move) => move.level <= this.level)
                  .sort((a, b) => b.level - a.level)
                  .slice(0, 4);

               return availableMoves.map((moveData) => {
                  const moveTemplate = MOVES_DATA[moveData.id];
                  if (!moveTemplate) {
                     console.error(`Move not found in MOVES_DATA: ${moveData.id}`);
                     // Return a basic tackle move as fallback
                     const move = { ...MOVES_DATA.tackle };
                     move.pp = move.pp || 35;
                     move.maxPp = move.pp;
                     return move;
                  }
                  const move = { ...moveTemplate };
                  move.pp = move.pp || 10;
                  move.maxPp = move.pp;
                  return move;
               });
            }

            selectAbility(abilities) {
               if (!abilities || abilities.length === 0) return null;
               const abilityId = abilities[Math.floor(Math.random() * abilities.length)];
               return {
                  id: abilityId,
                  data: ABILITIES_DATA[abilityId] || {}, // Fallback to empty object if ability not found
               };
            }

            getBoostedStat(statName) {
               if (statName === "hp") return this.stats.hp;

               let value = this.stats[statName];
               const stage = this.statStages[statName] || 0;

               // Apply stat stage multiplier
               if (stage >= 0) {
                  value *= (2 + stage) / 2;
               } else {
                  value *= 2 / (2 - stage);
               }

               // Apply status effects
               if (this.status === "burn" && statName === "attack") {
                  value *= 0.5;
               }
               if (this.status === "paralysis" && statName === "speed") {
                  value *= 0.5;
               }

               // Apply ability effects
               if (this.ability && this.ability.data && this.ability.data.onModifyStat) {
                  value = this.ability.data.onModifyStat(statName, value, this, this.battle);
               }

               // Apply item effects
               if (this.heldItem) {
                  const item = ITEMS_DATA[this.heldItem.id];
                  if (item.effect === "boost_stat" && item.stat === statName) {
                     value *= item.value;
                  }
               }

               return Math.floor(value);
            }

            boostStat(statName, stages) {
               const oldStage = this.statStages[statName];
               this.statStages[statName] = Math.max(-6, Math.min(6, oldStage + stages));
               return this.statStages[statName] - oldStage; // Return actual change
            }

            takeDamage(damage) {
               this.hp = Math.max(0, this.hp - damage);
               this.battleStats.damageTaken += damage;

               if (this.hp === 0) {
                  this.faint();
               }

               return this.hp === 0;
            }

            heal(amount) {
               const actualHeal = Math.min(amount, this.maxHp - this.hp);
               this.hp += actualHeal;
               return actualHeal;
            }

            setStatus(status) {
               if (this.status || this.hp === 0) return false;

               // Check immunity
               if (status === "burn" && this.types.includes("Fire")) return false;
               if (
                  (status === "poison" || status === "toxic") &&
                  (this.types.includes("Poison") || this.types.includes("Steel"))
               )
                  return false;
               if (status === "paralysis" && this.types.includes("Electric")) return false;
               if (status === "freeze" && this.types.includes("Ice")) return false;

               this.status = status;
               return true;
            }

            cureStatus() {
               this.status = null;
               this.toxicCounter = 0; // Reset toxic counter
            }

            addVolatileStatus(status) {
               this.volatileStatus.add(status);
            }

            removeVolatileStatus(status) {
               this.volatileStatus.delete(status);
            }

            hasVolatileStatus(status) {
               return this.volatileStatus.has(status);
            }

            faint() {
               this.hp = 0;
               this.status = null;
               this.toxicCounter = 0;
               this.protectCount = 0;
               this.confusionTurns = 0;
               this.volatileStatus.clear();
               // Reset stat stages
               Object.keys(this.statStages).forEach((stat) => {
                  this.statStages[stat] = 0;
               });
            }

            canUseMove(moveIndex) {
               if (this.hp === 0) return false;
               const move = this.moves[moveIndex];
               if (!move || move.pp <= 0) return false;

               // Check for choice lock
               if (this.heldItem && this.lockedMove && move.id !== this.lockedMove) {
                  return false;
               }

               return true;
            }

            useMove(moveIndex) {
               const move = this.moves[moveIndex];
               if (move && move.pp > 0) {
                  move.pp--;

                  // Handle choice items
                  if (this.heldItem) {
                     const item = ITEMS_DATA[this.heldItem.id];
                     if (item.restriction === "lock_move") {
                        this.lockedMove = move.id;
                     }
                  }

                  return move;
               }
               return null;
            }

            resetBattleState() {
               this.statStages = {
                  attack: 0,
                  defense: 0,
                  spAttack: 0,
                  spDefense: 0,
                  speed: 0,
                  accuracy: 0,
                  evasion: 0,
               };
               this.volatileStatus.clear();
               this.lockedMove = null;
               this.protectCount = 0;
               this.toxicCounter = 0;
               this.confusionTurns = 0;
               this.chargingMove = null;
            }
         }

         // ==================== BATTLE SYSTEM ====================
         class Battle {
            constructor(playerTeam, enemyTeam, format = BATTLE_FORMATS.SINGLES_6V6) {
               this.id = Math.random().toString(36).substr(2, 9);
               this.format = format;
               this.playerTeam = playerTeam;
               this.enemyTeam = enemyTeam;
               this.currentPlayerIndex = 0;
               this.currentEnemyIndex = 0;
               this.turn = 0;
               this.lastUsedMove = null;
               this.lastDamageWasCritical = false;
               this.trainerPersonality = new PersonalityAI(
                  ["aggressive", "calm", "enthusiastic"][Math.floor(Math.random() * 3)]
               );
               this.pendingSwitch = null; // For delayed Pokemon switching
               this.faintAnimationInProgress = false;
               this.weather = WEATHER_TYPES.CLEAR;
               this.weatherTurns = 0;
               this.terrain = null;
               this.terrainTurns = 0;
               this.trickRoom = false;
               this.trickRoomTurns = 0;
               this.gravity = false;
               this.gravityTurns = 0;
               this.state = BATTLE_STATES.INTRO;
               this.history = [];
               this.pendingActions = [];
               this.messageQueue = [];

               // Set battle reference for all Pokemon
               [...playerTeam, ...enemyTeam].forEach((pokemon) => {
                  pokemon.battle = this;
               });
            }

            get playerPokemon() {
               return this.playerTeam[this.currentPlayerIndex];
            }

            get enemyPokemon() {
               return this.enemyTeam[this.currentEnemyIndex];
            }

            addMessage(message) {
               // Auto-format dialogue with quotes
               if (
                  message.includes(" used ") ||
                  message.includes(" fainted") ||
                  message.includes("Go,") ||
                  message.includes("Come back") ||
                  message.includes("It's super effective") ||
                  message.includes("It's not very effective") ||
                  message.includes("A critical hit")
               ) {
                  // Battle action messages - no quotes needed
                  this.messageQueue.push(message);
               } else if (
                  message.includes("!") &&
                  !message.startsWith('"') &&
                  !message.endsWith('"')
               ) {
                  // Likely dialogue - add quotes
                  this.messageQueue.push(`"${message}"`);
               } else {
                  this.messageQueue.push(message);
               }
            }

            clearMessages() {
               this.messageQueue = [];
            }

            setWeather(weather, turns = 5) {
               this.weather = weather;
               this.weatherTurns = turns;

               const weatherMessages = {
                  [WEATHER_TYPES.SUN]: "The sunlight turned harsh!",
                  [WEATHER_TYPES.RAIN]: "It started to rain!",
                  [WEATHER_TYPES.SANDSTORM]: "A sandstorm kicked up!",
                  [WEATHER_TYPES.HAIL]: "It started to hail!",
               };

               if (weatherMessages[weather]) {
                  this.addMessage(weatherMessages[weather]);
               }
            }

            getOpponents(pokemon) {
               if (this.playerTeam.includes(pokemon)) {
                  return [this.enemyPokemon];
               } else {
                  return [this.playerPokemon];
               }
            }

            async executeTurn() {
               console.log("executeTurn started");
               this.turn++;
               this.clearMessages();

               // Determine turn order
               const actions = this.determineTurnOrder();
               console.log("Turn order determined:", actions.length, "actions");

               // Execute actions
               for (const action of actions) {
                  console.log("Executing action:", action.type);
                  if (action.type === "move") {
                     await this.executeMove(action.pokemon, action.target, action.move);
                  } else if (action.type === "switch") {
                     await this.executeSwitch(action.team, action.oldIndex, action.newIndex);
                  }

                  // Check for faints after each action
                  console.log("Checking for faints...");
                  if (this.checkForFaints()) {
                     console.log("Faint detected, breaking action loop");
                     break;
                  }
               }

               // End of turn effects
               console.log("Processing turn end effects...");
               await this.processTurnEnd();

               // Ensure battle state is ready for next turn if battle is still ongoing
               if (
                  this.state !== BATTLE_STATES.VICTORY &&
                  this.state !== BATTLE_STATES.DEFEAT &&
                  this.state !== BATTLE_STATES.SWITCHING
               ) {
                  this.state = BATTLE_STATES.PLAYER_TURN;
               }
               console.log("executeTurn completed, final state:", this.state);
            }

            determineTurnOrder() {
               const actions = [...this.pendingActions];

               // Sort by priority, then speed
               actions.sort((a, b) => {
                  // Switches always go first
                  if (a.type === "switch" && b.type !== "switch") return -1;
                  if (b.type === "switch" && a.type !== "switch") return 1;

                  // Compare move priorities
                  if (a.type === "move" && b.type === "move") {
                     const aPriority = a.move.priority || 0;
                     const bPriority = b.move.priority || 0;

                     if (aPriority !== bPriority) {
                        return bPriority - aPriority;
                     }

                     // Same priority, compare speeds
                     const aSpeed = a.pokemon.getBoostedStat("speed");
                     const bSpeed = b.pokemon.getBoostedStat("speed");

                     // Trick Room reverses speed order
                     if (this.trickRoom) {
                        return aSpeed - bSpeed;
                     } else {
                        return bSpeed - aSpeed;
                     }
                  }

                  return 0;
               });

               this.pendingActions = [];
               return actions;
            }

            async executeMove(attacker, defender, move) {
               // Check if attacker can move
               if (attacker.hp === 0) return;

               // Status checks
               if (attacker.status === "sleep") {
                  this.addMessage(`${attacker.name} is fast asleep!`);
                  if (Math.random() < 0.33) {
                     attacker.cureStatus();
                     this.addMessage(`${attacker.name} woke up!`);
                  } else {
                     return; // Can't move this turn
                  }
               }

               if (attacker.status === "freeze") {
                  this.addMessage(`${attacker.name} is frozen solid!`);
                  if (Math.random() < 0.2 || move.type === "Fire") {
                     attacker.cureStatus();
                     this.addMessage(`${attacker.name} thawed out!`);
                  } else {
                     return; // Can't move this turn
                  }
               }

               if (attacker.status === "paralysis" && Math.random() < 0.25) {
                  this.addMessage(`${attacker.name} is paralyzed! It can't move!`);
                  return; // Can't move this turn
               }

               // Flinch check
               if (attacker.hasVolatileStatus("flinch")) {
                  this.addMessage(`${attacker.name} flinched!`);
                  attacker.removeVolatileStatus("flinch");
                  return; // Can't move this turn
               }

               // Confusion check
               if (attacker.hasVolatileStatus("confusion")) {
                  this.addMessage(`${attacker.name} is confused!`);
                  if (Math.random() < 0.33) {
                     // Hurt itself in confusion
                     const damage = Math.floor(
                        (attacker.getBoostedStat("attack") * 40) /
                           attacker.getBoostedStat("defense") /
                           2
                     );
                     attacker.takeDamage(damage);
                     this.addMessage(`${attacker.name} hurt itself in confusion!`);
                     return;
                  }
                  // Remove confusion after a few turns
                  attacker.confusionTurns = (attacker.confusionTurns || 1) + 1;
                  if (attacker.confusionTurns > 3) {
                     attacker.removeVolatileStatus("confusion");
                     attacker.confusionTurns = 0;
                     this.addMessage(`${attacker.name} snapped out of confusion!`);
                  }
               }

               // Check for charging moves (Solar Beam, etc.)
               if (move.flags?.charge && !attacker.hasVolatileStatus("charging")) {
                  if (this.weather === WEATHER_TYPES.SUN && move.flags?.sunshine) {
                     // Skip charging in sun - continue to normal attack
                  } else {
                     // Start charging
                     attacker.addVolatileStatus("charging");
                     attacker.chargingMove = move;
                     this.addMessage(`${attacker.name} is charging power!`);
                     return; // Skip attack this turn
                  }
               } else if (attacker.hasVolatileStatus("charging")) {
                  // Release charged attack
                  attacker.removeVolatileStatus("charging");
                  attacker.chargingMove = null;
               }

               // Use the move
               this.addMessage(`${attacker.name} used ${move.name}!`);

               // Check if defender is protected
               if (defender.hasVolatileStatus("protect") && move.category !== "status") {
                  this.addMessage(`${defender.name} protected itself!`);
                  return;
               }

               // Accuracy check
               if (move.accuracy) {
                  const accuracy = this.calculateAccuracy(move, attacker, defender);
                  if (Math.random() * 100 > accuracy) {
                     this.addMessage(`${attacker.name}'s attack missed!`);
                     return;
                  }
               }

               // Execute move effect
               if (move.category === "status") {
                  await this.executeStatusMove(attacker, defender, move);
               } else {
                  await this.executeDamagingMove(attacker, defender, move);
               }
            }

            async executeDamagingMove(attacker, defender, move) {
               // Track the last used move and critical hit
               this.lastUsedMove = move;

               // Calculate damage
               const result = calculateDamage(attacker, defender, move, this);
               this.lastDamageWasCritical = result.critical;

               if (
                  result.damage === 0 &&
                  move.type === "Ground" &&
                  defender.ability?.id === "levitate"
               ) {
                  this.addMessage(`${defender.name} avoids Ground moves with Levitate!`);
                  return;
               }

               // Apply damage
               if (result.damage > 0) {
                  // Focus Sash check
                  if (
                     defender.heldItem?.id === "focussash" &&
                     defender.hp === defender.maxHp &&
                     result.damage >= defender.hp
                  ) {
                     result.damage = defender.hp - 1;
                     defender.heldItem = null; // Consume item
                     this.addMessage(`${defender.name} held on using its Focus Sash!`);
                  }

                  defender.takeDamage(result.damage);
                  attacker.battleStats.damageDealt += result.damage;

                  // Add trainer reactions
                  if (result.critical) {
                     const reaction = this.trainerPersonality.getReaction("impressed");
                     if (reaction) this.addMessage(reaction);
                  } else if (result.effectiveness > 1) {
                     const reaction = this.trainerPersonality.getReaction("impressed");
                     if (reaction) this.addMessage(reaction);
                  }

                  // Effectiveness message
                  if (result.effectiveness > 1) {
                     this.addMessage("It's super effective!");
                     soundManager.play("superEffective");
                  } else if (result.effectiveness < 1 && result.effectiveness > 0) {
                     this.addMessage("It's not very effective...");
                     soundManager.play("notVeryEffective");
                  } else if (result.effectiveness === 0) {
                     this.addMessage("It had no effect!");
                     return;
                  } else {
                     soundManager.play("hit");
                  }

                  // Critical hit message
                  if (result.critical) {
                     this.addMessage("A critical hit!");
                  }

                  // Secondary effects
                  if (move.secondary && Math.random() < move.secondary.chance / 100) {
                     if (move.secondary.status) {
                        if (defender.setStatus(move.secondary.status)) {
                           this.addMessage(`${defender.name} was ${move.secondary.status}!`);
                        }
                     }
                     if (move.secondary.volatileStatus) {
                        defender.addVolatileStatus(move.secondary.volatileStatus);
                     }
                     if (move.secondary.boost) {
                        Object.entries(move.secondary.boost).forEach(([stat, stages]) => {
                           const actual = defender.boostStat(stat, stages);
                           if (actual !== 0) {
                              const dir = actual > 0 ? "rose" : "fell";
                              const amount = Math.abs(actual) > 1 ? " sharply" : "";
                              this.addMessage(`${defender.name}'s ${stat} ${dir}${amount}!`);
                           }
                        });
                     }
                  }

                  // Self boost from move
                  if (move.selfBoost) {
                     Object.entries(move.selfBoost).forEach(([stat, stages]) => {
                        const actual = attacker.boostStat(stat, stages);
                        if (actual !== 0) {
                           const dir = actual > 0 ? "rose" : "fell";
                           const amount = Math.abs(actual) > 1 ? " sharply" : "";
                           this.addMessage(`${attacker.name}'s ${stat} ${dir}${amount}!`);
                        }
                     });
                  }

                  // Recoil
                  if (move.recoil) {
                     const recoilDamage = Math.floor(result.damage * move.recoil);
                     attacker.takeDamage(recoilDamage);
                     this.addMessage(`${attacker.name} was damaged by recoil!`);
                  }

                  // Life Orb recoil
                  if (attacker.heldItem?.id === "lifeorb") {
                     const recoilDamage = Math.floor(attacker.maxHp * 0.1);
                     attacker.takeDamage(recoilDamage);
                     this.addMessage(`${attacker.name} lost some HP due to its Life Orb!`);
                  }

                  // Contact move effects
                  if (move.flags?.contact) {
                     // Rocky Helmet
                     if (defender.heldItem?.id === "rockyhelmet") {
                        const contactDamage = Math.floor(attacker.maxHp / 6);
                        attacker.takeDamage(contactDamage);
                        this.addMessage(
                           `${attacker.name} was hurt by ${defender.name}'s Rocky Helmet!`
                        );
                     }

                     // Static ability
                     if (defender.ability?.id === "static" && Math.random() < 0.3) {
                        if (attacker.setStatus("paralysis")) {
                           this.addMessage(
                              `${attacker.name} was paralyzed by ${defender.name}'s Static!`
                           );
                        }
                     }

                     // Rough Skin ability
                     if (defender.ability?.id === "roughskin") {
                        const roughDamage = Math.floor(attacker.maxHp / 8);
                        attacker.takeDamage(roughDamage);
                        this.addMessage(
                           `${attacker.name} was hurt by ${defender.name}'s Rough Skin!`
                        );
                     }
                  }
               }
            }

            async executeStatusMove(attacker, defender, move) {
               // Status infliction
               if (move.status) {
                  if (defender.setStatus(move.status)) {
                     const statusMessages = {
                        burn: "was burned",
                        poison: "was poisoned",
                        toxic: "was badly poisoned",
                        paralysis: "was paralyzed",
                        freeze: "was frozen",
                        sleep: "fell asleep",
                     };
                     this.addMessage(`${defender.name} ${statusMessages[move.status]}!`);
                  } else {
                     this.addMessage("But it failed!");
                  }
               }

               // Stat changes
               if (move.boost) {
                  Object.entries(move.boost).forEach(([stat, stages]) => {
                     const actual = defender.boostStat(stat, stages);
                     if (actual !== 0) {
                        const dir = actual > 0 ? "rose" : "fell";
                        const amount = Math.abs(actual) > 1 ? " sharply" : "";
                        this.addMessage(`${defender.name}'s ${stat} ${dir}${amount}!`);
                     } else {
                        this.addMessage(
                           `${defender.name}'s ${stat} won't go any ${
                              stages > 0 ? "higher" : "lower"
                           }!`
                        );
                     }
                  });
               }

               // Self stat changes
               if (move.selfBoost) {
                  Object.entries(move.selfBoost).forEach(([stat, stages]) => {
                     const actual = attacker.boostStat(stat, stages);
                     if (actual !== 0) {
                        const dir = actual > 0 ? "rose" : "fell";
                        const amount = Math.abs(actual) > 1 ? " sharply" : "";
                        this.addMessage(`${attacker.name}'s ${stat} ${dir}${amount}!`);
                     } else {
                        this.addMessage(
                           `${attacker.name}'s ${stat} won't go any ${
                              stages > 0 ? "higher" : "lower"
                           }!`
                        );
                     }
                  });
               }

               // Healing
               if (move.flags?.heal) {
                  let healAmount = Math.floor(attacker.maxHp * 0.5);

                  // Weather modifications
                  if (move.id === "synthesis" || move.id === "moonlight") {
                     if (this.weather === WEATHER_TYPES.SUN)
                        healAmount = Math.floor(attacker.maxHp * 0.67);
                     else if (this.weather !== WEATHER_TYPES.CLEAR)
                        healAmount = Math.floor(attacker.maxHp * 0.25);
                  }

                  const actualHeal = attacker.heal(healAmount);
                  if (actualHeal > 0) {
                     this.addMessage(`${attacker.name} restored HP!`);
                  } else {
                     this.addMessage(`${attacker.name}'s HP is already full!`);
                  }
               }

               // Protection
               if (move.flags?.protect) {
                  // Check if protect was used recently (diminishing returns)
                  const protectCount = attacker.protectCount || 0;
                  const successChance = 1 / Math.pow(3, protectCount);

                  if (Math.random() < successChance) {
                     attacker.addVolatileStatus("protect");
                     attacker.protectCount = (attacker.protectCount || 0) + 1;
                     this.addMessage(`${attacker.name} protected itself!`);
                  } else {
                     this.addMessage(`${attacker.name} failed to protect itself!`);
                  }
               }

               // Weather/terrain setting
               if (move.weather) {
                  this.setWeather(move.weather);
               }
            }

            async executeSwitch(team, oldIndex, newIndex) {
               const isPlayer = team === this.playerTeam;
               const oldPokemon = team[oldIndex];
               const newPokemon = team[newIndex];

               // Trigger switch out abilities
               if (oldPokemon.ability?.data?.onSwitchOut) {
                  const message = oldPokemon.ability.data.onSwitchOut(this, oldPokemon);
                  if (message) this.addMessage(message);
               }

               // Reset battle state
               oldPokemon.resetBattleState();

               // Perform switch
               if (isPlayer) {
                  this.currentPlayerIndex = newIndex;
               } else {
                  this.currentEnemyIndex = newIndex;
               }

               this.addMessage(`${oldPokemon.name}, come back! Go, ${newPokemon.name}!`);

               // Trigger switch in abilities
               if (newPokemon.ability?.data?.onSwitchIn) {
                  const messages = newPokemon.ability.data.onSwitchIn(this, newPokemon);
                  if (Array.isArray(messages)) {
                     messages.forEach((msg) => this.addMessage(msg));
                  } else if (messages) {
                     this.addMessage(messages);
                  }
               }
            }

            calculateAccuracy(move, attacker, defender) {
               let accuracy = move.accuracy || 100;

               // Apply stat stages
               const accStage = attacker.statStages.accuracy - defender.statStages.evasion;
               if (accStage > 0) {
                  accuracy *= (3 + accStage) / 3;
               } else if (accStage < 0) {
                  accuracy *= 3 / (3 - accStage);
               }

               // Weather effects
               if (this.weather === WEATHER_TYPES.RAIN && move.id === "thunder") {
                  accuracy = 100;
               } else if (this.weather === WEATHER_TYPES.SUN && move.id === "thunder") {
                  accuracy = 50;
               }

               return Math.min(100, accuracy);
            }

            checkForFaints() {
               console.log("=== CHECK FOR FAINTS DEBUG ===");
               console.log("Player Pokemon HP:", this.playerPokemon.hp);
               console.log("Enemy Pokemon HP:", this.enemyPokemon.hp);

               let fainted = false;

               if (this.playerPokemon.hp === 0) {
                  console.log("Player Pokemon fainted!");
                  this.addMessage(`${this.playerPokemon.name} fainted!`);
                  soundManager.play("faint");
                  fainted = true;
                  this.faintAnimationInProgress = true;

                  // Check for more Pokemon
                  const nextIndex = this.playerTeam.findIndex(
                     (p, i) => i !== this.currentPlayerIndex && p.hp > 0
                  );
                  console.log("Next player Pokemon index:", nextIndex);
                  if (nextIndex === -1) {
                     console.log("No more player Pokemon - DEFEAT");
                     this.state = BATTLE_STATES.DEFEAT;
                     this.addMessage("You are out of usable Pokemon! You blacked out!");
                  } else {
                     console.log("Setting state to SWITCHING for player");
                     this.state = BATTLE_STATES.SWITCHING;
                     // Set up pending switch that will be executed after animation
                     this.pendingSwitch = {
                        type: "player",
                        newIndex: nextIndex,
                        oldPokemon: this.playerPokemon,
                     };
                  }
               }

               if (this.enemyPokemon.hp === 0) {
                  console.log("Enemy Pokemon fainted!");
                  this.addMessage(`${this.enemyPokemon.name} fainted!`);
                  soundManager.play("faint");
                  fainted = true;
                  this.faintAnimationInProgress = true;

                  // Check for more Pokemon
                  const nextIndex = this.enemyTeam.findIndex(
                     (p, i) => i !== this.currentEnemyIndex && p.hp > 0
                  );
                  console.log("Next enemy Pokemon index:", nextIndex);
                  if (nextIndex === -1) {
                     console.log("No more enemy Pokemon - VICTORY");
                     this.state = BATTLE_STATES.VICTORY;
                     this.addMessage("You won the battle!");
                  } else {
                     console.log("Setting state to SWITCHING for enemy");
                     this.state = BATTLE_STATES.SWITCHING;
                     this.pendingSwitch = {
                        type: "enemy",
                        newIndex: nextIndex,
                        oldPokemon: this.enemyPokemon,
                     };
                  }
               }

               console.log("Final fainted result:", fainted);
               console.log("Final battle state:", this.state);
               console.log("Pending switch:", this.pendingSwitch);
               return fainted;
            }

            // Method to execute the pending switch after faint animation
            executePendingSwitch() {
               console.log("=== EXECUTING PENDING SWITCH ===");
               console.log("Pending switch:", this.pendingSwitch);

               if (!this.pendingSwitch) {
                  console.log("No pending switch found");
                  return;
               }

               const { type, newIndex, oldPokemon } = this.pendingSwitch;
               console.log("Switching type:", type, "to index:", newIndex);

               if (type === "player") {
                  this.currentPlayerIndex = newIndex;
                  const newPokemon = this.playerPokemon;
                  oldPokemon.resetBattleState();
                  soundManager.play("switchIn");
                  this.addMessage(`Go, ${newPokemon.name}!`);
                  console.log("Player switched to:", newPokemon.name);

                  // Trigger switch-in abilities
                  if (newPokemon.ability?.data?.onSwitchIn) {
                     const messages = newPokemon.ability.data.onSwitchIn(this, newPokemon);
                     if (Array.isArray(messages)) {
                        messages.forEach((msg) => this.addMessage(msg));
                     } else if (messages) {
                        this.addMessage(messages);
                     }
                  }
               } else if (type === "enemy") {
                  this.currentEnemyIndex = newIndex;
                  const newPokemon = this.enemyPokemon;
                  oldPokemon.resetBattleState();
                  soundManager.play("switchIn");
                  this.addMessage(`Opponent sent out ${newPokemon.name}!`);
                  console.log("Enemy switched to:", newPokemon.name);

                  // Trigger switch-in abilities
                  if (newPokemon.ability?.data?.onSwitchIn) {
                     const messages = newPokemon.ability.data.onSwitchIn(this, newPokemon);
                     if (Array.isArray(messages)) {
                        messages.forEach((msg) => this.addMessage(msg));
                     } else if (messages) {
                        this.addMessage(messages);
                     }
                  }
               }

               this.pendingSwitch = null;
               this.faintAnimationInProgress = false;

               // IMPORTANT: Reset battle state to continue battle
               console.log("Resetting battle state to PLAYER_TURN");
               this.state = BATTLE_STATES.PLAYER_TURN;
            }

            async processTurnEnd() {
               // Weather countdown
               if (this.weatherTurns > 0) {
                  this.weatherTurns--;
                  if (this.weatherTurns === 0) {
                     this.weather = WEATHER_TYPES.CLEAR;
                     this.addMessage("The weather returned to normal.");
                  }
               }

               // Weather damage
               if (this.weather === WEATHER_TYPES.SANDSTORM) {
                  [this.playerPokemon, this.enemyPokemon].forEach((pokemon) => {
                     if (
                        pokemon.hp > 0 &&
                        !["Rock", "Ground", "Steel"].some((type) => pokemon.types.includes(type))
                     ) {
                        const damage = Math.floor(pokemon.maxHp / 16);
                        pokemon.takeDamage(damage);
                        this.addMessage(`${pokemon.name} is buffeted by the sandstorm!`);
                     }
                  });
               }

               if (this.weather === WEATHER_TYPES.HAIL) {
                  [this.playerPokemon, this.enemyPokemon].forEach((pokemon) => {
                     if (pokemon.hp > 0 && !pokemon.types.includes("Ice")) {
                        const damage = Math.floor(pokemon.maxHp / 16);
                        pokemon.takeDamage(damage);
                        this.addMessage(`${pokemon.name} is buffeted by the hail!`);
                     }
                  });
               }

               // Status damage
               [this.playerPokemon, this.enemyPokemon].forEach((pokemon) => {
                  if (pokemon.hp > 0) {
                     if (pokemon.status === "burn") {
                        const damage = Math.floor(pokemon.maxHp / 16);
                        pokemon.takeDamage(damage);
                        this.addMessage(`${pokemon.name} was hurt by its burn!`);
                     }
                     if (pokemon.status === "poison") {
                        const damage = Math.floor(pokemon.maxHp / 8);
                        pokemon.takeDamage(damage);
                        this.addMessage(`${pokemon.name} was hurt by poison!`);
                     }
                     if (pokemon.status === "toxic") {
                        // Toxic poison increases damage each turn
                        pokemon.toxicCounter = (pokemon.toxicCounter || 0) + 1;
                        const damage = Math.floor(pokemon.maxHp / 16) * pokemon.toxicCounter;
                        pokemon.takeDamage(damage);
                        this.addMessage(`${pokemon.name} was hurt by toxic poison!`);
                     }
                  }
               });

               // Leftovers healing
               [this.playerPokemon, this.enemyPokemon].forEach((pokemon) => {
                  if (pokemon.hp > 0 && pokemon.heldItem?.id === "leftovers") {
                     const heal = Math.floor(pokemon.maxHp / 16);
                     const actualHeal = pokemon.heal(heal);
                     if (actualHeal > 0) {
                        this.addMessage(
                           `${pokemon.name} restored a little HP using its Leftovers!`
                        );
                     }
                  }
               });

               // Berry activation
               [this.playerPokemon, this.enemyPokemon].forEach((pokemon) => {
                  if (pokemon.hp > 0 && pokemon.heldItem?.category === "berry") {
                     const item = ITEMS_DATA[pokemon.heldItem.id];

                     if (
                        item.trigger === "hp_below" &&
                        pokemon.hp <= pokemon.maxHp * item.threshold
                     ) {
                        if (item.effect === "heal") {
                           pokemon.heal(item.value);
                           this.addMessage(`${pokemon.name} restored HP using its ${item.name}!`);
                        } else if (item.effect === "heal_percent") {
                           pokemon.heal(Math.floor(pokemon.maxHp * item.value));
                           this.addMessage(`${pokemon.name} restored HP using its ${item.name}!`);
                        }
                        pokemon.heldItem = null; // Consume berry
                     }

                     if (
                        item.trigger === "has_status" &&
                        pokemon.status &&
                        item.effect === "cure_status"
                     ) {
                        pokemon.cureStatus();
                        this.addMessage(`${pokemon.name} cured its status using its ${item.name}!`);
                        pokemon.heldItem = null; // Consume berry
                     }
                  }
               });

               // Ability end-of-turn effects
               [this.playerPokemon, this.enemyPokemon].forEach((pokemon) => {
                  if (pokemon.hp > 0 && pokemon.ability?.data?.onTurnEnd) {
                     const message = pokemon.ability.data.onTurnEnd(this, pokemon);
                     if (message) this.addMessage(message);
                  }
               });

               // Check for faints from end-of-turn damage
               this.checkForFaints();

               // Clear volatile statuses that last one turn
               [this.playerPokemon, this.enemyPokemon].forEach((pokemon) => {
                  pokemon.removeVolatileStatus("protect");
                  pokemon.removeVolatileStatus("flinch");
                  // Reset protect count if didn't use protect this turn
                  if (!pokemon.hasVolatileStatus("protect")) {
                     pokemon.protectCount = 0;
                  }
               });
            }

            queueAction(action) {
               this.pendingActions.push(action);
            }
         }

         // ==================== UI COMPONENTS ====================

         // ==================== BATTLE VISUAL EFFECTS SYSTEM ====================

         // Battle Camera System
         class BattleCamera {
            constructor() {
               this.zoom = 1;
               this.offsetX = 0;
               this.offsetY = 0;
               this.shake = 0;
               this.shakeDecay = 0.9;
               this.isShaking = false;
            }

            // Zoom in during attacks
            focusAttack(attacker, target) {
               this.zoom = 1.2;
               this.offsetX = attacker === "player" ? -50 : 50;
               // Smooth transition back
               setTimeout(() => this.reset(), 1000);
            }

            // Screen shake on impact
            impact(intensity = 10) {
               this.shake = intensity;
               this.isShaking = true;
               this.startShakeDecay();
            }

            startShakeDecay() {
               if (this.shake > 0.5) {
                  this.shake *= this.shakeDecay;
                  requestAnimationFrame(() => this.startShakeDecay());
               } else {
                  this.shake = 0;
                  this.isShaking = false;
               }
            }

            reset() {
               this.zoom = 1;
               this.offsetX = 0;
               this.offsetY = 0;
            }

            getTransform() {
               const shakeX = this.isShaking ? (Math.random() - 0.5) * this.shake : 0;
               const shakeY = this.isShaking ? (Math.random() - 0.5) * this.shake : 0;

               return {
                  transform: `scale(${this.zoom}) translate(${this.offsetX + shakeX}px, ${
                     this.offsetY + shakeY
                  }px)`,
                  transition: this.isShaking ? "none" : "transform 0.5s ease-out",
               };
            }
         }

         // Move-Specific Animation Data
         const MOVE_ANIMATIONS = {
            thunderbolt: {
               particles: "electric-sparks",
               screenFlash: "#ffff00",
               cameraShake: 15,
               soundLayers: ["thunder-charge", "thunder-strike"],
               color: "#FFD700",
            },
            flamethrower: {
               particles: "fire-stream",
               screenTint: "#ff6600",
               heatWave: true,
               soundLayers: ["fire-whoosh", "fire-crackle"],
               color: "#FF4500",
            },
            tackle: {
               particles: "impact-dust",
               screenFlash: "#ffffff",
               cameraShake: 8,
               color: "#8B7355",
            },
            "water gun": {
               particles: "water-splash",
               screenTint: "#4169E1",
               cameraShake: 6,
               color: "#1E90FF",
            },
            scratch: {
               particles: "slash-marks",
               screenFlash: "#ffffff",
               cameraShake: 5,
               color: "#CD853F",
            },
         };

         // Type Colors for Effects
         const TYPE_COLORS = {
            normal: "#A8A878",
            fire: "#F08030",
            water: "#6890F0",
            electric: "#F8D030",
            grass: "#78C850",
            ice: "#98D8D8",
            fighting: "#C03028",
            poison: "#A040A0",
            ground: "#E0C068",
            flying: "#A890F0",
            psychic: "#F85888",
            bug: "#A8B820",
            rock: "#B8A038",
            ghost: "#705898",
            dragon: "#7038F8",
            dark: "#705848",
            steel: "#B8B8D0",
            fairy: "#EE99AC",
         };

         // Particle System
         class ParticleSystem {
            constructor() {
               this.particles = [];
            }

            createDamageParticles(x, y, moveType, effectiveness) {
               const particles = [];
               const color = TYPE_COLORS[moveType] || "#ffffff";
               const count = effectiveness > 1 ? 30 : 15;

               for (let i = 0; i < count; i++) {
                  particles.push({
                     x,
                     y,
                     vx: (Math.random() - 0.5) * 10,
                     vy: (Math.random() - 0.5) * 10,
                     color,
                     size: Math.random() * 5 + 2,
                     life: 1.0,
                     decay: 0.02,
                  });
               }

               return particles;
            }

            update() {
               this.particles = this.particles.filter((particle) => {
                  particle.x += particle.vx;
                  particle.y += particle.vy;
                  particle.life -= particle.decay;
                  particle.vy += 0.2; // gravity
                  return particle.life > 0;
               });
            }
         }

         // Screen Flash Effect Component
         const ScreenFlash = ({ color, duration = 200 }) => {
            const [isVisible, setIsVisible] = useState(true);

            useEffect(() => {
               const timer = setTimeout(() => setIsVisible(false), duration);
               return () => clearTimeout(timer);
            }, [duration]);

            if (!isVisible) return null;

            return (
               <div
                  className="fixed inset-0 pointer-events-none z-50 animate-pulse"
                  style={{
                     backgroundColor: color,
                     opacity: 0.3,
                     animation: `flash ${duration}ms ease-out`,
                  }}
               />
            );
         };

         // Enhanced HP Bar with Damage Preview
         const EnhancedHPBar = ({ pokemon, isPlayer, pendingDamage = 0 }) => {
            const [displayHP, setDisplayHP] = useState(pokemon.hp);
            const [animatingDamage, setAnimatingDamage] = useState(false);

            const currentHpPercentage = (pokemon.hp / pokemon.maxHp) * 100;
            const previewHpPercentage =
               pendingDamage > 0
                  ? (Math.max(0, pokemon.hp - pendingDamage) / pokemon.maxHp) * 100
                  : currentHpPercentage;

            let hpBarClass = "hp-bar-gradient-green";
            if (currentHpPercentage < 50) hpBarClass = "hp-bar-gradient-yellow";
            if (currentHpPercentage < 25) hpBarClass = "hp-bar-gradient-red";

            let previewBarClass = "hp-bar-gradient-green";
            if (previewHpPercentage < 50) previewBarClass = "hp-bar-gradient-yellow";
            if (previewHpPercentage < 25) previewBarClass = "hp-bar-gradient-red";

            useEffect(() => {
               if (displayHP !== pokemon.hp) {
                  setAnimatingDamage(true);
                  const animationTime = Math.abs(displayHP - pokemon.hp) * 20; // Animate based on damage amount

                  const startHP = displayHP;
                  const endHP = pokemon.hp;
                  const startTime = Date.now();

                  const animate = () => {
                     const elapsed = Date.now() - startTime;
                     const progress = Math.min(elapsed / animationTime, 1);

                     const currentHP = startHP + (endHP - startHP) * progress;
                     setDisplayHP(Math.round(currentHP));

                     if (progress < 1) {
                        requestAnimationFrame(animate);
                     } else {
                        setAnimatingDamage(false);
                     }
                  };

                  requestAnimationFrame(animate);
               }
            }, [pokemon.hp, displayHP]);

            return (
               <div className="mb-2">
                  <div className="flex items-center justify-between mb-1">
                     <span className="text-xs font-bold text-gray-700">HP</span>
                     <span className="text-xs text-gray-600 font-mono">
                        {Math.round(displayHP)}/{pokemon.maxHp}
                     </span>
                  </div>

                  <div className="hp-bar-container">
                     {/* Current HP Bar */}
                     <div
                        className={`hp-bar-fill ${hpBarClass}`}
                        style={{ width: `${(displayHP / pokemon.maxHp) * 100}%` }}
                     />

                     {/* Damage Preview Bar */}
                     {pendingDamage > 0 && (
                        <div
                           className="absolute top-0 left-0 h-full bg-red-400 opacity-50"
                           style={{
                              width: `${previewHpPercentage}%`,
                              marginLeft: `${previewHpPercentage}%`,
                           }}
                        />
                     )}

                     {/* Smooth damage transition overlay */}
                     {animatingDamage && (
                        <div className="absolute top-0 left-0 h-full bg-yellow-300 opacity-30 animate-pulse" />
                     )}
                  </div>
               </div>
            );
         };

         // Trainer Personality System
         const TRAINER_DIALOGUE = {
            aggressive: {
               taunt: [
                  "Is that all you've got?",
                  "My Pokemon are way stronger!",
                  "You'll have to do better than that!",
                  "Ha! Missed!",
               ],
               impressed: [
                  "Not bad, but we're just getting started!",
                  "Lucky shot!",
                  "That actually hurt!",
               ],
               desperate: ["This isn't over yet!", "We won't give up!", "Time to get serious!"],
               victory: [
                  "I told you my Pokemon were stronger!",
                  "Better luck next time!",
                  "That's how it's done!",
               ],
            },
            calm: {
               taunt: [
                  "An interesting strategy...",
                  "I see what you're trying to do.",
                  "Let me show you proper technique.",
               ],
               impressed: ["Well played.", "A solid move.", "Impressive strategy."],
               desperate: [
                  "The battle isn't decided yet.",
                  "Let's see what happens next.",
                  "This is getting interesting.",
               ],
               victory: [
                  "A good battle.",
                  "You fought well.",
                  "Perhaps we can battle again sometime.",
               ],
            },
            enthusiastic: {
               taunt: [
                  "This is so exciting!",
                  "I love a good battle!",
                  "Let's see what you can really do!",
               ],
               impressed: [
                  "Wow, that was amazing!",
                  "Incredible move!",
                  "Your Pokemon are so cool!",
               ],
               desperate: [
                  "This battle is incredible!",
                  "I'm having so much fun!",
                  "Let's give it everything we've got!",
               ],
               victory: [
                  "That was the best battle ever!",
                  "Your Pokemon were amazing!",
                  "Let's battle again soon!",
               ],
            },
         };

         // AI Personality System
         class PersonalityAI {
            constructor(personality = "calm") {
               this.personality = personality;
               this.dialogue = TRAINER_DIALOGUE[personality];
               this.lastReactionTime = 0;
               this.reactionCooldown = 3000; // 3 seconds between reactions
            }

            getReaction(situation) {
               const now = Date.now();
               if (now - this.lastReactionTime < this.reactionCooldown) {
                  return null; // Don't spam reactions
               }

               const reactions = this.dialogue[situation];
               if (reactions && reactions.length > 0) {
                  this.lastReactionTime = now;
                  return reactions[Math.floor(Math.random() * reactions.length)];
               }
               return null;
            }
         }

         // ==================== BATTLE COACH SYSTEM ====================
         // ==================== ENHANCED COACH SYSTEM ====================

         class EnhancedBattleCoach {
            constructor() {
               this.battleHistory = [];
               this.playerTendencies = new Map();
               this.successfulStrategies = new Map();
            }

            analyze(battle, playerPokemon, enemyPokemon) {
               const analysis = {
                  recommendations: [],
                  warnings: [],
                  opportunities: [],
                  longTermStrategy: null,
                  riskAssessment: {},
               };

               // Comprehensive battle state analysis
               const battleState = this.analyzeBattleState(battle, playerPokemon, enemyPokemon);

               // Generate recommendations
               analysis.recommendations = this.generateRecommendations(battleState);

               // Identify warnings and risks
               analysis.warnings = this.identifyWarnings(battleState);

               // Find opportunities
               analysis.opportunities = this.findOpportunities(battleState);

               // Suggest long-term strategy
               analysis.longTermStrategy = this.planLongTermStrategy(battleState);

               // Risk assessment for each option
               analysis.riskAssessment = this.assessRisks(battleState);

               return analysis;
            }

            analyzeBattleState(battle, playerPokemon, enemyPokemon) {
               return {
                  battle,
                  playerPokemon,
                  enemyPokemon,
                  playerTeam: battle.playerTeam,
                  enemyTeam: battle.enemyTeam,
                  turn: battle.turn,
                  weather: battle.weather,
                  playerTeamStatus: this.analyzeTeamStatus(battle.playerTeam),
                  enemyTeamStatus: this.analyzeTeamStatus(battle.enemyTeam),
                  momentum: this.calculateMomentum(battle),
                  threatLevel: this.assessThreatLevel(enemyPokemon, playerPokemon),
                  winConditions: this.identifyWinConditions(battle),
                  setupPotential: this.evaluateSetupPotential(playerPokemon, enemyPokemon),
                  speedTiers: this.calculateSpeedTiers(battle),
               };
            }

            generateRecommendations(battleState) {
               const recommendations = [];
               const { playerPokemon, enemyPokemon, battle } = battleState;

               // Analyze each move option
               playerPokemon.moves.forEach((move, index) => {
                  if (move.pp <= 0) return;

                  const moveAnalysis = this.analyzeMove(
                     move,
                     playerPokemon,
                     enemyPokemon,
                     battleState
                  );

                  recommendations.push({
                     type: "move",
                     moveIndex: index,
                     move: move,
                     score: moveAnalysis.score,
                     reasoning: moveAnalysis.reasoning,
                     priority: moveAnalysis.priority,
                     risk: moveAnalysis.risk,
                     reward: moveAnalysis.reward,
                     conditions: moveAnalysis.conditions,
                  });
               });

               // Analyze switch options
               battle.playerTeam.forEach((pokemon, index) => {
                  if (index === battle.currentPlayerIndex || pokemon.hp <= 0) return;

                  const switchAnalysis = this.analyzeSwitchOption(
                     pokemon,
                     enemyPokemon,
                     playerPokemon,
                     battleState
                  );

                  recommendations.push({
                     type: "switch",
                     pokemonIndex: index,
                     pokemon: pokemon,
                     score: switchAnalysis.score,
                     reasoning: switchAnalysis.reasoning,
                     priority: switchAnalysis.priority,
                     risk: switchAnalysis.risk,
                     reward: switchAnalysis.reward,
                     conditions: switchAnalysis.conditions,
                  });
               });

               // Sort by score but also consider risk/reward ratio
               recommendations.sort((a, b) => {
                  const aRiskAdjusted = a.score * (1 - a.risk * 0.3) + a.reward * 0.2;
                  const bRiskAdjusted = b.score * (1 - b.risk * 0.3) + b.reward * 0.2;
                  return bRiskAdjusted - aRiskAdjusted;
               });

               return recommendations;
            }

            analyzeMove(move, attacker, defender, battleState) {
               let score = 0;
               const reasoning = [];
               let priority = 0;
               let risk = 0;
               let reward = 0;
               const conditions = [];

               // Damage calculation
               if (move.power) {
                  const effectiveness = calculateTypeEffectiveness(move.type, defender.types);
                  const estimatedDamage = this.estimateDamage(
                     move,
                     attacker,
                     defender,
                     effectiveness
                  );

                  // Calculate damage ranges (min and max)
                  const minDamage = Math.floor(estimatedDamage * 0.85);
                  const maxDamage = Math.floor(estimatedDamage * 1.0);
                  const damagePercent = (estimatedDamage / defender.hp) * 100;
                  const minPercent = (minDamage / defender.hp) * 100;
                  const maxPercent = (maxDamage / defender.hp) * 100;

                  score += damagePercent * 0.6; // Increased weight for damage

                  // Effectiveness analysis with detailed feedback
                  if (effectiveness > 1) {
                     score *= effectiveness;
                     const effText =
                        effectiveness === 2
                           ? "2x"
                           : effectiveness === 4
                           ? "4x"
                           : `${effectiveness}x`;
                     reasoning.push(`Super effective (${effText} damage)`);
                     priority += Math.floor(effectiveness * 2);
                     reward += effectiveness * 25;
                  } else if (effectiveness < 1 && effectiveness > 0) {
                     score *= effectiveness;
                     const effText =
                        effectiveness === 0.5
                           ? "x"
                           : effectiveness === 0.25
                           ? "x"
                           : `${effectiveness}x`;
                     reasoning.push(`Not very effective (${effText} damage)`);
                     risk += (1 - effectiveness) * 25;
                  } else if (effectiveness === 0) {
                     score = 0;
                     reasoning.push(`No effect - move will fail!`);
                     risk = 100;
                  }

                  // STAB bonus
                  if (attacker.types && attacker.types.includes(move.type)) {
                     score *= 1.2;
                     reasoning.push(`STAB bonus (+50% damage)`);
                  }

                  // Damage threshold analysis
                  if (estimatedDamage >= defender.hp) {
                     score *= 3.0; // Increased KO bonus
                     reasoning.push(` GUARANTEED KO!`);
                     priority += 10;
                     reward += 75;
                  } else if (maxDamage >= defender.hp) {
                     score *= 2.2;
                     reasoning.push(
                        ` Possible KO (${Math.round(minPercent)}-${Math.round(
                           maxPercent
                        )}% damage)`
                     );
                     priority += 7;
                     reward += 50;
                  } else if (estimatedDamage >= defender.hp * 0.7) {
                     score *= 1.8;
                     reasoning.push(` Heavy damage (${Math.round(damagePercent)}% damage)`);
                     priority += 4;
                     reward += 30;
                  } else if (estimatedDamage >= defender.hp * 0.4) {
                     score *= 1.4;
                     reasoning.push(` Good damage (${Math.round(damagePercent)}% damage)`);
                     priority += 2;
                     reward += 15;
                  } else if (estimatedDamage >= defender.hp * 0.2) {
                     reasoning.push(` Moderate damage (${Math.round(damagePercent)}% damage)`);
                  } else {
                     reasoning.push(` Light damage (${Math.round(damagePercent)}% damage)`);
                     if (damagePercent < 10) {
                        risk += 20;
                        conditions.push(" Very low damage output");
                     }
                  }

                  // Speed analysis with more detail
                  const mySpeed = attacker.getBoostedStat("speed");
                  const oppSpeed = defender.getBoostedStat("speed");

                  if (move.priority > 0) {
                     reasoning.push(` Priority +${move.priority} - will move first`);
                     priority += move.priority * 3;
                     if (attacker.hp < attacker.maxHp * 0.3) {
                        score *= 1.6;
                        reasoning.push(` Critical HP - priority essential!`);
                     }
                  } else if (mySpeed > oppSpeed) {
                     reasoning.push(` You're faster - will move first`);
                     reward += 10;
                  } else if (mySpeed < oppSpeed) {
                     if (estimatedDamage < defender.hp) {
                        risk += 35;
                        conditions.push(` Opponent is faster and may counter-attack`);

                        // Check if opponent can KO us
                        const threatMoves = defender.moves.filter((m) => {
                           if (!m || !m.power || m.pp <= 0) return false;
                           const eff = calculateTypeEffectiveness(m.type, attacker.types);
                           const dmg = this.estimateDamage(m, defender, attacker, eff);
                           return dmg >= attacker.hp;
                        });

                        if (threatMoves.length > 0) {
                           risk += 50;
                           conditions.push(` DANGER: Opponent can KO you first!`);
                        }
                     }
                  }

                  // Recoil/drawback consideration with better feedback
                  if (move.recoil) {
                     const recoilDamage = Math.floor(estimatedDamage * move.recoil);
                     const recoilPercent = (recoilDamage / attacker.hp) * 100;
                     risk += recoilPercent * 0.8;
                     conditions.push(
                        ` Recoil: ${recoilDamage} damage (${Math.round(
                           recoilPercent
                        )}% of your HP)`
                     );

                     if (recoilDamage >= attacker.hp) {
                        risk += 100;
                        conditions.push(` FATAL: Recoil will KO you!`);
                     }
                  }

                  // Multi-hit moves
                  if (move.multihit) {
                     const hits = Array.isArray(move.multihit)
                        ? (move.multihit[0] + move.multihit[1]) / 2
                        : move.multihit;
                     reasoning.push(` Multi-hit: ~${hits} hits`);
                     if (hits > 2) reward += 15;
                  }
               }

               // Status move evaluation
               if (move.category === "status") {
                  const statusEval = this.evaluateStatusMove(move, attacker, defender, battleState);
                  score = statusEval.score;
                  reasoning.push(...statusEval.reasoning);
                  risk = statusEval.risk;
                  reward = statusEval.reward;
                  conditions.push(...statusEval.conditions);
               }

               // Weather considerations
               this.applyWeatherAnalysis(move, battleState, score, reasoning, conditions);

               // Accuracy risk
               if (move.accuracy && move.accuracy < 100) {
                  risk += (100 - move.accuracy) * 0.5;
                  if (move.accuracy <= 70) {
                     conditions.push(`Low accuracy (${move.accuracy}%) - risky`);
                  }
               }

               // Consider opponent's likely response
               const likelyResponse = this.predictOpponentResponse(move, defender, battleState);
               if (likelyResponse.threat) {
                  risk += likelyResponse.threatLevel;
                  conditions.push(likelyResponse.warning);
               }

               return { score, reasoning, priority, risk, reward, conditions };
            }

            evaluateStatusMove(move, attacker, defender, battleState) {
               let score = 35; // Base score for status moves
               const reasoning = [];
               let risk = 15; // Base risk for giving opponent a free turn
               let reward = 25;
               const conditions = [];

               // Setup moves analysis
               if (move.selfBoost) {
                  const hpPercent = attacker.hp / attacker.maxHp;

                  // HP-based setup viability
                  if (hpPercent > 0.8) {
                     score += 45;
                     reasoning.push(` Excellent HP for setup (${Math.round(hpPercent * 100)}%)`);
                     reward += 40;
                  } else if (hpPercent > 0.5) {
                     score += 25;
                     reasoning.push(` Good HP for setup (${Math.round(hpPercent * 100)}%)`);
                     reward += 25;
                  } else if (hpPercent > 0.3) {
                     score += 5;
                     reasoning.push(` Risky HP for setup (${Math.round(hpPercent * 100)}%)`);
                     risk += 25;
                  } else {
                     risk += 60;
                     conditions.push(` Critical HP - setup very dangerous!`);
                     score *= 0.2;
                  }

                  // Survival check - can we tank hits?
                  const maxThreat = this.calculateMaxThreatDamage(defender, attacker);
                  if (maxThreat >= attacker.hp) {
                     risk += 70;
                     conditions.push(` Opponent can KO you - setup not viable`);
                     score *= 0.15;
                  } else if (maxThreat >= attacker.hp * 0.7) {
                     risk += 40;
                     conditions.push(` Opponent deals heavy damage - risky setup`);
                     score *= 0.6;
                  }

                  // Analyze boost values with detailed feedback
                  Object.entries(move.selfBoost).forEach(([stat, boost]) => {
                     const currentStage = attacker.statStages[stat] || 0;
                     const maxedOut = currentStage >= 6;

                     if (maxedOut) {
                        conditions.push(` ${stat.toUpperCase()} already maxed out`);
                        score *= 0.3;
                        return;
                     }

                     const boostValue = boost * 20;
                     score += boostValue;

                     // Specific stat analysis
                     switch (stat) {
                        case "attack":
                           if (attacker.stats.attack > 100) {
                              reasoning.push(` Attack boost on strong attacker (+${boost})`);
                              reward += 30;
                           }
                           break;
                        case "spAttack":
                           if (attacker.stats.spAttack > 100) {
                              reasoning.push(
                                 ` Sp.Attack boost on strong special attacker (+${boost})`
                              );
                              reward += 30;
                           }
                           break;
                        case "speed":
                           const mySpeed = attacker.getBoostedStat("speed");
                           const oppSpeed = defender.getBoostedStat("speed");
                           if (mySpeed < oppSpeed) {
                              score += boostValue * 1.5;
                              reasoning.push(
                                 ` Speed boost will let you outspeed opponent (+${boost})`
                              );
                              reward += 35;
                           } else {
                              reasoning.push(` Speed boost (+${boost})`);
                           }
                           break;
                        case "defense":
                        case "spDefense":
                           reasoning.push(` Defensive boost (+${boost} ${stat})`);
                           if (hpPercent > 0.6) reward += 20;
                           break;
                     }
                  });
               }

               // Status condition infliction
               if (move.status && !defender.status) {
                  score += 60;

                  // Specific status condition analysis
                  switch (move.status) {
                     case "sleep":
                        score += 50;
                        reasoning.push(` Sleep - extremely powerful status!`);
                        reward += 60;
                        break;
                     case "paralysis":
                        const speedCheck =
                           defender.getBoostedStat("speed") > attacker.getBoostedStat("speed");
                        if (speedCheck) {
                           score += 40;
                           reasoning.push(` Paralysis will cripple faster opponent`);
                           reward += 45;
                        } else {
                           reasoning.push(` Paralysis reduces speed and causes flinching`);
                           reward += 25;
                        }
                        break;
                     case "burn":
                        if (defender.stats.attack > defender.stats.spAttack) {
                           score += 45;
                           reasoning.push(` Burn will halve physical attacker's damage`);
                           reward += 40;
                        } else {
                           reasoning.push(` Burn causes residual damage`);
                           reward += 20;
                        }
                        break;
                     case "poison":
                        reasoning.push(` Poison causes residual damage`);
                        reward += 20;
                        break;
                     case "toxic":
                        score += 30;
                        reasoning.push(` Toxic - increasing poison damage!`);
                        reward += 35;
                        break;
                     case "freeze":
                        score += 40;
                        reasoning.push(` Freeze - opponent likely can't move`);
                        reward += 50;
                        break;
                  }
               } else if (move.status && defender.status) {
                  score *= 0.1;
                  conditions.push(` Opponent already has status condition`);
                  risk += 30;
               }

               // Healing moves analysis
               if (
                  move.flags?.heal ||
                  move.name?.toLowerCase().includes("recover") ||
                  move.name?.toLowerCase().includes("heal") ||
                  move.name?.toLowerCase().includes("rest")
               ) {
                  const missingHp = attacker.maxHp - attacker.hp;
                  const missingPercent = (missingHp / attacker.maxHp) * 100;

                  if (missingPercent > 70) {
                     score += 70;
                     reasoning.push(
                        ` Excellent healing opportunity (${Math.round(
                           missingPercent
                        )}% missing HP)`
                     );
                     reward += 50;
                  } else if (missingPercent > 40) {
                     score += 40;
                     reasoning.push(
                        ` Good healing value (${Math.round(missingPercent)}% missing HP)`
                     );
                     reward += 30;
                  } else if (missingPercent > 15) {
                     score += 20;
                     reasoning.push(
                        ` Moderate healing (${Math.round(missingPercent)}% missing HP)`
                     );
                  } else {
                     score *= 0.3;
                     conditions.push(` Already near full HP - healing wasteful`);
                  }

                  // Check if healing is viable against opponent's damage
                  const avgDamage = this.estimateAverageOpponentDamage(defender, attacker);
                  const healAmount = attacker.maxHp * 0.5; // Assume 50% heal

                  if (avgDamage > healAmount * 1.5) {
                     risk += 40;
                     conditions.push(` Opponent outdamages healing - not sustainable`);
                  }
               }

               // Protection moves (Protect, Detect, etc.)
               if (
                  move.flags?.protect ||
                  move.name?.toLowerCase().includes("protect") ||
                  move.name?.toLowerCase().includes("detect")
               ) {
                  // Base protection value
                  score += 25;
                  reasoning.push(` Protection - blocks opponent's move`);

                  // Scouting value early in battle
                  if (battleState.turn <= 3) {
                     score += 35;
                     reasoning.push(` Great for scouting opponent's moves early`);
                  }

                  // Residual damage synergy
                  if (
                     defender.status === "toxic" ||
                     defender.status === "burn" ||
                     defender.status === "poison"
                  ) {
                     score += 45;
                     reasoning.push(` Stalls while opponent takes status damage`);
                     reward += 35;
                  }

                  // Weather synergy
                  if (
                     battleState.weather === WEATHER_TYPES.SANDSTORM ||
                     battleState.weather === WEATHER_TYPES.HAIL
                  ) {
                     if (
                        !attacker.types.includes("Rock") &&
                        !attacker.types.includes("Ground") &&
                        !attacker.types.includes("Steel") &&
                        !attacker.types.includes("Ice")
                     ) {
                        // We take weather damage but opponent might too
                        score += 15;
                        reasoning.push(` Stalls in weather`);
                     }
                  }

                  // Diminishing returns for consecutive protection
                  const protectCount = attacker.protectCount || 0;
                  if (protectCount > 0) {
                     const failChance = Math.min(100, protectCount * 33.33);
                     risk += failChance;
                     conditions.push(
                        ` ${Math.round(failChance)}% chance to fail (used ${protectCount} times)`
                     );
                     score *= 1 - failChance / 100;
                  }
               }

               // Entry hazard moves
               if (
                  move.name?.toLowerCase().includes("spikes") ||
                  move.name?.toLowerCase().includes("stealth") ||
                  move.name?.toLowerCase().includes("toxic spikes")
               ) {
                  score += 40;
                  reasoning.push(` Sets up entry hazards for switches`);
                  reward += 30;

                  // More valuable if opponent has multiple healthy Pokemon
                  const enemyHealthy = battleState.enemyTeamStatus?.healthy || 0;
                  if (enemyHealthy > 2) {
                     score += 25;
                     reasoning.push(` Enemy has ${enemyHealthy} healthy Pokemon for hazards`);
                  }
               }

               return { score, reasoning, risk, reward, conditions };
            }

            calculateMaxThreatDamage(opponent, defender) {
               let maxDamage = 0;

               if (!opponent.moves) return 0;

               opponent.moves.forEach((move) => {
                  if (!move || !move.power || move.pp <= 0) return;

                  const effectiveness = calculateTypeEffectiveness(move.type, defender.types);
                  const damage = this.estimateDamage(move, opponent, defender, effectiveness);
                  maxDamage = Math.max(maxDamage, damage);
               });

               return maxDamage;
            }

            // Enhanced threat analysis for better coach recommendations
            analyzeDetailedThreats(enemyPokemon, playerPokemon) {
               const threats = [];

               if (!enemyPokemon.moves) return threats;

               enemyPokemon.moves.forEach((move, index) => {
                  if (!move || !move.power || move.pp <= 0) return;

                  const effectiveness = calculateTypeEffectiveness(move.type, playerPokemon.types);
                  const damage = this.estimateDamage(
                     move,
                     enemyPokemon,
                     playerPokemon,
                     effectiveness
                  );
                  const damagePercent = (damage / playerPokemon.hp) * 100;

                  if (damagePercent > 30) {
                     // Only consider significant threats
                     threats.push({
                        move: move,
                        damage: damage,
                        damagePercent: damagePercent,
                        effectiveness: effectiveness,
                        canKO: damage >= playerPokemon.hp,
                        priority: move.priority || 0,
                        accuracy: move.accuracy || 100,
                     });
                  }
               });

               // Sort by damage potential
               threats.sort((a, b) => {
                  // Prioritize KO moves, then by damage
                  if (a.canKO && !b.canKO) return -1;
                  if (!a.canKO && b.canKO) return 1;
                  return b.damage - a.damage;
               });

               return threats;
            }

            // Improved type advantage calculator
            calculateDetailedTypeMatchup(attackerTypes, defenderTypes) {
               let bestOffensive = 1;
               let worstDefensive = 1;
               const details = [];

               // Calculate best offensive matchup
               attackerTypes.forEach((atkType) => {
                  defenderTypes.forEach((defType) => {
                     const effectiveness = TYPE_EFFECTIVENESS[atkType]?.[defType] ?? 1;
                     if (effectiveness > bestOffensive) {
                        bestOffensive = effectiveness;
                        details.push({
                           type: "offensive",
                           attackType: atkType,
                           defendType: defType,
                           effectiveness: effectiveness,
                        });
                     }
                  });
               });

               // Calculate defensive matchup (how well we resist their attacks)
               defenderTypes.forEach((defType) => {
                  attackerTypes.forEach((atkType) => {
                     const effectiveness = TYPE_EFFECTIVENESS[atkType]?.[defType] ?? 1;
                     if (effectiveness < worstDefensive) {
                        worstDefensive = effectiveness;
                        details.push({
                           type: "defensive",
                           attackType: atkType,
                           defendType: defType,
                           effectiveness: effectiveness,
                        });
                     }
                  });
               });

               return {
                  bestOffensive,
                  worstDefensive,
                  details,
                  overallAdvantage: bestOffensive * (2 - worstDefensive), // Combined score
               };
            }

            predictOpponentResponse(playerMove, opponent, battleState) {
               const response = {
                  threat: false,
                  threatLevel: 0,
                  warning: "",
                  likelyMove: null,
               };

               // Find opponent's most threatening moves
               const threateningMoves = opponent.moves.filter((m) => {
                  if (m.pp <= 0) return false;

                  const effectiveness = calculateTypeEffectiveness(
                     m.type,
                     battleState.playerPokemon.types
                  );
                  const damage = this.estimateDamage(
                     m,
                     opponent,
                     battleState.playerPokemon,
                     effectiveness
                  );

                  return damage > battleState.playerPokemon.hp * 0.5;
               });

               if (threateningMoves.length > 0) {
                  // Find the most likely threatening move
                  const mostLikely = threateningMoves.reduce((best, move) => {
                     const damage = this.estimateDamage(
                        move,
                        opponent,
                        battleState.playerPokemon,
                        calculateTypeEffectiveness(move.type, battleState.playerPokemon.types)
                     );

                     if (!best || damage > best.damage) {
                        return { move, damage };
                     }
                     return best;
                  }, null);

                  if (mostLikely) {
                     response.threat = true;
                     response.threatLevel = (mostLikely.damage / battleState.playerPokemon.hp) * 50;
                     response.likelyMove = mostLikely.move;

                     if (mostLikely.damage >= battleState.playerPokemon.hp) {
                        response.warning = `Opponent can KO with ${mostLikely.move.name}`;
                        response.threatLevel += 50;
                     } else {
                        response.warning = `Opponent can deal heavy damage with ${mostLikely.move.name}`;
                     }
                  }
               }

               return response;
            }

            identifyWarnings(battleState) {
               const warnings = [];

               // Low HP warning
               if (battleState.playerPokemon.hp < battleState.playerPokemon.maxHp * 0.25) {
                  warnings.push({
                     type: "critical-hp",
                     message: "Your Pokemon is at critical HP!",
                     severity: "high",
                  });
               }

               // Speed disadvantage
               const mySpeed = battleState.playerPokemon.getBoostedStat("speed");
               const oppSpeed = battleState.enemyPokemon.getBoostedStat("speed");
               if (oppSpeed > mySpeed) {
                  warnings.push({
                     type: "speed-disadvantage",
                     message: "Opponent is faster and will move first",
                     severity: "medium",
                  });
               }

               // Setup threat
               const enemyBoosts = Object.values(battleState.enemyPokemon.statStages).reduce(
                  (sum, stage) => sum + Math.max(0, stage),
                  0
               );
               if (enemyBoosts >= 3) {
                  warnings.push({
                     type: "enemy-setup",
                     message: `Opponent has significant stat boosts (+${enemyBoosts})`,
                     severity: "high",
                  });
               }

               // Weather disadvantage
               if (battleState.weather !== WEATHER_TYPES.CLEAR) {
                  const weatherWarning = this.checkWeatherDisadvantage(battleState);
                  if (weatherWarning) {
                     warnings.push(weatherWarning);
                  }
               }

               // Last Pokemon
               const healthyPokemon = battleState.playerTeamStatus.healthy;
               if (healthyPokemon === 1) {
                  warnings.push({
                     type: "last-pokemon",
                     message: "This is your last Pokemon!",
                     severity: "critical",
                  });
               }

               return warnings;
            }

            findOpportunities(battleState) {
               const opportunities = [];

               // Free setup opportunity
               if (
                  battleState.enemyPokemon.status === "sleep" ||
                  battleState.enemyPokemon.status === "freeze"
               ) {
                  opportunities.push({
                     type: "free-setup",
                     message: "Opponent is incapacitated - perfect time to setup!",
                     suggestedMoves: battleState.playerPokemon.moves.filter((m) => m.selfBoost),
                  });
               }

               // Type advantage opportunity
               const bestMatchup = this.calculateBestTypeMatchup(
                  battleState.playerPokemon.types,
                  battleState.enemyPokemon.types
               );
               if (bestMatchup > 1) {
                  opportunities.push({
                     type: "type-advantage",
                     message: `You have type advantage (${bestMatchup}x damage)`,
                     value: bestMatchup,
                  });
               }

               // Speed control opportunity
               if (
                  battleState.playerPokemon.moves.some((m) => m.status === "paralysis") &&
                  battleState.enemyPokemon.getBoostedStat("speed") >
                     battleState.playerPokemon.getBoostedStat("speed")
               ) {
                  opportunities.push({
                     type: "speed-control",
                     message: "Paralysis could neutralize opponent's speed advantage",
                  });
               }

               // Sweep opportunity
               const setupMoves = battleState.playerPokemon.moves.filter(
                  (m) => m.selfBoost && (m.selfBoost.attack > 0 || m.selfBoost.spAttack > 0)
               );
               if (setupMoves.length > 0 && battleState.enemyTeamStatus.healthy <= 2) {
                  opportunities.push({
                     type: "sweep-potential",
                     message: "Few enemy Pokemon left - setup sweep opportunity!",
                     suggestedMoves: setupMoves,
                  });
               }

               return opportunities;
            }

            planLongTermStrategy(battleState) {
               const strategies = [];

               // Analyze win conditions
               const winConditions = battleState.winConditions;

               // Setup sweep strategy
               if (
                  this.hasSetupSweeper(
                     battleState.playerTeam,
                     battleState.battle.currentPlayerIndex
                  )
               ) {
                  strategies.push({
                     name: "Setup Sweep",
                     description: "Set up a sweeper to clean through their team",
                     steps: [
                        "Weaken or remove Pokemon that threaten your sweeper",
                        "Find safe opportunity to set up",
                        "Sweep remaining team",
                     ],
                     viability: this.assessStrategyViability("setup-sweep", battleState),
                  });
               }

               // Defensive/stall strategy
               if (this.hasDefensivePokemon(battleState.playerTeam)) {
                  strategies.push({
                     name: "Defensive Stall",
                     description: "Wear down opponent with status and residual damage",
                     steps: [
                        "Inflict status conditions (toxic, burn)",
                        "Use recovery moves to stay healthy",
                        "Stall with protect/substitute",
                     ],
                     viability: this.assessStrategyViability("stall", battleState),
                  });
               }

               // Momentum strategy
               strategies.push({
                  name: "Offensive Momentum",
                  description: "Maintain pressure with strong attacks and good switches",
                  steps: [
                     "Use type advantages aggressively",
                     "Make predictive switches",
                     "Never give opponent free turns",
                  ],
                  viability: this.assessStrategyViability("momentum", battleState),
               });

               // Sort by viability
               strategies.sort((a, b) => b.viability - a.viability);

               return strategies[0] || null;
            }

            assessRisks(battleState) {
               const risks = {};

               // For each possible action, assess risk
               battleState.playerPokemon.moves.forEach((move, index) => {
                  if (move.pp <= 0) return;

                  risks[`move_${index}`] = this.calculateActionRisk(
                     { type: "move", move },
                     battleState
                  );
               });

               // Assess switch risks
               battleState.battle.playerTeam.forEach((pokemon, index) => {
                  if (index === battleState.battle.currentPlayerIndex || pokemon.hp <= 0) return;

                  risks[`switch_${index}`] = this.calculateActionRisk(
                     { type: "switch", pokemon },
                     battleState
                  );
               });

               return risks;
            }

            calculateActionRisk(action, battleState) {
               let risk = 0;
               const factors = [];

               if (action.type === "move") {
                  // Miss risk
                  if (action.move.accuracy && action.move.accuracy < 100) {
                     risk += (100 - action.move.accuracy) * 0.5;
                     factors.push(`${100 - action.move.accuracy}% chance to miss`);
                  }

                  // Recoil risk
                  if (action.move.recoil) {
                     risk += 20;
                     factors.push("Recoil damage");
                  }

                  // Setup risk (giving opponent free turn)
                  if (action.move.category === "status" && !action.move.flags?.protect) {
                     risk += 15;
                     factors.push("Gives opponent free turn");
                  }
               } else if (action.type === "switch") {
                  // Switch always gives opponent free turn
                  risk += 25;
                  factors.push("Opponent gets free turn");

                  // Entry hazard risk
                  if (battleState.hazards?.playerSide?.includes("spikes")) {
                     risk += 15;
                     factors.push("Will take hazard damage");
                  }
               }

               // Risk of being KO'd
               const koRisk = this.calculateKORisk(battleState);
               if (koRisk > 0) {
                  risk += koRisk;
                  factors.push(`${koRisk}% chance of being KO'd`);
               }

               return { total: risk, factors };
            }

            // Helper methods
            analyzeTeamStatus(team) {
               // Safety check for team parameter
               if (!team || !Array.isArray(team)) {
                  console.warn("analyzeTeamStatus: Invalid team parameter", team);
                  return {
                     healthy: 0,
                     damaged: 0,
                     statused: 0,
                     setupPotential: 0,
                  };
               }

               return {
                  healthy: team.filter((p) => p && p.hp > 0).length,
                  damaged: team.filter((p) => p && p.hp > 0 && p.hp < p.maxHp * 0.5).length,
                  statused: team.filter((p) => p && p.hp > 0 && p.status).length,
                  setupPotential: team.filter(
                     (p) => p && p.hp > 0 && p.moves && p.moves.some((m) => m && m.selfBoost)
                  ).length,
               };
            }

            calculateMomentum(battle) {
               // Safety check for battle parameter
               if (!battle || !battle.playerPokemon || !battle.enemyPokemon) {
                  console.warn("calculateMomentum: Invalid battle parameter", battle);
                  return 0;
               }

               let momentum = 0;

               // Recent knockouts
               const recentHistory = battle.history?.slice(-5) || [];
               recentHistory.forEach((event) => {
                  if (event && event.type === "knockout") {
                     momentum += event.team === "player" ? 20 : -20;
                  }
               });

               // Current Pokemon advantage
               const playerHP = (battle.playerPokemon.hp || 0) / (battle.playerPokemon.maxHp || 1);
               const enemyHP = (battle.enemyPokemon.hp || 0) / (battle.enemyPokemon.maxHp || 1);
               momentum += (playerHP - enemyHP) * 30;

               // Stat boosts
               const playerBoosts = Object.values(battle.playerPokemon.statStages || {}).reduce(
                  (sum, val) => sum + (val || 0),
                  0
               );
               const enemyBoosts = Object.values(battle.enemyPokemon.statStages || {}).reduce(
                  (sum, val) => sum + (val || 0),
                  0
               );
               momentum += (playerBoosts - enemyBoosts) * 10;

               return momentum;
            }

            assessThreatLevel(enemyPokemon, playerPokemon) {
               let threat = 0;

               // Can enemy KO us?
               const maxDamage = Math.max(
                  ...enemyPokemon.moves.map((move) => {
                     if (!move.power || move.pp === 0) return 0;
                     const effectiveness = calculateTypeEffectiveness(
                        move.type,
                        playerPokemon.types
                     );
                     return this.estimateDamage(move, enemyPokemon, playerPokemon, effectiveness);
                  })
               );

               if (maxDamage >= playerPokemon.hp) {
                  threat += 50;
               } else if (maxDamage >= playerPokemon.hp * 0.5) {
                  threat += 30;
               }

               // Speed threat
               if (enemyPokemon.getBoostedStat("speed") > playerPokemon.getBoostedStat("speed")) {
                  threat += 20;
               }

               // Setup threat
               const boosts = Object.values(enemyPokemon.statStages || {}).reduce(
                  (sum, val) => sum + Math.max(0, val),
                  0
               );
               threat += boosts * 10;

               return Math.min(100, threat);
            }

            identifyWinConditions(battle) {
               const conditions = [];

               // Sweep condition
               const sweepers = battle.playerTeam.filter(
                  (p) =>
                     p.hp > 0 &&
                     p.moves.some((m) => m.selfBoost) &&
                     (p.stats.attack > 100 || p.stats.spAttack > 100)
               );
               if (sweepers.length > 0) {
                  conditions.push({
                     type: "sweep",
                     pokemon: sweepers[0],
                     requirement: "Remove threats and set up",
                  });
               }

               // Defensive win
               const walls = battle.playerTeam.filter(
                  (p) =>
                     p.hp > 0 &&
                     (p.stats.defense > 100 || p.stats.spDefense > 100) &&
                     p.moves.some((m) => m.flags?.heal)
               );
               if (walls.length > 0) {
                  conditions.push({
                     type: "stall",
                     pokemon: walls[0],
                     requirement: "Inflict status and outlast",
                  });
               }

               return conditions;
            }

            calculateSpeedTiers(battle) {
               const tiers = [];

               // Get all Pokemon speeds
               const allPokemon = [
                  ...battle.playerTeam.map((p, i) => ({ pokemon: p, team: "player", index: i })),
                  ...battle.enemyTeam.map((p, i) => ({ pokemon: p, team: "enemy", index: i })),
               ].filter(({ pokemon }) => pokemon.hp > 0);

               // Calculate effective speeds
               allPokemon.forEach(({ pokemon, team, index }) => {
                  const speed = pokemon.getBoostedStat("speed");
                  tiers.push({ pokemon, team, index, speed });
               });

               // Sort by speed
               tiers.sort((a, b) => b.speed - a.speed);

               return tiers;
            }

            estimateDamage(move, attacker, defender, effectiveness) {
               if (!move || !move.power) return 0;

               const level = attacker.level || 50;
               const attack =
                  move.category === "physical"
                     ? attacker.getBoostedStat("attack")
                     : attacker.getBoostedStat("spAttack");
               const defense =
                  move.category === "physical"
                     ? defender.getBoostedStat("defense")
                     : defender.getBoostedStat("spDefense");

               // Base damage calculation using the standard Pokemon damage formula
               let damage = (((2 * level) / 5 + 2) * move.power * attack) / defense / 50 + 2;

               // Apply type effectiveness
               damage *= effectiveness || 1;

               // STAB (Same Type Attack Bonus)
               if (attacker.types && attacker.types.includes(move.type)) {
                  damage *= 1.5;
               }

               // Weather modifiers
               if (this.battleState && this.battleState.weather) {
                  damage = this.applyWeatherDamageModifier(damage, move, this.battleState.weather);
               }

               // Critical hit possibility (1/16 chance, increases damage by 1.5x)
               const critChance = 0.0625;
               const averageCritMultiplier = 1 + critChance * 0.5;
               damage *= averageCritMultiplier;

               // Random damage roll (85-100% of calculated damage)
               damage *= 0.925; // Average of the range

               return Math.floor(Math.max(1, damage));
            }

            applyWeatherDamageModifier(damage, move, weather) {
               switch (weather) {
                  case WEATHER_TYPES.SUN:
                     if (move.type === "Fire") return damage * 1.5;
                     if (move.type === "Water") return damage * 0.5;
                     break;
                  case WEATHER_TYPES.RAIN:
                     if (move.type === "Water") return damage * 1.5;
                     if (move.type === "Fire") return damage * 0.5;
                     break;
                  case WEATHER_TYPES.SANDSTORM:
                     if (move.type === "Rock") return damage * 1.5;
                     break;
               }
               return damage;
            }

            estimateAverageOpponentDamage(opponent, defender) {
               const damages = opponent.moves
                  .filter((m) => m.power && m.pp > 0)
                  .map((move) => {
                     const effectiveness = calculateTypeEffectiveness(move.type, defender.types);
                     return this.estimateDamage(move, opponent, defender, effectiveness);
                  });

               return damages.length > 0
                  ? damages.reduce((sum, d) => sum + d, 0) / damages.length
                  : 0;
            }

            calculateBestTypeMatchup(attackerTypes, defenderTypes) {
               let best = 1;
               attackerTypes.forEach((atkType) => {
                  defenderTypes.forEach((defType) => {
                     const effectiveness = TYPE_EFFECTIVENESS[atkType]?.[defType] ?? 1;
                     best = Math.max(best, effectiveness);
                  });
               });
               return best;
            }

            calculateWorstTypeMatchup(defenderTypes, attackerTypes) {
               let worst = 1;
               attackerTypes.forEach((atkType) => {
                  defenderTypes.forEach((defType) => {
                     const effectiveness = TYPE_EFFECTIVENESS[atkType]?.[defType] ?? 1;
                     worst = Math.min(worst, effectiveness);
                  });
               });
               return worst;
            }

            calculateKORisk(battleState) {
               const { playerPokemon, enemyPokemon } = battleState;
               let koChance = 0;

               enemyPokemon.moves.forEach((move) => {
                  if (!move.power || move.pp === 0) return;

                  const effectiveness = calculateTypeEffectiveness(move.type, playerPokemon.types);
                  const damage = this.estimateDamage(
                     move,
                     enemyPokemon,
                     playerPokemon,
                     effectiveness
                  );

                  if (damage >= playerPokemon.hp) {
                     // Account for accuracy
                     const hitChance = (move.accuracy || 100) / 100;
                     koChance = Math.max(koChance, hitChance * 100);
                  }
               });

               return Math.round(koChance);
            }

            checkWeatherDisadvantage(battleState) {
               const weather = battleState.weather;
               const playerTypes = battleState.playerPokemon.types;

               switch (weather) {
                  case WEATHER_TYPES.SUN:
                     if (playerTypes.includes("Water")) {
                        return {
                           type: "weather-disadvantage",
                           message: "Sun weakens Water moves",
                           severity: "medium",
                        };
                     }
                     break;
                  case WEATHER_TYPES.RAIN:
                     if (playerTypes.includes("Fire")) {
                        return {
                           type: "weather-disadvantage",
                           message: "Rain weakens Fire moves",
                           severity: "medium",
                        };
                     }
                     break;
                  case WEATHER_TYPES.SANDSTORM:
                     if (!["Rock", "Ground", "Steel"].some((t) => playerTypes.includes(t))) {
                        return {
                           type: "weather-damage",
                           message: "Taking damage from sandstorm",
                           severity: "low",
                        };
                     }
                     break;
               }

               return null;
            }

            hasSetupSweeper(team, currentIndex) {
               // Safety check for team parameter
               if (!team || !Array.isArray(team)) {
                  console.warn("hasSetupSweeper: Invalid team parameter", team);
                  return false;
               }

               return team.some((pokemon, index) => {
                  if (!pokemon || pokemon.hp <= 0) return false;

                  const hasSetup =
                     pokemon.moves &&
                     pokemon.moves.some(
                        (m) =>
                           m &&
                           m.selfBoost &&
                           (m.selfBoost.attack > 0 ||
                              m.selfBoost.spAttack > 0 ||
                              m.selfBoost.speed > 0)
                     );

                  const hasOffensiveStats =
                     pokemon.stats && (pokemon.stats.attack > 100 || pokemon.stats.spAttack > 100);

                  return hasSetup && hasOffensiveStats;
               });
            }

            hasDefensivePokemon(team) {
               // Safety check for team parameter
               if (!team || !Array.isArray(team)) {
                  console.warn("hasDefensivePokemon: Invalid team parameter", team);
                  return false;
               }

               return team.some((pokemon) => {
                  if (!pokemon || pokemon.hp <= 0) return false;

                  const hasDefensiveStats =
                     pokemon.stats &&
                     (pokemon.stats.defense > 100 || pokemon.stats.spDefense > 100);
                  const hasRecovery =
                     pokemon.moves && pokemon.moves.some((m) => m && m.flags?.heal);
                  const hasStatus =
                     pokemon.moves &&
                     pokemon.moves.some((m) => m && (m.status === "toxic" || m.status === "burn"));

                  return hasDefensiveStats && (hasRecovery || hasStatus);
               });
            }

            assessStrategyViability(strategy, battleState) {
               let viability = 50;

               switch (strategy) {
                  case "setup-sweep":
                     // Good if we have healthy setup sweepers
                     if (this.hasSetupSweeper(battleState.playerTeam)) {
                        viability += 20;
                     }
                     // Bad if opponent has priority moves
                     if (battleState.enemyPokemon.moves.some((m) => m.priority > 0)) {
                        viability -= 15;
                     }
                     // Good if opponent's team is weakened
                     if (battleState.enemyTeamStatus.healthy <= 2) {
                        viability += 25;
                     }
                     break;

                  case "stall":
                     // Good if we have defensive Pokemon
                     if (this.hasDefensivePokemon(battleState.playerTeam)) {
                        viability += 20;
                     }
                     // Bad if opponent has setup moves
                     if (battleState.enemyPokemon.moves.some((m) => m.selfBoost)) {
                        viability -= 20;
                     }
                     // Good if we can inflict status
                     if (battleState.playerPokemon.moves.some((m) => m.status)) {
                        viability += 15;
                     }
                     break;

                  case "momentum":
                     // Good if we have speed advantage
                     if (battleState.speedTiers[0]?.team === "player") {
                        viability += 20;
                     }
                     // Good if we have type advantages
                     if (battleState.momentum > 0) {
                        viability += battleState.momentum * 0.5;
                     }
                     break;
               }

               return Math.max(0, Math.min(100, viability));
            }

            applyWeatherAnalysis(move, battleState, score, reasoning, conditions) {
               // Weather considerations for move analysis
               switch (battleState.weather) {
                  case WEATHER_TYPES.SUN:
                     if (move.type === "Fire") {
                        reasoning.push("Sun boosts Fire moves");
                     }
                     if (move.type === "Water") {
                        conditions.push("Sun weakens Water moves");
                     }
                     break;
                  case WEATHER_TYPES.RAIN:
                     if (move.type === "Water") {
                        reasoning.push("Rain boosts Water moves");
                     }
                     if (move.type === "Fire") {
                        conditions.push("Rain weakens Fire moves");
                     }
                     break;
               }
            }

            analyzeSwitchOption(switchPokemon, enemyPokemon, currentPokemon, battleState) {
               let score = 0;
               const reasoning = [];
               let priority = 0;
               let risk = 25; // Base switching risk
               let reward = 0;
               const conditions = [];

               // Type matchup analysis
               const offensive = this.calculateBestTypeMatchup(
                  switchPokemon.types,
                  enemyPokemon.types
               );
               const defensive = this.calculateWorstTypeMatchup(
                  switchPokemon.types,
                  enemyPokemon.types
               );

               score += offensive * 30 + (1 / defensive) * 30;

               if (offensive > 1) {
                  reasoning.push(`Type advantage (${offensive}x damage)`);
                  reward += 25;
               }
               if (defensive < 1) {
                  reasoning.push(`Resists opponent's attacks (${defensive}x damage taken)`);
                  reward += 20;
               }

               // HP comparison
               const hpPercent = switchPokemon.hp / switchPokemon.maxHp;
               const currentHpPercent = currentPokemon.hp / currentPokemon.maxHp;

               if (hpPercent > currentHpPercent + 0.3) {
                  score += 40;
                  reasoning.push(`Much healthier than current Pokemon`);
                  priority += 2;
               }

               // Speed consideration
               if (switchPokemon.getBoostedStat("speed") > enemyPokemon.getBoostedStat("speed")) {
                  score += 20;
                  reasoning.push(`Will be faster than opponent`);
               }

               // Current Pokemon's state
               if (currentPokemon.hp < currentPokemon.maxHp * 0.25) {
                  score += 50;
                  reasoning.push(`Current Pokemon at critical HP`);
                  priority += 3;
               }

               // Status considerations
               if (currentPokemon.status && !switchPokemon.status) {
                  score += 30;
                  reasoning.push(`Removes status condition`);
               }

               // Entry hazards
               if (battleState.hazards?.playerSide?.includes("spikes")) {
                  risk += 20;
                  conditions.push(`Will take Spikes damage on entry`);
               }

               // Check if switch gives opponent setup opportunity
               if (enemyPokemon.moves.some((m) => m.selfBoost)) {
                  risk += 15;
                  conditions.push(`May give opponent setup opportunity`);
               }

               return { score, reasoning, priority, risk, reward, conditions };
            }

            evaluateSetupPotential(playerPokemon, enemyPokemon) {
               let potential = 0;

               // Check if player Pokemon has setup moves
               const setupMoves = playerPokemon.moves.filter((m) => m.selfBoost);
               if (setupMoves.length > 0) {
                  potential += 30;

                  // Higher potential if player has good offensive stats
                  if (playerPokemon.stats.attack > 100 || playerPokemon.stats.spAttack > 100) {
                     potential += 20;
                  }

                  // Higher potential if player is healthy
                  const hpPercent = playerPokemon.hp / playerPokemon.maxHp;
                  potential += hpPercent * 20;

                  // Lower potential if enemy is faster and threatening
                  if (
                     enemyPokemon.getBoostedStat("speed") > playerPokemon.getBoostedStat("speed")
                  ) {
                     const threatMoves = enemyPokemon.moves.filter((m) => {
                        if (!m.power || m.pp <= 0) return false;
                        const effectiveness = calculateTypeEffectiveness(
                           m.type,
                           playerPokemon.types
                        );
                        const damage = this.estimateDamage(
                           m,
                           enemyPokemon,
                           playerPokemon,
                           effectiveness
                        );
                        return damage > playerPokemon.hp * 0.5;
                     });

                     if (threatMoves.length > 0) {
                        potential -= 25;
                     }
                  }
               }

               return Math.max(0, potential);
            }
         }

         // Enhanced Battle Coach Component UI
         const EnhancedBattleCoachUI = ({ battle, playerPokemon, enemyPokemon, onClose }) => {
            const [viewMode, setViewMode] = useState("simple"); // 'simple', 'detailed', 'strategic'
            const [selectedRecommendation, setSelectedRecommendation] = useState(null);

            const coach = useMemo(() => new EnhancedBattleCoach(), []);
            const analysis = useMemo(
               () => coach.analyze(battle, playerPokemon, enemyPokemon),
               [battle, playerPokemon, enemyPokemon, coach]
            );

            const bestRecommendation = analysis.recommendations[0];

            return (
               <div className="absolute top-4 left-4 bg-white/95 border-4 border-black rounded-lg p-4 max-w-md shadow-lg z-50 max-h-[80vh] overflow-y-auto">
                  <div className="flex justify-between items-center mb-3">
                     <h3 className="font-bold text-sm flex items-center gap-2">
                        <span className="text-2xl"></span> Advanced Battle Coach
                     </h3>
                     <button onClick={onClose} className="text-gray-500 hover:text-black text-lg">
                        
                     </button>
                  </div>

                  {/* View Mode Tabs */}
                  <div className="flex gap-1 mb-3 text-xs">
                     <button
                        onClick={() => setViewMode("simple")}
                        className={`px-2 py-1 rounded ${
                           viewMode === "simple" ? "bg-blue-500 text-white" : "bg-gray-200"
                        }`}
                     >
                        Simple
                     </button>
                     <button
                        onClick={() => setViewMode("detailed")}
                        className={`px-2 py-1 rounded ${
                           viewMode === "detailed" ? "bg-blue-500 text-white" : "bg-gray-200"
                        }`}
                     >
                        Detailed
                     </button>
                     <button
                        onClick={() => setViewMode("strategic")}
                        className={`px-2 py-1 rounded ${
                           viewMode === "strategic" ? "bg-blue-500 text-white" : "bg-gray-200"
                        }`}
                     >
                        Strategic
                     </button>
                  </div>

                  {/* Warnings */}
                  {analysis.warnings.length > 0 && (
                     <div className="mb-3 space-y-1">
                        {analysis.warnings
                           .filter((w) => w.severity === "critical" || w.severity === "high")
                           .map((warning, i) => (
                              <div
                                 key={i}
                                 className={`text-xs p-2 rounded ${
                                    warning.severity === "critical"
                                       ? "bg-red-200 border border-red-400"
                                       : "bg-orange-200 border border-orange-400"
                                 }`}
                              >
                                  {warning.message}
                              </div>
                           ))}
                     </div>
                  )}

                  {/* Main Recommendation */}
                  {bestRecommendation && viewMode === "simple" && (
                     <div className="bg-gradient-to-r from-green-100 to-green-50 border-2 border-green-600 rounded-lg p-3 mb-3 shadow-md">
                        <div className="font-bold text-xs mb-1 text-green-800 flex items-center gap-1">
                            <span>BEST ACTION</span>
                           <span className="ml-auto text-[10px] bg-green-200 px-2 py-1 rounded">
                              Score: {bestRecommendation.score.toFixed(1)}
                           </span>
                        </div>
                        <div className="font-bold text-sm mb-2 text-gray-800">
                           {bestRecommendation.type === "move"
                              ? `Use ${bestRecommendation.move.name}`
                              : `Switch to ${bestRecommendation.pokemon.name}`}
                           {bestRecommendation.type === "move" && bestRecommendation.move.power && (
                              <span className="text-xs text-gray-600 ml-2">
                                 ({bestRecommendation.move.power} power,{" "}
                                 {bestRecommendation.move.type} type)
                              </span>
                           )}
                        </div>

                        <div className="space-y-1">
                           {bestRecommendation.reasoning.slice(0, 2).map((reason, i) => (
                              <div key={i} className="text-xs text-gray-700 flex items-start gap-1">
                                 <span className="text-green-600"></span>
                                 <span>{reason}</span>
                              </div>
                           ))}
                        </div>

                        {/* Risk/Reward indicators */}
                        <div className="flex gap-3 mt-2 text-xs">
                           <div className="flex items-center gap-1">
                              <div
                                 className={`w-3 h-3 rounded ${
                                    bestRecommendation.risk < 20
                                       ? "bg-green-400"
                                       : bestRecommendation.risk < 40
                                       ? "bg-yellow-400"
                                       : "bg-red-400"
                                 }`}
                              ></div>
                              <span className="text-gray-600">
                                 Risk: {Math.round(bestRecommendation.risk)}%
                              </span>
                           </div>
                           <div className="flex items-center gap-1">
                              <div
                                 className={`w-3 h-3 rounded ${
                                    bestRecommendation.reward > 40
                                       ? "bg-green-400"
                                       : bestRecommendation.reward > 20
                                       ? "bg-yellow-400"
                                       : "bg-gray-400"
                                 }`}
                              ></div>
                              <span className="text-gray-600">
                                 Reward: {Math.round(bestRecommendation.reward)}
                              </span>
                           </div>
                        </div>

                        {bestRecommendation.conditions.length > 0 && (
                           <div className="mt-2 p-2 bg-yellow-50 border border-yellow-300 rounded">
                              <div className="text-xs text-yellow-800 font-semibold mb-1">
                                  Important:
                              </div>
                              <div className="text-xs text-yellow-700">
                                 {bestRecommendation.conditions[0]}
                              </div>
                           </div>
                        )}
                     </div>
                  )}

                  {/* Detailed View */}
                  {viewMode === "detailed" && (
                     <div className="space-y-2">
                        <div className="text-xs font-bold mb-2 flex items-center gap-2">
                            All Options Analyzed:
                           <span className="text-[10px] text-gray-500 font-normal">
                              (Click for details)
                           </span>
                        </div>
                        {analysis.recommendations.slice(0, 6).map((rec, index) => {
                           const isTopChoice = index === 0;
                           const isGoodChoice = rec.score >= (bestRecommendation?.score || 0) * 0.7;
                           const riskLevel =
                              rec.risk < 25 ? "low" : rec.risk < 50 ? "medium" : "high";

                           return (
                              <div
                                 key={index}
                                 onClick={() => setSelectedRecommendation(rec)}
                                 className={`p-3 rounded-lg border cursor-pointer text-xs transition-all hover:shadow-md ${
                                    isTopChoice
                                       ? "bg-gradient-to-r from-green-50 to-green-25 border-green-400 shadow-sm"
                                       : isGoodChoice
                                       ? "bg-blue-50 border-blue-300"
                                       : "bg-gray-50 border-gray-300"
                                 } ${
                                    selectedRecommendation === rec
                                       ? "ring-2 ring-blue-400 shadow-md"
                                       : ""
                                 }`}
                              >
                                 <div className="flex justify-between items-start mb-2">
                                    <div className="font-semibold text-gray-800">
                                       {isTopChoice && " "}
                                       {rec.type === "move"
                                          ? rec.move.name
                                          : `Switch to ${rec.pokemon.name}`}
                                       {rec.type === "move" && rec.move.power && (
                                          <span className="text-[10px] text-gray-500 ml-1">
                                             ({rec.move.power}BP)
                                          </span>
                                       )}
                                    </div>
                                    <div className="flex items-center gap-2">
                                       <span
                                          className={`text-[10px] px-2 py-1 rounded ${
                                             riskLevel === "low"
                                                ? "bg-green-200 text-green-800"
                                                : riskLevel === "medium"
                                                ? "bg-yellow-200 text-yellow-800"
                                                : "bg-red-200 text-red-800"
                                          }`}
                                       >
                                          {riskLevel.toUpperCase()}
                                       </span>
                                       <span className="text-[10px] text-gray-500 font-mono">
                                          {rec.score.toFixed(1)}
                                       </span>
                                    </div>
                                 </div>

                                 <div className="text-[10px] text-gray-600 mb-2">
                                    {rec.reasoning[0]}
                                 </div>

                                 <div className="flex justify-between items-center">
                                    <div className="flex gap-3 text-[10px]">
                                       <span
                                          className={`${
                                             rec.risk < 25
                                                ? "text-green-600"
                                                : rec.risk < 50
                                                ? "text-yellow-600"
                                                : "text-red-600"
                                          }`}
                                       >
                                           {Math.round(rec.risk)}%
                                       </span>
                                       <span
                                          className={`${
                                             rec.reward > 40
                                                ? "text-green-600"
                                                : rec.reward > 20
                                                ? "text-yellow-600"
                                                : "text-gray-600"
                                          }`}
                                       >
                                           {Math.round(rec.reward)}
                                       </span>
                                    </div>
                                    {rec.priority > 0 && (
                                       <span className="text-[10px] bg-purple-200 text-purple-800 px-2 py-1 rounded">
                                          Priority: {rec.priority}
                                       </span>
                                    )}
                                 </div>
                              </div>
                           );
                        })}

                        {selectedRecommendation && (
                           <div className="mt-3 p-3 bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-300 rounded-lg text-xs">
                              <div className="font-bold mb-2 text-blue-800 flex items-center gap-1">
                                  <span>Detailed Analysis</span>
                              </div>

                              <div className="mb-3">
                                 <div className="font-semibold text-gray-700 mb-1">Reasoning:</div>
                                 <ul className="space-y-1 text-[10px]">
                                    {selectedRecommendation.reasoning.map((reason, i) => (
                                       <li key={i} className="flex items-start gap-1">
                                          <span className="text-blue-600 mt-0.5"></span>
                                          <span>{reason}</span>
                                       </li>
                                    ))}
                                 </ul>
                              </div>

                              {selectedRecommendation.conditions.length > 0 && (
                                 <div>
                                    <div className="font-semibold text-gray-700 mb-1">
                                       Important Notes:
                                    </div>
                                    <ul className="space-y-1 text-[10px]">
                                       {selectedRecommendation.conditions.map((condition, i) => (
                                          <li
                                             key={i}
                                             className="flex items-start gap-1 text-orange-700"
                                          >
                                             <span className="text-orange-600 mt-0.5"></span>
                                             <span>{condition}</span>
                                          </li>
                                       ))}
                                    </ul>
                                 </div>
                              )}
                           </div>
                        )}
                     </div>
                  )}

                  {/* Strategic View */}
                  {viewMode === "strategic" && (
                     <div className="space-y-3 text-xs">
                        {/* Long-term Strategy */}
                        {analysis.longTermStrategy && (
                           <div className="bg-purple-50 border border-purple-300 rounded p-2">
                              <div className="font-bold text-purple-800 mb-1">
                                  Recommended Strategy: {analysis.longTermStrategy.name}
                              </div>
                              <div className="text-[10px] mb-2">
                                 {analysis.longTermStrategy.description}
                              </div>
                              <div className="text-[10px]">
                                 <div className="font-semibold mb-1">Steps:</div>
                                 <ol className="list-decimal list-inside space-y-1">
                                    {analysis.longTermStrategy.steps.map((step, i) => (
                                       <li key={i}>{step}</li>
                                    ))}
                                 </ol>
                              </div>
                              <div className="mt-2 text-[10px]">
                                 Viability: {analysis.longTermStrategy.viability}%
                              </div>
                           </div>
                        )}

                        {/* Opportunities */}
                        {analysis.opportunities.length > 0 && (
                           <div className="bg-yellow-50 border border-yellow-300 rounded p-2">
                              <div className="font-bold text-yellow-800 mb-1"> Opportunities</div>
                              {analysis.opportunities.map((opp, i) => (
                                 <div key={i} className="text-[10px] mb-1">
                                     {opp.message}
                                 </div>
                              ))}
                           </div>
                        )}

                        {/* Battle State Overview */}
                        <div className="bg-gray-50 border border-gray-300 rounded p-2">
                           <div className="font-bold mb-1">Battle State</div>
                           <div className="grid grid-cols-2 gap-2 text-[10px]">
                              <div>
                                 <span className="font-semibold">Your Team:</span>
                                 <div>
                                    Healthy: {battle.playerTeam.filter((p) => p.hp > 0).length}
                                 </div>
                                 <div>
                                    Setup Potential:{" "}
                                    {
                                       battle.playerTeam.filter(
                                          (p) => p.hp > 0 && p.moves.some((m) => m.selfBoost)
                                       ).length
                                    }
                                 </div>
                              </div>
                              <div>
                                 <span className="font-semibold">Enemy Team:</span>
                                 <div>
                                    Healthy: {battle.enemyTeam.filter((p) => p.hp > 0).length}
                                 </div>
                                 <div>
                                    Threats:{" "}
                                    {
                                       battle.enemyTeam.filter((p) => {
                                          if (p.hp <= 0) return false;
                                          return p.moves.some((m) => {
                                             if (!m.power) return false;
                                             const eff = calculateTypeEffectiveness(
                                                m.type,
                                                playerPokemon.types
                                             );
                                             return eff > 1;
                                          });
                                       }).length
                                    }
                                 </div>
                              </div>
                           </div>
                        </div>
                     </div>
                  )}

                  {/* Quick Tips */}
                  <div className="mt-3 pt-3 border-t border-gray-200 text-[10px] text-gray-600">
                     <div className="font-semibold mb-1">Quick Tips:</div>
                     <div> Press Tab to cycle view modes</div>
                     <div> Numbers in () show risk percentage</div>
                     <div> Green = recommended, Orange = risky</div>
                  </div>
               </div>
            );
         };

         // Backward compatibility alias
         const BattleCoach = ({ battle, playerPokemon, enemyPokemon, onClose }) => {
            return (
               <EnhancedBattleCoachUI
                  battle={battle}
                  playerPokemon={playerPokemon}
                  enemyPokemon={enemyPokemon}
                  onClose={onClose}
               />
            );
         };

         // Coach Analysis Functions
         // Backward compatibility wrapper functions for the enhanced coach system
         function analyzeMove(move, attacker, defender, battle) {
            const coach = new EnhancedBattleCoach();
            const battleState = {
               battle,
               playerPokemon: attacker,
               enemyPokemon: defender,
               turn: battle.turn || 1,
               weather: battle.weather || WEATHER_TYPES.CLEAR,
            };

            const analysis = coach.analyzeMove(move, attacker, defender, battleState);
            return {
               score: analysis.score,
               reasoning: analysis.reasoning,
               priority: analysis.priority,
            };
         }

         function analyzeSwitchOption(switchPokemon, enemyPokemon, currentPokemon, battle) {
            const coach = new EnhancedBattleCoach();
            const battleState = {
               battle,
               playerPokemon: currentPokemon,
               enemyPokemon: enemyPokemon,
               turn: battle.turn || 1,
               weather: battle.weather || WEATHER_TYPES.CLEAR,
            };

            const analysis = coach.analyzeSwitchOption(
               switchPokemon,
               enemyPokemon,
               currentPokemon,
               battleState
            );
            return {
               score: analysis.score,
               reasoning: analysis.reasoning,
               priority: analysis.priority,
            };
         }

         function estimateDamage(move, attacker, defender, effectiveness) {
            const coach = new EnhancedBattleCoach();
            return coach.estimateDamage(
               move,
               attacker,
               defender,
               effectiveness || calculateTypeEffectiveness(move.type, defender.types)
            );
         }

         function calculateBestTypeMatchup(attackerTypes, defenderTypes) {
            const coach = new EnhancedBattleCoach();
            return coach.calculateBestTypeMatchup(attackerTypes, defenderTypes);
         }

         function calculateWorstTypeMatchup(defenderTypes, attackerTypes) {
            const coach = new EnhancedBattleCoach();
            return coach.calculateWorstTypeMatchup(defenderTypes, attackerTypes);
         }

         function evaluateStatusMove(move, attacker, defender, battle) {
            const coach = new EnhancedBattleCoach();
            const battleState = {
               battle,
               playerPokemon: attacker,
               enemyPokemon: defender,
               turn: battle.turn || 1,
               weather: battle.weather || WEATHER_TYPES.CLEAR,
            };

            const analysis = coach.evaluateStatusMove(move, attacker, defender, battleState);
            return analysis.score;
         }

         function getTypeAdvantageDescription(yourTypes, oppTypes) {
            const coach = new EnhancedBattleCoach();
            const offensive = coach.calculateBestTypeMatchup(yourTypes, oppTypes);
            const defensive = coach.calculateWorstTypeMatchup(yourTypes, oppTypes);

            if (offensive > 1 && defensive >= 1) return "You have advantage";
            if (offensive <= 1 && defensive < 1) return "Opponent has advantage";
            if (offensive > 1 && defensive < 1) return "Mixed matchup";
            return "Neutral matchup";
         }

         // Loading Screen Component
         const LoadingScreen = () => {
            return (
               <div className="loading-screen">
                  <div className="loading-pokeball">
                     <svg viewBox="0 0 100 100">
                        <circle cx="50" cy="50" r="45" fill="#ff0000" />
                        <rect x="5" y="45" width="90" height="10" fill="#000" />
                        <circle cx="50" cy="50" r="15" fill="#fff" stroke="#000" strokeWidth="3" />
                        <circle cx="50" cy="50" r="8" fill="#000" />
                     </svg>
                  </div>
                  <p
                     className="mt-4 text-gray-800 animate-pulse"
                     style={{ textShadow: "1px 1px 2px rgba(255, 255, 255, 0.8)" }}
                  >
                     Loading...
                  </p>
               </div>
            );
         };

         // Main Menu Component
         const MainMenu = ({ onNewGame, onLoadGame, onSettings, onMultiplayer, gameStats }) => {
            const [showStats, setShowStats] = useState(false);

            return (
               <div className="min-h-screen flex items-center justify-center p-4">
                  <div className="text-center">
                     <h1
                        className="text-6xl text-white mb-4"
                        style={{ textShadow: "3px 3px 0 #000" }}
                     >
                        Pokemon Battle
                     </h1>
                     <h2
                        className="text-3xl text-gray-200 mb-12"
                        style={{ textShadow: "2px 2px 0 #000" }}
                     >
                        Ultimate Arena
                     </h2>

                     <div className="flex flex-col gap-4 items-center">
                        <button
                           onClick={onNewGame}
                           className="text-2xl text-white animate-pulse hover:scale-110 transition-transform"
                           style={{ textShadow: "2px 2px 0 #000" }}
                        >
                           NEW GAME
                        </button>

                        <button
                           onClick={onMultiplayer}
                           className="text-xl text-yellow-300 hover:text-yellow-100 transition-colors hover:scale-110 transform"
                           style={{ textShadow: "2px 2px 0 #000" }}
                        >
                           MULTIPLAYER
                        </button>

                        {localStorage.getItem("pokemonSaveData") && (
                           <button
                              onClick={onLoadGame}
                              className="text-xl text-gray-300 hover:text-white transition-colors"
                              style={{ textShadow: "2px 2px 0 #000" }}
                           >
                              CONTINUE
                           </button>
                        )}

                        <button
                           onClick={() => setShowStats(!showStats)}
                           className="text-lg text-gray-300 hover:text-white transition-colors"
                           style={{ textShadow: "2px 2px 0 #000" }}
                        >
                           STATISTICS
                        </button>

                        <button
                           onClick={onSettings}
                           className="text-lg text-gray-300 hover:text-white transition-colors"
                           style={{ textShadow: "2px 2px 0 #000" }}
                        >
                           SETTINGS
                        </button>
                     </div>

                     {showStats && (
                        <div className="mt-8 bg-black/50 p-4 rounded-lg text-white text-xs">
                           <h3 className="mb-2">Your Stats</h3>
                           <div className="grid grid-cols-2 gap-2 text-left">
                              <div>Battles: {gameStats.totalBattles}</div>
                              <div>Wins: {gameStats.wins}</div>
                              <div>
                                 Win Rate:{" "}
                                 {gameStats.totalBattles > 0
                                    ? Math.round((gameStats.wins / gameStats.totalBattles) * 100)
                                    : 0}
                                 %
                              </div>
                              <div>Best Streak: {gameStats.bestStreak || 0}</div>
                           </div>
                        </div>
                     )}

                     <div className="mt-8 text-xs text-gray-400">
                        <p>Version {GAME_VERSION}</p>
                        <p className="mt-2">Press F11 for fullscreen</p>
                     </div>
                  </div>
               </div>
            );
         };

         // Team Builder Component
         const TeamBuilder = ({ onConfirm, onBack, format = BATTLE_FORMATS.SINGLES_6V6 }) => {
            const [selectedTeam, setSelectedTeam] = useState([]);
            const [hoveredPokemon, setHoveredPokemon] = useState(null);
            const [searchQuery, setSearchQuery] = useState("");

            const availablePokemon = Object.values(POKEMON_DATA).filter((p) =>
               p.name.toLowerCase().includes(searchQuery.toLowerCase())
            );

            const handlePokemonSelect = (pokemon) => {
               if (selectedTeam.some((p) => p.id === pokemon.id)) {
                  setSelectedTeam(selectedTeam.filter((p) => p.id !== pokemon.id));
               } else if (selectedTeam.length < format.teamSize) {
                  setSelectedTeam([...selectedTeam, pokemon]);
               }
               soundManager.play("select");
            };

            const handleConfirm = () => {
               if (selectedTeam.length === format.teamSize) {
                  soundManager.play("confirm");
                  onConfirm(selectedTeam);
               }
            };

            return (
               <div className="min-h-screen p-4">
                  <div className="max-w-7xl mx-auto">
                     <div className="text-center mb-6">
                        <h1
                           className="text-3xl text-white mb-2"
                           style={{ textShadow: "2px 2px 0 #000" }}
                        >
                           Build Your Team
                        </h1>
                        <p
                           className="text-sm text-gray-200"
                           style={{ textShadow: "1px 1px 0 #000" }}
                        >
                           Select {format.teamSize} Pokemon ({selectedTeam.length}/{format.teamSize}
                           )
                        </p>
                     </div>

                     <div className="mb-4">
                        <input
                           type="text"
                           placeholder="Search Pokemon..."
                           value={searchQuery}
                           onChange={(e) => setSearchQuery(e.target.value)}
                           className="w-full max-w-md mx-auto block px-4 py-2 bg-white/90 border-2 border-black rounded text-sm"
                        />
                     </div>

                     <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 mb-6 max-h-96 overflow-y-auto custom-scrollbar">
                        {availablePokemon.map((pokemon) => {
                           const isSelected = selectedTeam.some((p) => p.id === pokemon.id);
                           return (
                              <div
                                 key={pokemon.id}
                                 onClick={() => handlePokemonSelect(pokemon)}
                                 onMouseEnter={() => setHoveredPokemon(pokemon)}
                                 onMouseLeave={() => setHoveredPokemon(null)}
                                 className={`bg-white/90 p-3 rounded-lg cursor-pointer transform transition-all duration-200 border-4 ${
                                    isSelected
                                       ? "border-yellow-400 scale-105"
                                       : "border-gray-400 hover:scale-105"
                                 }`}
                              >
                                 <img
                                    src={pokemon.sprite}
                                    alt={pokemon.name}
                                    className="w-20 h-20 mx-auto pixelated"
                                 />
                                 <p className="mt-2 text-xs text-center font-bold">
                                    {pokemon.name}
                                 </p>
                                 <div className="flex gap-1 mt-1 justify-center">
                                    {pokemon.types.map((type) => (
                                       <span
                                          key={type}
                                          className={`text-[8px] text-white px-1 rounded type-${type.toLowerCase()}`}
                                       >
                                          {type}
                                       </span>
                                    ))}
                                 </div>
                              </div>
                           );
                        })}
                     </div>

                     {hoveredPokemon && (
                        <div className="fixed bottom-4 right-4 bg-white/95 p-4 rounded-lg border-2 border-black shadow-lg max-w-sm">
                           <h3 className="font-bold mb-2">{hoveredPokemon.name}</h3>
                           <div className="text-xs space-y-1">
                              <div>Types: {hoveredPokemon.types.join(" / ")}</div>
                              <div className="grid grid-cols-3 gap-1 mt-2">
                                 <div>HP: {hoveredPokemon.baseStats.hp}</div>
                                 <div>Atk: {hoveredPokemon.baseStats.attack}</div>
                                 <div>Def: {hoveredPokemon.baseStats.defense}</div>
                                 <div>SpA: {hoveredPokemon.baseStats.spAttack}</div>
                                 <div>SpD: {hoveredPokemon.baseStats.spDefense}</div>
                                 <div>Spe: {hoveredPokemon.baseStats.speed}</div>
                              </div>
                              <div className="mt-2">
                                 <strong>Abilities:</strong>{" "}
                                 {hoveredPokemon.abilities
                                    .map((a) => ABILITIES_DATA[a]?.name || a)
                                    .join(", ")}
                              </div>
                           </div>
                        </div>
                     )}

                     <div className="text-center">
                        <div className="mb-4">
                           <h3 className="text-white mb-2" style={{ textShadow: "1px 1px 0 #000" }}>
                              Your Team
                           </h3>
                           <div className="flex justify-center gap-2">
                              {Array.from({ length: format.teamSize }).map((_, i) => (
                                 <div
                                    key={i}
                                    className="w-20 h-20 bg-white/30 rounded-lg border-2 border-dashed border-white/50 flex items-center justify-center"
                                 >
                                    {selectedTeam[i] ? (
                                       <img
                                          src={selectedTeam[i].sprite}
                                          alt={selectedTeam[i].name}
                                          className="w-16 h-16 pixelated"
                                       />
                                    ) : (
                                       <span
                                          className="text-gray-600 text-2xl"
                                          style={{
                                             textShadow: "1px 1px 2px rgba(255, 255, 255, 0.8)",
                                          }}
                                       >
                                          ?
                                       </span>
                                    )}
                                 </div>
                              ))}
                           </div>
                        </div>

                        <div className="flex gap-4 justify-center">
                           <button
                              onClick={onBack}
                              className="action-button bg-gray-300 hover:bg-gray-400 text-black px-6 py-2 rounded-lg"
                           >
                              Back
                           </button>
                           <button
                              onClick={handleConfirm}
                              disabled={selectedTeam.length !== format.teamSize}
                              className="action-button bg-green-400 hover:bg-green-500 text-black px-6 py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed"
                           >
                              Confirm Team
                           </button>
                        </div>
                     </div>
                  </div>
               </div>
            );
         };

         // Multiplayer Lobby Component
         const MultiplayerLobby = ({ onBack }) => {
            const [lobbyState, setLobbyState] = useState("menu"); // menu, creating, joining, waiting, room
            const [playerName, setPlayerName] = useState("");
            const [roomCode, setRoomCode] = useState("");
            const [currentRoom, setCurrentRoom] = useState(null);
            const [players, setPlayers] = useState([]);
            const [connectionStatus, setConnectionStatus] = useState("disconnected");
            const [selectedTeam, setSelectedTeam] = useState([]);
            const [isReady, setIsReady] = useState(false);
            const [chatMessages, setChatMessages] = useState([]);
            const [chatInput, setChatInput] = useState("");
            const [error, setError] = useState("");

            useEffect(() => {
               // Initialize multiplayer connection
               const initConnection = async () => {
                  try {
                     setConnectionStatus("connecting");
                     await multiplayerManager.connect();
                     setConnectionStatus("connected");
                  } catch (error) {
                     console.error("Failed to connect to multiplayer server:", error);
                     setConnectionStatus("error");
                     setError(
                        "Could not connect to multiplayer server. Make sure the server is running."
                     );
                  }
               };

               initConnection();

               // Set up event handlers
               const handleRoomCreated = (data) => {
                  if (data.success) {
                     setCurrentRoom(data.room);
                     setPlayers(data.room.players);
                     setLobbyState("room");
                     setError("");
                  } else {
                     setError(data.error);
                  }
               };

               const handleRoomJoined = (data) => {
                  if (data.success) {
                     setCurrentRoom(data.room);
                     setPlayers(data.room.players);
                     setLobbyState("room");
                     setError("");
                  } else {
                     setError(data.error);
                  }
               };

               const handlePlayerJoined = (data) => {
                  setPlayers(data.room.players);
                  setChatMessages((prev) => [
                     ...prev,
                     {
                        type: "system",
                        message: `${data.player.name} joined the room`,
                        timestamp: new Date().toISOString(),
                     },
                  ]);
               };

               const handlePlayerStatusUpdated = (data) => {
                  setPlayers(data.room.players);
               };

               const handleBattleStart = (data) => {
                  setLobbyState("battle");
                  setChatMessages((prev) => [
                     ...prev,
                     {
                        type: "system",
                        message: "Battle starting!",
                        timestamp: new Date().toISOString(),
                     },
                  ]);
               };

               const handleChatMessage = (data) => {
                  setChatMessages((prev) => [
                     ...prev,
                     {
                        type: "player",
                        playerId: data.playerId,
                        playerName: data.playerName,
                        message: data.message,
                        timestamp: data.timestamp,
                     },
                  ]);
               };

               const handlePlayerDisconnected = (data) => {
                  setPlayers(data.room.players);
                  setChatMessages((prev) => [
                     ...prev,
                     {
                        type: "system",
                        message: "A player disconnected",
                        timestamp: new Date().toISOString(),
                     },
                  ]);
               };

               multiplayerManager.on("room_created", handleRoomCreated);
               multiplayerManager.on("room_joined", handleRoomJoined);
               multiplayerManager.on("player_joined", handlePlayerJoined);
               multiplayerManager.on("player_status_updated", handlePlayerStatusUpdated);
               multiplayerManager.on("battle_start", handleBattleStart);
               multiplayerManager.on("chat_message", handleChatMessage);
               multiplayerManager.on("player_disconnected", handlePlayerDisconnected);

               return () => {
                  multiplayerManager.off("room_created", handleRoomCreated);
                  multiplayerManager.off("room_joined", handleRoomJoined);
                  multiplayerManager.off("player_joined", handlePlayerJoined);
                  multiplayerManager.off("player_status_updated", handlePlayerStatusUpdated);
                  multiplayerManager.off("battle_start", handleBattleStart);
                  multiplayerManager.off("chat_message", handleChatMessage);
                  multiplayerManager.off("player_disconnected", handlePlayerDisconnected);
               };
            }, []);

            const handleCreateRoom = () => {
               if (!playerName.trim()) {
                  setError("Please enter your name");
                  return;
               }
               setLobbyState("creating");
               multiplayerManager.createRoom(playerName.trim());
            };

            const handleJoinRoom = () => {
               if (!playerName.trim() || !roomCode.trim()) {
                  setError("Please enter your name and room code");
                  return;
               }
               setLobbyState("joining");
               multiplayerManager.joinRoom(roomCode.trim().toUpperCase(), playerName.trim());
            };

            const handleQuickMatch = () => {
               if (!playerName.trim()) {
                  setError("Please enter your name");
                  return;
               }
               setLobbyState("waiting");
               multiplayerManager.quickMatch(playerName.trim());
            };

            const handleTeamReady = () => {
               if (selectedTeam.length === 0) {
                  setError("Please select a team first");
                  return;
               }
               const newReadyState = !isReady;
               setIsReady(newReadyState);
               multiplayerManager.setReady(newReadyState, selectedTeam);
            };

            const handleSendMessage = () => {
               if (chatInput.trim()) {
                  multiplayerManager.sendMessage(chatInput.trim());
                  setChatInput("");
               }
            };

            const handleLeaveRoom = () => {
               multiplayerManager.leaveRoom();
               setCurrentRoom(null);
               setPlayers([]);
               setSelectedTeam([]);
               setIsReady(false);
               setChatMessages([]);
               setLobbyState("menu");
            };

            // Connection status display
            const renderConnectionStatus = () => {
               switch (connectionStatus) {
                  case "connecting":
                     return (
                        <div className="text-center p-8">
                           <div className="text-yellow-300 text-lg mb-4">
                               Connecting to server...
                           </div>
                           <div className="text-sm text-gray-300">
                              Please wait while we establish connection
                           </div>
                        </div>
                     );
                  case "error":
                     return (
                        <div className="text-center p-8">
                           <div className="text-red-400 text-lg mb-4"> Connection Failed</div>
                           <div className="text-sm text-gray-300 mb-4">{error}</div>
                           <div className="text-xs text-gray-400">
                              Make sure the server is running on localhost:3001
                              <br />
                              Run: cd server && npm start
                           </div>
                           <button
                              onClick={onBack}
                              className="action-button bg-gray-300 hover:bg-gray-400 text-black px-6 py-2 rounded-lg mt-4"
                           >
                              Back to Menu
                           </button>
                        </div>
                     );
                  default:
                     return null;
               }
            };

            if (connectionStatus !== "connected") {
               return (
                  <div className="min-h-screen flex items-center justify-center p-4">
                     <div className="text-box max-w-md">{renderConnectionStatus()}</div>
                  </div>
               );
            }

            return (
               <div className="min-h-screen p-4">
                  <div className="max-w-4xl mx-auto">
                     <div className="text-center mb-6">
                        <h1
                           className="text-4xl text-white mb-2"
                           style={{ textShadow: "2px 2px 0 #000" }}
                        >
                           Multiplayer Lobby
                        </h1>
                        <div className="text-sm text-gray-200">
                           Status: <span className="text-green-400"> Connected</span>
                        </div>
                     </div>

                     {error && (
                        <div className="bg-red-500/20 border border-red-500 rounded-lg p-4 mb-4">
                           <div className="text-red-200">{error}</div>
                        </div>
                     )}

                     {lobbyState === "menu" && (
                        <div className="text-box max-w-md mx-auto">
                           <div className="space-y-4">
                              <div>
                                 <label className="block text-sm font-bold mb-2">Your Name:</label>
                                 <input
                                    type="text"
                                    value={playerName}
                                    onChange={(e) => setPlayerName(e.target.value)}
                                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                                    placeholder="Enter your name"
                                    maxLength="20"
                                 />
                              </div>

                              <div className="space-y-2">
                                 <button
                                    onClick={handleCreateRoom}
                                    className="action-button w-full bg-blue-400 hover:bg-blue-500 text-black py-3 rounded-lg"
                                 >
                                     Create Private Room
                                 </button>

                                 <button
                                    onClick={handleQuickMatch}
                                    className="action-button w-full bg-green-400 hover:bg-green-500 text-black py-3 rounded-lg"
                                 >
                                     Quick Match
                                 </button>

                                 <div className="border-t pt-2">
                                    <input
                                       type="text"
                                       value={roomCode}
                                       onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
                                       className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 mb-2"
                                       placeholder="Enter room code"
                                       maxLength="6"
                                    />
                                    <button
                                       onClick={handleJoinRoom}
                                       className="action-button w-full bg-yellow-400 hover:bg-yellow-500 text-black py-3 rounded-lg"
                                    >
                                        Join Room
                                    </button>
                                 </div>
                              </div>

                              <button
                                 onClick={onBack}
                                 className="action-button w-full bg-gray-300 hover:bg-gray-400 text-black py-2 rounded-lg"
                              >
                                 Back to Main Menu
                              </button>
                           </div>
                        </div>
                     )}

                     {(lobbyState === "creating" ||
                        lobbyState === "joining" ||
                        lobbyState === "waiting") && (
                        <div className="text-center">
                           <div className="text-white text-lg mb-4">
                              {lobbyState === "creating" && " Creating room..."}
                              {lobbyState === "joining" && " Joining room..."}
                              {lobbyState === "waiting" && " Finding opponent..."}
                           </div>
                           <div className="animate-pulse text-gray-300">Please wait...</div>
                        </div>
                     )}

                     {lobbyState === "room" && currentRoom && (
                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                           {/* Room Info */}
                           <div className="lg:col-span-2">
                              <div className="text-box mb-4">
                                 <h3 className="text-lg font-bold mb-4">
                                    Room: {currentRoom.code}
                                 </h3>
                                 <div className="room-code text-center">{currentRoom.code}</div>
                                 <div className="text-center text-sm text-gray-600 mt-2">
                                    Share this code with your friend!
                                 </div>
                              </div>

                              {/* Players */}
                              <div className="text-box mb-4">
                                 <h4 className="font-bold mb-3">Players ({players.length}/2)</h4>
                                 <div className="space-y-2">
                                    {players.map((player) => (
                                       <div
                                          key={player.id}
                                          className="flex items-center justify-between p-2 bg-gray-100 rounded"
                                       >
                                          <div className="flex items-center gap-2">
                                             <span className="font-bold">{player.name}</span>
                                             {player.isHost && (
                                                <span className="text-xs bg-blue-500 text-white px-2 py-1 rounded">
                                                   HOST
                                                </span>
                                             )}
                                          </div>
                                          <div className="flex items-center gap-2">
                                             {player.ready ? (
                                                <span className="text-green-600"> Ready</span>
                                             ) : (
                                                <span className="text-gray-500"> Not Ready</span>
                                             )}
                                          </div>
                                       </div>
                                    ))}
                                 </div>
                              </div>

                              {/* Team Selection */}
                              <div className="text-box">
                                 <h4 className="font-bold mb-3">Your Team</h4>
                                 <div className="text-sm mb-4">
                                    For quick multiplayer, you can use a preset team or select your
                                    own Pokmon.
                                 </div>

                                 <div className="space-y-2">
                                    <button
                                       onClick={() => {
                                          // Quick preset team
                                          const presetTeam = [
                                             POKEMON_DATA[25], // Pikachu
                                             POKEMON_DATA[6], // Charizard
                                             POKEMON_DATA[9], // Blastoise
                                          ].map((p) => new Pokemon(p, 50));
                                          setSelectedTeam(presetTeam);
                                       }}
                                       className="action-button w-full bg-purple-300 hover:bg-purple-400 text-black py-2 rounded-lg"
                                    >
                                        Use Random Team
                                    </button>

                                    <div className="text-xs text-gray-600">
                                       Team:{" "}
                                       {selectedTeam.length > 0
                                          ? selectedTeam.map((p) => p.name).join(", ")
                                          : "No team selected"}
                                    </div>
                                 </div>

                                 <div className="mt-4 flex gap-2">
                                    <button
                                       onClick={handleTeamReady}
                                       disabled={selectedTeam.length === 0}
                                       className={`action-button flex-1 py-2 rounded-lg ${
                                          isReady
                                             ? "bg-red-300 hover:bg-red-400"
                                             : "bg-green-300 hover:bg-green-400"
                                       } text-black disabled:opacity-50`}
                                    >
                                       {isReady ? " Cancel Ready" : " Ready Up"}
                                    </button>

                                    <button
                                       onClick={handleLeaveRoom}
                                       className="action-button bg-gray-300 hover:bg-gray-400 text-black px-4 py-2 rounded-lg"
                                    >
                                        Leave
                                    </button>
                                 </div>
                              </div>
                           </div>

                           {/* Chat */}
                           <div className="text-box h-96 flex flex-col">
                              <h4 className="font-bold mb-3">Chat</h4>
                              <div className="flex-1 overflow-y-auto space-y-2 text-xs mb-3">
                                 {chatMessages.map((msg, index) => (
                                    <div
                                       key={index}
                                       className={`p-2 rounded ${
                                          msg.type === "system"
                                             ? "bg-blue-100 italic"
                                             : "bg-gray-100"
                                       }`}
                                    >
                                       {msg.type === "player" && (
                                          <span className="font-bold">{msg.playerName}: </span>
                                       )}
                                       {msg.message}
                                    </div>
                                 ))}
                              </div>
                              <div className="flex gap-2">
                                 <input
                                    type="text"
                                    value={chatInput}
                                    onChange={(e) => setChatInput(e.target.value)}
                                    onKeyPress={(e) => e.key === "Enter" && handleSendMessage()}
                                    className="flex-1 px-2 py-1 border border-gray-300 rounded text-xs"
                                    placeholder="Type a message..."
                                    maxLength="100"
                                 />
                                 <button
                                    onClick={handleSendMessage}
                                    className="action-button bg-blue-300 hover:bg-blue-400 text-black px-3 py-1 rounded text-xs"
                                 >
                                    Send
                                 </button>
                              </div>
                           </div>
                        </div>
                     )}
                  </div>
               </div>
            );
         };

         // Pokemon Status Display Component
         const PokemonStatus = ({ pokemon, isPlayer }) => {
            // Safety check
            if (!pokemon) {
               return (
                  <div className="pokemon-info-card p-3">
                     <div className="text-xs">Loading...</div>
                  </div>
               );
            }

            const hpPercentage = (pokemon.hp / pokemon.maxHp) * 100;
            let hpBarClass = "hp-bar-gradient-green";
            if (hpPercentage < 50) hpBarClass = "hp-bar-gradient-yellow";
            if (hpPercentage < 25) hpBarClass = "hp-bar-gradient-red";

            return (
               <div className={`pokemon-info-card p-3 ${isPlayer ? "" : ""}`}>
                  {/* Pokemon name and level */}
                  <div className="flex justify-between items-center mb-2">
                     <span className="font-bold text-sm text-gray-800">{pokemon.name}</span>
                     <span className="text-xs bg-gray-700 text-white px-2 py-1 rounded">
                        Lv.{pokemon.level}
                     </span>
                  </div>

                  <EnhancedHPBar pokemon={pokemon} isPlayer={isPlayer} />

                  {/* Types and Status */}
                  <div className="flex gap-1 items-center justify-between">
                     <div className="flex gap-1">
                        {pokemon.types.map((type) => (
                           <span
                              key={type}
                              className={`text-[9px] text-white px-2 py-0.5 rounded type-${type.toLowerCase()} font-bold`}
                              style={{ textShadow: "1px 1px 0 rgba(0,0,0,0.8)" }}
                           >
                              {type}
                           </span>
                        ))}
                     </div>

                     {/* Status Effect Indicator */}
                     {pokemon.status && pokemon.status !== "none" && (
                        <div className="relative">
                           <div
                              className={`status-effect-indicator status-${pokemon.status.toLowerCase()}`}
                           >
                              {pokemon.status.substring(0, 3).toUpperCase()}
                           </div>
                        </div>
                     )}
                  </div>
               </div>
            );
         };

         // Battle Scene Component
         const BattleScene = ({ battle, playerPokemon, enemyPokemon, isAnimating }) => {
            const [showDamage, setShowDamage] = useState(null);
            const [screenFlash, setScreenFlash] = useState(null);
            const [cameraShake, setCameraShake] = useState(false);
            const cameraRef = useRef(new BattleCamera());

            useEffect(() => {
               if (showDamage) {
                  const timer = setTimeout(() => setShowDamage(null), 1500);
                  return () => clearTimeout(timer);
               }
            }, [showDamage]);

            // Effect for triggering screen flash and camera shake on moves
            useEffect(() => {
               if (isAnimating && battle.lastUsedMove) {
                  const moveData = MOVE_ANIMATIONS[battle.lastUsedMove.name.toLowerCase()];
                  if (moveData) {
                     // Screen flash
                     if (moveData.screenFlash) {
                        setScreenFlash(moveData.screenFlash);
                        setTimeout(() => setScreenFlash(null), 300);
                     }

                     // Camera shake
                     if (moveData.cameraShake) {
                        cameraRef.current.impact(moveData.cameraShake);
                        setCameraShake(true);
                        setTimeout(() => setCameraShake(false), 500);
                     }
                  }
               }
            }, [isAnimating, battle.lastUsedMove]);

            // Safety check - don't render if Pokemon are not available
            if (!playerPokemon || !enemyPokemon) {
               return (
                  <div className="relative h-[500px] rounded-lg overflow-hidden flex items-center justify-center">
                     <div
                        className="text-gray-800 text-lg"
                        style={{ textShadow: "1px 1px 2px rgba(255, 255, 255, 0.8)" }}
                     >
                        Loading...
                     </div>
                  </div>
               );
            }

            return (
               <div className="battle-terrain relative h-[500px] rounded-lg overflow-hidden">
                  {/* Screen Flash Effect */}
                  {screenFlash && <ScreenFlash color={screenFlash} duration={300} />}
                  {/* Main Battle Scene with Camera Transform */}
                  <div style={cameraRef.current.getTransform()} className="relative w-full h-full">
                     {/* Weather Effects */}
                     {battle.weather === WEATHER_TYPES.RAIN && (
                        <div className="absolute inset-0 pointer-events-none z-10 weather-rain">
                           <div className="weather-indicator">
                              <span className="weather-text">RAIN</span>
                           </div>
                        </div>
                     )}
                     {battle.weather === WEATHER_TYPES.SANDSTORM && (
                        <div className="absolute inset-0 pointer-events-none z-10 weather-sandstorm">
                           <div className="weather-indicator">
                              <span className="weather-text">SANDSTORM</span>
                           </div>
                        </div>
                     )}

                     {/* Turn Indicator */}
                     <div className="turn-indicator">Turn {battle.turn || 1}</div>

                     {/* Team Indicators */}
                     <div className="absolute top-6 left-6 z-20">
                        <div className="team-indicator-container flex gap-2">
                           {battle.playerTeam.map((p, i) => {
                              const hpPercentage = (p.hp / p.maxHp) * 100;
                              let statusClass = "";

                              if (p.hp === 0) {
                                 statusClass = "fainted";
                              } else if (hpPercentage <= 20) {
                                 statusClass = "critical-hp";
                              } else if (hpPercentage <= 50) {
                                 statusClass = "low-hp";
                              } else {
                                 statusClass = "healthy";
                              }

                              const activeClass = i === battle.currentPlayerIndex ? "active" : "";

                              return (
                                 <div
                                    key={i}
                                    className={`pokeball-mini ${statusClass} ${activeClass}`}
                                    title={`${p.name} - HP: ${p.hp}/${p.maxHp} (${Math.round(
                                       hpPercentage
                                    )}%)`}
                                 />
                              );
                           })}
                        </div>
                     </div>

                     <div className="absolute top-6 right-6 z-20">
                        <div className="team-indicator-container flex gap-2">
                           {battle.enemyTeam.map((p, i) => {
                              const hpPercentage = (p.hp / p.maxHp) * 100;
                              let statusClass = "";

                              if (p.hp === 0) {
                                 statusClass = "fainted";
                              } else if (hpPercentage <= 20) {
                                 statusClass = "critical-hp";
                              } else if (hpPercentage <= 50) {
                                 statusClass = "low-hp";
                              } else {
                                 statusClass = "healthy";
                              }

                              const activeClass = i === battle.currentEnemyIndex ? "active" : "";

                              return (
                                 <div
                                    key={i}
                                    className={`pokeball-mini ${statusClass} ${activeClass}`}
                                    title={`${p.name} - HP: ${p.hp}/${p.maxHp} (${Math.round(
                                       hpPercentage
                                    )}%)`}
                                 />
                              );
                           })}
                        </div>
                     </div>

                     {/* Enemy Pokemon */}
                     <div className="absolute top-24 right-8">
                        <PokemonStatus pokemon={enemyPokemon} isPlayer={false} />
                     </div>
                     <div className="absolute top-40 right-16">
                        <img
                           src={enemyPokemon.sprite}
                           alt={enemyPokemon.name}
                           className={`pixelated w-40 h-40 ${
                              enemyPokemon.hp === 0 ? "animate-faint" : ""
                           } ${isAnimating === "enemy-attack" ? "animate-enemy-attack" : ""} ${
                              isAnimating === "player-damage" ? "animate-damage" : ""
                           } ${isAnimating === "enemy-take-damage" ? "animate-damage-shake" : ""} ${
                              battle.lastDamageWasCritical && isAnimating === "enemy-take-damage"
                                 ? "animate-critical-hit"
                                 : ""
                           } ${enemyPokemon.status ? `status-${enemyPokemon.status}` : ""}`}
                        />
                        <div className="battle-platform mt-2" />
                     </div>

                     {/* Player Pokemon */}
                     <div className="absolute bottom-32 left-8">
                        <PokemonStatus pokemon={playerPokemon} isPlayer={true} />
                     </div>
                     <div className="absolute bottom-16 left-16">
                        <img
                           src={playerPokemon.spriteBack}
                           alt={playerPokemon.name}
                           className={`pixelated w-48 h-48 ${
                              playerPokemon.hp === 0 ? "animate-faint" : ""
                           } ${isAnimating === "player-attack" ? "animate-player-attack" : ""} ${
                              isAnimating === "enemy-damage" ? "animate-damage" : ""
                           } ${
                              isAnimating === "player-take-damage" ? "animate-damage-shake" : ""
                           } ${
                              battle.lastDamageWasCritical && isAnimating === "player-take-damage"
                                 ? "animate-critical-hit"
                                 : ""
                           } ${playerPokemon.status ? `status-${playerPokemon.status}` : ""}`}
                        />
                        <div className="battle-platform mt-2" />
                     </div>

                     {/* Damage Numbers */}
                     {showDamage && (
                        <div
                           className={`damage-number ${showDamage.className}`}
                           style={{
                              left: showDamage.isPlayer ? "25%" : "75%",
                              top: showDamage.isPlayer ? "60%" : "40%",
                           }}
                        >
                           {showDamage.text}
                        </div>
                     )}
                  </div>{" "}
                  {/* Close camera transform div */}
               </div>
            );
         };

         // Battle Controls Component
         const BattleControls = ({
            battle,
            pokemon,
            onMove,
            onSwitch,
            onRun,
            disabled,
            onCoachToggle,
         }) => {
            const [showMoves, setShowMoves] = useState(true);
            const [showSwitch, setShowSwitch] = useState(false);
            const [hoveredMove, setHoveredMove] = useState(null);

            // Debug logging
            console.log("=== BATTLE CONTROLS RENDER ===");
            console.log("Disabled:", disabled);
            console.log("Battle state:", battle?.state);
            console.log("Pokemon:", pokemon?.name);

            // Safety check
            if (!pokemon || !battle) {
               return (
                  <div className="p-4">
                     <div className="text-center text-gray-500">Loading battle controls...</div>
                  </div>
               );
            }

            const handleMoveSelect = (moveIndex) => {
               console.log("=== MOVE SELECT ATTEMPT ===");
               console.log("Move index:", moveIndex);
               console.log("Disabled:", disabled);
               console.log("Pokemon moves:", pokemon.moves);
               console.log("Move PP:", pokemon.moves[moveIndex]?.pp);
               console.log("Can use move:", pokemon.canUseMove(moveIndex));

               if (!disabled && pokemon.canUseMove(moveIndex)) {
                  console.log("=== CALLING onMove ===");
                  soundManager.play("select");
                  onMove(moveIndex);
               } else {
                  console.log("=== MOVE BLOCKED ===");
                  console.log("Reason - disabled:", disabled);
                  console.log("Reason - can't use move:", !pokemon.canUseMove(moveIndex));
               }
            };

            const handleSwitch = (index) => {
               if (!disabled) {
                  soundManager.play("select");
                  onSwitch(index);
                  setShowSwitch(false);
               }
            };

            return (
               <div className="battle-ui-panel p-4">
                  {!showSwitch && (
                     <div className="battle-menu-grid grid grid-cols-2 gap-3">
                        {pokemon.moves.map((move, index) => (
                           <button
                              key={index}
                              onClick={() => {
                                 console.log("=== BUTTON CLICKED ===");
                                 console.log("Button clicked for move index:", index);
                                 console.log("Move:", move);
                                 console.log("About to call handleMoveSelect");
                                 handleMoveSelect(index);
                              }}
                              onMouseEnter={() => setHoveredMove(move)}
                              onMouseLeave={() => setHoveredMove(null)}
                              disabled={disabled || move.pp === 0}
                              className={`move-button ${move.pp === 0 ? "disabled" : ""}`}
                           >
                              <div className="move-name">{move.name}</div>
                              <div className="move-details">
                                 <span
                                    className={`type-${move.type.toLowerCase()} move-type-badge`}
                                 >
                                    {move.type}
                                 </span>
                                 <span className="move-pp">
                                    {move.pp}/{move.maxPp}
                                 </span>
                              </div>
                           </button>
                        ))}
                     </div>
                  )}

                  {showSwitch && (
                     <div className="space-y-2">
                        <h3 className="font-bold mb-2 text-gray-800">Choose Pokemon:</h3>
                        {battle.playerTeam.map((p, index) => {
                           if (index === battle.currentPlayerIndex || p.hp === 0) return null;

                           return (
                              <button
                                 key={index}
                                 onClick={() => handleSwitch(index)}
                                 className="move-button w-full flex items-center gap-3"
                              >
                                 <img src={p.sprite} alt={p.name} className="w-8 h-8 pixelated" />
                                 <span className="font-bold text-gray-800">{p.name}</span>
                                 <span className="ml-auto text-sm text-gray-600">
                                    {p.hp}/{p.maxHp} HP
                                 </span>
                              </button>
                           );
                        })}
                     </div>
                  )}

                  <div className="flex gap-3 mt-4">
                     <button
                        onClick={() => {
                           soundManager.play("select");
                           onCoachToggle && onCoachToggle();
                        }}
                        disabled={disabled}
                        className="battle-action-button coach flex-1"
                     >
                        COACH
                     </button>
                     <button
                        onClick={() => {
                           setShowSwitch(!showSwitch);
                        }}
                        disabled={disabled || battle.playerTeam.filter((p) => p.hp > 0).length <= 1}
                        className="battle-action-button switch flex-1"
                     >
                        SWITCH
                     </button>
                     <button
                        onClick={onRun}
                        disabled={disabled}
                        className="battle-action-button run flex-1"
                     >
                        CLOSE
                     </button>
                  </div>

                  {hoveredMove && (
                     <div className="effectiveness-popup">
                        <div className="move-preview-content">
                           <div className="font-bold text-sm mb-1">{hoveredMove.name}</div>
                           <div className="text-xs space-y-1">
                              <div>Power: {hoveredMove.power || "-"}</div>
                              <div>Accuracy: {hoveredMove.accuracy || "-"}%</div>
                              <div className="mt-2 text-[10px] opacity-80">
                                 {hoveredMove.description}
                              </div>
                           </div>
                        </div>
                     </div>
                  )}
               </div>
            );
         };

         // Message Box Component
         const MessageBox = ({
            messages,
            onNext,
            autoAdvance = true,
            autoAdvanceDelay = 2000,
            typingSpeed = 30,
         }) => {
            const [currentIndex, setCurrentIndex] = useState(0);
            const [displayText, setDisplayText] = useState("");
            const [isTyping, setIsTyping] = useState(true);
            const [autoAdvanceTimer, setAutoAdvanceTimer] = useState(null);

            useEffect(() => {
               if (currentIndex >= messages.length) {
                  onNext();
                  return;
               }

               const message = messages[currentIndex];
               let charIndex = 0;
               setDisplayText("");
               setIsTyping(true);

               // Clear any existing auto-advance timer
               if (autoAdvanceTimer) {
                  clearTimeout(autoAdvanceTimer);
                  setAutoAdvanceTimer(null);
               }

               const typingInterval = setInterval(() => {
                  if (charIndex < message.length) {
                     setDisplayText(message.substring(0, charIndex + 1));
                     charIndex++;
                  } else {
                     clearInterval(typingInterval);
                     setIsTyping(false);

                     // Auto-advance to next message after a delay (only if enabled)
                     if (autoAdvance) {
                        const timer = setTimeout(() => {
                           if (currentIndex < messages.length - 1) {
                              setCurrentIndex((prev) => prev + 1);
                           } else {
                              onNext();
                           }
                        }, autoAdvanceDelay);
                        setAutoAdvanceTimer(timer);
                     }
                  }
               }, typingSpeed);

               return () => {
                  clearInterval(typingInterval);
                  if (autoAdvanceTimer) {
                     clearTimeout(autoAdvanceTimer);
                  }
               };
            }, [currentIndex, messages, onNext, autoAdvance, autoAdvanceDelay, typingSpeed]);

            const handleClick = () => {
               // Clear auto-advance timer when user clicks
               if (autoAdvanceTimer) {
                  clearTimeout(autoAdvanceTimer);
                  setAutoAdvanceTimer(null);
               }

               if (isTyping) {
                  // Skip typing animation and show full message
                  setDisplayText(messages[currentIndex]);
                  setIsTyping(false);

                  // Still set auto-advance timer if enabled
                  if (autoAdvance) {
                     const timer = setTimeout(() => {
                        if (currentIndex < messages.length - 1) {
                           setCurrentIndex((prev) => prev + 1);
                        } else {
                           onNext();
                        }
                     }, autoAdvanceDelay);
                     setAutoAdvanceTimer(timer);
                  }
               } else {
                  // Advance to next message immediately
                  if (currentIndex < messages.length - 1) {
                     setCurrentIndex(currentIndex + 1);
                  } else {
                     onNext();
                  }
               }
            };

            if (currentIndex >= messages.length) return null;

            return (
               <div className="text-box p-4 cursor-pointer" onClick={handleClick}>
                  <p className="text-sm">{displayText}</p>
                  {!isTyping && (
                     <div className="flex justify-between items-center mt-2">
                        <div className="text-xs text-gray-600">
                           {autoAdvance ? "Auto-advancing..." : "Click to continue"}
                        </div>
                        <div className="w-0 h-0 border-l-[8px] border-l-transparent border-r-[8px] border-r-transparent border-t-[8px] border-t-black animate-pulse" />
                     </div>
                  )}
               </div>
            );
         };

         // Settings Component
         const Settings = ({ settings, onSettingsChange, onClose }) => {
            const [activeTab, setActiveTab] = useState("general");

            return (
               <div className="settings-panel">
                  <h2 className="text-xl mb-4">Settings</h2>

                  <div className="settings-tabs">
                     <button
                        className={`settings-tab ${activeTab === "general" ? "active" : ""}`}
                        onClick={() => setActiveTab("general")}
                     >
                        General
                     </button>
                     <button
                        className={`settings-tab ${activeTab === "audio" ? "active" : ""}`}
                        onClick={() => setActiveTab("audio")}
                     >
                        Audio
                     </button>
                     <button
                        className={`settings-tab ${activeTab === "controls" ? "active" : ""}`}
                        onClick={() => setActiveTab("controls")}
                     >
                        Controls
                     </button>
                  </div>

                  <div className="mt-4">
                     {activeTab === "general" && (
                        <div className="space-y-4">
                           <label className="flex items-center gap-2">
                              <input
                                 type="checkbox"
                                 checked={settings.showAnimations}
                                 onChange={(e) =>
                                    onSettingsChange({ showAnimations: e.target.checked })
                                 }
                              />
                              <span>Battle Animations</span>
                           </label>

                           <label className="flex items-center gap-2">
                              <input
                                 type="checkbox"
                                 checked={settings.showDamageNumbers}
                                 onChange={(e) =>
                                    onSettingsChange({ showDamageNumbers: e.target.checked })
                                 }
                              />
                              <span>Damage Numbers</span>
                           </label>

                           <label className="flex items-center gap-2">
                              <input
                                 type="checkbox"
                                 checked={settings.autoSave}
                                 onChange={(e) => onSettingsChange({ autoSave: e.target.checked })}
                              />
                              <span>Auto Save</span>
                           </label>

                           <label className="flex items-center gap-2">
                              <input
                                 type="checkbox"
                                 checked={settings.autoAdvanceText}
                                 onChange={(e) =>
                                    onSettingsChange({ autoAdvanceText: e.target.checked })
                                 }
                              />
                              <span>Auto-Advance Text</span>
                           </label>

                           <div>
                              <label className="block mb-2">Battle Speed</label>
                              <select
                                 value={settings.battleSpeed}
                                 onChange={(e) => onSettingsChange({ battleSpeed: e.target.value })}
                                 className="w-full p-2 border-2 border-black rounded"
                              >
                                 <option value="normal">Normal</option>
                                 <option value="fast">Fast</option>
                                 <option value="ultra">Ultra Fast</option>
                              </select>
                           </div>

                           <div>
                              <label className="block mb-2">Text Speed</label>
                              <select
                                 value={settings.textSpeed}
                                 onChange={(e) => onSettingsChange({ textSpeed: e.target.value })}
                                 className="w-full p-2 border-2 border-black rounded"
                              >
                                 <option value="slow">Slow</option>
                                 <option value="normal">Normal</option>
                                 <option value="fast">Fast</option>
                              </select>
                           </div>
                        </div>
                     )}

                     {activeTab === "audio" && (
                        <div className="space-y-4">
                           <div>
                              <label className="block mb-2">Master Volume</label>
                              <input
                                 type="range"
                                 min="0"
                                 max="1"
                                 step="0.1"
                                 value={settings.volume}
                                 onChange={(e) => {
                                    const value = parseFloat(e.target.value);
                                    soundManager.setVolume(value);
                                    onSettingsChange({ volume: value });
                                 }}
                                 className="w-full"
                              />
                           </div>

                           <label className="flex items-center gap-2">
                              <input
                                 type="checkbox"
                                 checked={settings.muted}
                                 onChange={(e) => {
                                    soundManager.toggleMute();
                                    onSettingsChange({ muted: e.target.checked });
                                 }}
                              />
                              <span>Mute All Sounds</span>
                           </label>
                        </div>
                     )}

                     {activeTab === "controls" && (
                        <div className="space-y-2 text-xs">
                           <div className="font-bold mb-2">Keyboard Shortcuts</div>
                           <div>1-4: Select Move</div>
                           <div>S: Switch Pokemon</div>
                           <div>R: Close Battle</div>
                           <div>Space: Speed Up Messages</div>
                           <div>ESC: Open/Close Settings</div>
                        </div>
                     )}
                  </div>

                  <button
                     onClick={onClose}
                     className="action-button mt-6 w-full bg-gray-300 hover:bg-gray-400 text-black py-2 rounded-lg"
                  >
                     Close
                  </button>
               </div>
            );
         };

         // Battle Options Menu Component
         const BattleOptionsMenu = ({
            onToggleCoach,
            onToggleSettings,
            onExitBattle,
            showCoach,
            battle,
         }) => {
            const [isOpen, setIsOpen] = useState(false);

            return (
               <div className="absolute top-4 left-4 z-30">
                  <button
                     onClick={() => setIsOpen(!isOpen)}
                     className="action-button bg-blue-400 hover:bg-blue-500 text-black border-2 border-black shadow-lg transition-all"
                     style={{
                        fontFamily: "'Press Start 2P', monospace",
                        fontSize: "10px",
                        padding: "8px 12px",
                        borderRadius: "4px",
                     }}
                     title="Battle Options"
                  >
                     MENU
                  </button>

                  {isOpen && (
                     <>
                        {/* Backdrop */}
                        <div
                           className="fixed inset-0 bg-black/20 z-20"
                           onClick={() => setIsOpen(false)}
                        />

                        {/* Menu */}
                        <div
                           className="absolute top-12 left-0 bg-white border-4 border-black rounded-lg p-4 space-y-2 min-w-48 shadow-xl z-30"
                           style={{ fontFamily: "'Press Start 2P', monospace" }}
                        >
                           <div className="font-bold text-center border-b-2 border-black pb-2 mb-3 text-xs">
                              BATTLE OPTIONS
                           </div>

                           <button
                              onClick={() => {
                                 onToggleCoach();
                                 setIsOpen(false);
                              }}
                              className="action-button w-full text-left px-3 py-2 bg-green-200 hover:bg-green-300 border-2 border-black rounded text-black flex items-center gap-2"
                              style={{ fontSize: "8px" }}
                           >
                              <span className="text-xs"></span>
                              <span>{showCoach ? "HIDE COACH" : "SHOW COACH"}</span>
                           </button>

                           <button
                              onClick={() => {
                                 setIsOpen(false);
                                 // Add speed display functionality here
                              }}
                              className="action-button w-full text-left px-3 py-2 bg-yellow-200 hover:bg-yellow-300 border-2 border-black rounded text-black flex items-center gap-2"
                              style={{ fontSize: "8px" }}
                           >
                              <span className="text-xs"></span>
                              <span>SPEED ORDER</span>
                           </button>

                           <button
                              onClick={() => {
                                 setIsOpen(false);
                                 // Add type chart functionality here
                              }}
                              className="action-button w-full text-left px-3 py-2 bg-purple-200 hover:bg-purple-300 border-2 border-black rounded text-black flex items-center gap-2"
                              style={{ fontSize: "8px" }}
                           >
                              <span className="text-xs"></span>
                              <span>TYPE CHART</span>
                           </button>

                           <div className="border-t-2 border-black pt-2 mt-2 space-y-2">
                              <button
                                 onClick={() => {
                                    onToggleSettings();
                                    setIsOpen(false);
                                 }}
                                 className="action-button w-full text-left px-3 py-2 bg-gray-200 hover:bg-gray-300 border-2 border-black rounded text-black flex items-center gap-2"
                                 style={{ fontSize: "8px" }}
                              >
                                 <span className="text-xs"></span>
                                 <span>SETTINGS</span>
                              </button>

                              <button
                                 onClick={() => {
                                    if (confirm("FORFEIT THIS BATTLE?")) {
                                       onExitBattle();
                                    }
                                    setIsOpen(false);
                                 }}
                                 className="action-button w-full text-left px-3 py-2 bg-red-200 hover:bg-red-300 border-2 border-black rounded text-red-800 flex items-center gap-2"
                                 style={{ fontSize: "8px" }}
                              >
                                 <span className="text-xs"></span>
                                 <span>FORFEIT</span>
                              </button>
                           </div>

                           <div
                              className="text-center pt-2 border-t-2 border-gray-300 text-gray-600"
                              style={{ fontSize: "7px" }}
                           >
                              TURN {battle?.turn || 1}
                           </div>
                        </div>
                     </>
                  )}
               </div>
            );
         };

         // ==================== MAIN APP COMPONENT ====================
         function App() {
            // State Management
            const [gameState, setGameState] = useState(GAME_STATES.LOADING);
            const [battle, setBattle] = useState(null);
            const [playerTeam, setPlayerTeam] = useState([]);
            const [settings, setSettings] = useState({
               volume: 0.5,
               muted: false,
               showAnimations: true,
               showDamageNumbers: true,
               autoSave: true,
               battleSpeed: "normal",
               showCoachByDefault: false,
               coachDetailLevel: "basic", // 'basic', 'detailed', 'expert'
               autoAdvanceText: true, // Auto-advance text messages
               textSpeed: "normal", // 'fast', 'normal', 'slow'
            });
            const [gameStats, setGameStats] = useState(() => {
               const saved = localStorage.getItem("pokemonGameStats");
               return saved
                  ? JSON.parse(saved)
                  : {
                       totalBattles: 0,
                       wins: 0,
                       losses: 0,
                       currentStreak: 0,
                       bestStreak: 0,
                       favoriteMove: {},
                    };
            });
            const [showSettings, setShowSettings] = useState(false);
            const [isAnimating, setIsAnimating] = useState(false);
            const [currentMessages, setCurrentMessages] = useState([]);
            const [showCoach, setShowCoach] = useState(false);
            const [battleUpdateCounter, setBattleUpdateCounter] = useState(0);

            const aiEngine = useRef(null);

            // Initialize
            useEffect(() => {
               const init = async () => {
                  // Load saved settings first
                  const savedSettings = localStorage.getItem("pokemonSettings");
                  if (savedSettings) {
                     const parsed = JSON.parse(savedSettings);
                     // Merge with default settings to ensure new properties have defaults
                     setSettings((prev) => ({ ...prev, ...parsed }));
                  }

                  // Don't wait for sound initialization - do it later on first user interaction
                  setGameState(GAME_STATES.MAIN_MENU);
               };

               init();
            }, []);

            // Save settings and apply sound settings
            useEffect(() => {
               localStorage.setItem("pokemonSettings", JSON.stringify(settings));

               // Apply sound settings
               soundManager.setVolume(settings.volume);
               if (settings.muted) {
                  soundManager.muted = true;
                  soundManager.setVolume(0);
               }
            }, [settings]);

            // Save game stats
            useEffect(() => {
               localStorage.setItem("pokemonGameStats", JSON.stringify(gameStats));
            }, [gameStats]);

            // Keyboard controls
            useEffect(() => {
               const handleKeyPress = (e) => {
                  if (e.key === "Escape") {
                     setShowSettings(!showSettings);
                  }

                  if (gameState === GAME_STATES.BATTLE && battle && !isAnimating) {
                     const playerPokemon = battle.playerPokemon;

                     switch (e.key) {
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                           const moveIndex = parseInt(e.key) - 1;
                           if (playerPokemon.moves[moveIndex]) {
                              handlePlayerMove(moveIndex);
                           }
                           break;
                        case "s":
                        case "S":
                           // Open switch menu
                           break;
                        case "r":
                        case "R":
                           handleRun();
                           break;
                     }
                  }
               };

               window.addEventListener("keydown", handleKeyPress);
               return () => window.removeEventListener("keydown", handleKeyPress);
            }, [gameState, battle, isAnimating, showSettings]);

            // Game Flow Functions
            const startNewGame = () => {
               setGameState(GAME_STATES.TEAM_BUILDER);
            };

            const startMultiplayer = () => {
               setGameState(GAME_STATES.MULTIPLAYER_LOBBY);
            };

            const loadGame = () => {
               const savedData = localStorage.getItem("pokemonSaveData");
               if (savedData) {
                  const parsed = JSON.parse(savedData);
                  // Restore game state from save
                  setPlayerTeam(
                     parsed.playerTeam.map((p) => {
                        const pokemon = new Pokemon(POKEMON_DATA[p.species], p.level);
                        Object.assign(pokemon, p);
                        return pokemon;
                     })
                  );
                  // Continue from save
                  setGameState(GAME_STATES.TEAM_BUILDER);
               }
            };

            const handleTeamConfirm = (selectedPokemon) => {
               const team = selectedPokemon.map((p) => new Pokemon(p, 50));
               setPlayerTeam(team);
               startBattle(team);
            };

            const startBattle = (team) => {
               // Create enemy team
               const availablePokemon = Object.values(POKEMON_DATA);
               const enemyTeamData = [];

               while (enemyTeamData.length < 3) {
                  const randomPokemon =
                     availablePokemon[Math.floor(Math.random() * availablePokemon.length)];
                  if (!enemyTeamData.some((p) => p.id === randomPokemon.id)) {
                     enemyTeamData.push(randomPokemon);
                  }
               }

               const enemyTeam = enemyTeamData.map(
                  (p) => new Pokemon(p, 48 + Math.floor(Math.random() * 5))
               );

               // Create battle
               const newBattle = new Battle(team, enemyTeam);
               setBattle(newBattle);

               // Create AI
               aiEngine.current = new EnhancedAIBattleEngine("balanced", 1.0);

               // Start battle
               setGameState(GAME_STATES.BATTLE);
               newBattle.state = BATTLE_STATES.PLAYER_TURN;
               setCurrentMessages([
                  `A wild trainer appeared!`,
                  `Trainer sent out ${enemyTeam[0].name}!`,
                  `Go, ${team[0].name}!`,
               ]);
            };

            const handlePlayerMove = async (moveIndex) => {
               console.log("=== MOVE SELECTION DEBUG ===");
               console.log("handlePlayerMove called with moveIndex:", moveIndex);
               console.log("Battle state:", battle?.state);
               console.log("Is animating:", isAnimating);
               console.log("Battle object:", battle);

               if (!battle) {
                  console.error("No battle object found!");
                  return;
               }

               if (battle.state !== BATTLE_STATES.PLAYER_TURN) {
                  console.log("Not player turn, current state:", battle.state);
                  return;
               }

               if (isAnimating) {
                  console.log("Animation in progress, ignoring input");
                  return;
               }

               const playerPokemon = battle.playerPokemon;
               if (!playerPokemon) {
                  console.error("No player Pokemon found!");
                  return;
               }

               const move = playerPokemon.moves[moveIndex];
               if (!move) {
                  console.error("Move not found at index:", moveIndex);
                  return;
               }

               console.log("Player Pokemon:", playerPokemon.name);
               console.log("Selected move:", move.name, move);

               if (!playerPokemon.canUseMove(moveIndex)) {
                  console.log("Cannot use move - no PP or other restriction");
                  setCurrentMessages([`${move.name} has no PP left!`]);
                  return;
               }

               try {
                  console.log("Setting animation to true and executing move");
                  setIsAnimating(true);
                  battle.state = BATTLE_STATES.EXECUTING_MOVE;

                  // Clear any previous messages
                  battle.clearMessages();

                  // Queue player action
                  console.log("Queuing player action...");
                  battle.queueAction({
                     type: "move",
                     pokemon: playerPokemon,
                     target: battle.enemyPokemon,
                     move: playerPokemon.useMove(moveIndex),
                  });

                  // Get AI decision
                  console.log("Getting AI decision...");
                  const aiDecision = await aiEngine.current.decideTurn({
                     playerPokemon,
                     enemyPokemon: battle.enemyPokemon,
                     playerTeam: battle.playerTeam,
                     enemyTeam: battle.enemyTeam,
                     currentPlayerIndex: battle.currentPlayerIndex,
                     currentEnemyIndex: battle.currentEnemyIndex,
                     weather: battle.weather,
                  });
                  console.log("AI decision received:", aiDecision);

                  if (aiDecision.action === "move") {
                     const enemyMoveIndex = battle.enemyPokemon.moves.findIndex(
                        (m) => m.id === aiDecision.move.id
                     );
                     console.log("Enemy using move index:", enemyMoveIndex);
                     if (enemyMoveIndex >= 0) {
                        battle.queueAction({
                           type: "move",
                           pokemon: battle.enemyPokemon,
                           target: playerPokemon,
                           move: battle.enemyPokemon.useMove(enemyMoveIndex),
                        });
                     }
                  } else if (aiDecision.action === "switch") {
                     console.log("Enemy switching to:", aiDecision.target);
                     battle.queueAction({
                        type: "switch",
                        team: battle.enemyTeam,
                        oldIndex: battle.currentEnemyIndex,
                        newIndex: aiDecision.target,
                     });
                  }

                  // Execute turn
                  console.log("Executing turn...");
                  await battle.executeTurn();
                  console.log("Turn execution completed");

                  // Force React re-render by incrementing counter
                  setBattleUpdateCounter((prev) => prev + 1);

                  // Display messages
                  console.log("Checking messages, queue length:", battle.messageQueue.length);
                  if (battle.messageQueue.length > 0) {
                     console.log("Setting messages:", battle.messageQueue);
                     setCurrentMessages([...battle.messageQueue]);
                     battle.clearMessages();
                  } else {
                     // If no messages (shouldn't happen), reset to player turn
                     console.log("No messages found, resetting to player turn");
                     console.log("Current battle state before reset:", battle.state);
                     setIsAnimating(false);
                     battle.state = BATTLE_STATES.PLAYER_TURN;
                     console.log("Battle state after reset:", battle.state);
                  }
               } catch (error) {
                  console.error("Error in handlePlayerMove:", error);
                  setIsAnimating(false);
                  battle.state = BATTLE_STATES.PLAYER_TURN;
                  setCurrentMessages(["An error occurred during battle. Please try again."]);
               }
            };
            const handlePlayerSwitch = (newIndex) => {
               if (!battle || battle.state !== BATTLE_STATES.PLAYER_TURN || isAnimating) return;

               setIsAnimating(true);
               battle.state = BATTLE_STATES.SWITCHING;

               battle.executeSwitch(battle.playerTeam, battle.currentPlayerIndex, newIndex);

               // Force React re-render by incrementing counter
               setBattleUpdateCounter((prev) => prev + 1);
               setCurrentMessages(battle.messageQueue);
               battle.clearMessages();

               // Enemy gets free turn
               setTimeout(async () => {
                  const aiDecision = await aiEngine.current.decideTurn({
                     playerPokemon: battle.playerPokemon,
                     enemyPokemon: battle.enemyPokemon,
                     playerTeam: battle.playerTeam,
                     enemyTeam: battle.enemyTeam,
                     currentPlayerIndex: battle.currentPlayerIndex,
                     currentEnemyIndex: battle.currentEnemyIndex,
                     weather: battle.weather,
                  });

                  if (aiDecision.action === "move") {
                     const enemyMoveIndex = battle.enemyPokemon.moves.findIndex(
                        (m) => m.id === aiDecision.move.id
                     );
                     await battle.executeMove(
                        battle.enemyPokemon,
                        battle.playerPokemon,
                        battle.enemyPokemon.moves[enemyMoveIndex]
                     );
                  }

                  // Force React re-render by incrementing counter
                  setBattleUpdateCounter((prev) => prev + 1);

                  setCurrentMessages(battle.messageQueue);
                  battle.clearMessages();
                  setIsAnimating(false);

                  if (!battle.checkForFaints()) {
                     battle.state = BATTLE_STATES.PLAYER_TURN;
                  }
               }, 1000);
            };

            const handleRun = () => {
               if (!battle) return;

               // Redirect to main page by reloading the page
               window.location.reload();
            };

            const handleMessagesComplete = () => {
               console.log("=== MESSAGES COMPLETE DEBUG ===");
               console.log("Current battle state:", battle?.state);
               console.log("Setting isAnimating to false");

               setCurrentMessages([]); // Clear messages to show battle controls
               setIsAnimating(false);

               if (battle.state === BATTLE_STATES.VICTORY) {
                  // Update stats
                  setGameStats((prev) => ({
                     ...prev,
                     totalBattles: prev.totalBattles + 1,
                     wins: prev.wins + 1,
                     currentStreak: prev.currentStreak + 1,
                     bestStreak: Math.max(prev.bestStreak, prev.currentStreak + 1),
                  }));

                  // Don't auto-redirect, let the victory screen show
                  console.log("Battle won! Showing victory screen");
               } else if (battle.state === BATTLE_STATES.DEFEAT) {
                  // Update stats
                  setGameStats((prev) => ({
                     ...prev,
                     totalBattles: prev.totalBattles + 1,
                     losses: prev.losses + 1,
                     currentStreak: 0,
                  }));

                  // Don't auto-redirect, let the defeat screen show
                  console.log("Battle lost! Showing defeat screen");
               } else if (battle.state === BATTLE_STATES.SWITCHING) {
                  console.log("=== SWITCHING STATE HANDLER ===");
                  console.log("Pending switch:", battle.pendingSwitch);
                  console.log("Faint animation in progress:", battle.faintAnimationInProgress);

                  // Check if there's a pending switch from faint animation
                  if (battle.pendingSwitch) {
                     console.log("Executing pending switch...");
                     battle.executePendingSwitch();
                     setBattleUpdateCounter((prev) => prev + 1);
                  } else {
                     // After showing switch messages, return to player turn
                     console.log("No pending switch, returning to player turn");
                     battle.state = BATTLE_STATES.PLAYER_TURN;
                     // Force re-render
                     setBattleUpdateCounter((prev) => prev + 1);
                  }
               } else if (battle.state === BATTLE_STATES.EXECUTING_MOVE) {
                  // After move execution messages are complete, return to player turn
                  console.log("Move execution complete, returning to player turn");
                  battle.state = BATTLE_STATES.PLAYER_TURN;
                  // Force re-render
                  setBattleUpdateCounter((prev) => prev + 1);
               } else {
                  // Reset to player turn for continued battle
                  console.log("Default case: returning to player turn");
                  battle.state = BATTLE_STATES.PLAYER_TURN;
                  // Force re-render
                  setBattleUpdateCounter((prev) => prev + 1);
               }
            };

            // Render
            return (
               <GameContext.Provider value={{ settings, gameStats, soundManager }}>
                  <div className="min-h-screen overflow-hidden relative">
                     {gameState === GAME_STATES.LOADING && <LoadingScreen />}

                     {gameState === GAME_STATES.MAIN_MENU && (
                        <MainMenu
                           onNewGame={startNewGame}
                           onMultiplayer={startMultiplayer}
                           onLoadGame={loadGame}
                           onSettings={() => setShowSettings(true)}
                           gameStats={gameStats}
                        />
                     )}

                     {gameState === GAME_STATES.MULTIPLAYER_LOBBY && (
                        <MultiplayerLobby onBack={() => setGameState(GAME_STATES.MAIN_MENU)} />
                     )}

                     {gameState === GAME_STATES.TEAM_BUILDER && (
                        <TeamBuilder
                           onConfirm={handleTeamConfirm}
                           onBack={() => setGameState(GAME_STATES.MAIN_MENU)}
                           format={BATTLE_FORMATS.SINGLES_3V3}
                        />
                     )}

                     {gameState === GAME_STATES.BATTLE && battle && (
                        <div className="min-h-screen p-4 flex flex-col relative">
                           {/* Battle Options Menu */}
                           <BattleOptionsMenu
                              onToggleCoach={() => setShowCoach(!showCoach)}
                              onToggleSettings={() => setShowSettings(true)}
                              onExitBattle={() => {
                                 setGameState(GAME_STATES.MAIN_MENU);
                                 setBattle(null);
                                 setCurrentMessages([]);
                                 setIsAnimating(false);
                              }}
                              showCoach={showCoach}
                              battle={battle}
                           />

                           {/* Coach Component */}
                           {showCoach &&
                              battle.state === BATTLE_STATES.PLAYER_TURN &&
                              !isAnimating && (
                                 <BattleCoach
                                    battle={battle}
                                    playerPokemon={battle.playerPokemon}
                                    enemyPokemon={battle.enemyPokemon}
                                    onClose={() => setShowCoach(false)}
                                 />
                              )}

                           <div className="max-w-4xl mx-auto w-full flex-1 flex flex-col">
                              <BattleScene
                                 battle={battle}
                                 playerPokemon={battle.playerPokemon}
                                 enemyPokemon={battle.enemyPokemon}
                                 isAnimating={
                                    isAnimating
                                       ? battle.state === BATTLE_STATES.PLAYER_TURN
                                          ? "player-attack"
                                          : "enemy-attack"
                                       : null
                                 }
                              />

                              <div className="mt-4 text-box">
                                 {currentMessages.length > 0 ? (
                                    <MessageBox
                                       messages={currentMessages}
                                       onNext={handleMessagesComplete}
                                       autoAdvance={settings.autoAdvanceText !== false}
                                       autoAdvanceDelay={
                                          settings.textSpeed === "fast"
                                             ? 1000
                                             : settings.textSpeed === "slow"
                                             ? 3000
                                             : 2000
                                       }
                                       typingSpeed={
                                          settings.textSpeed === "fast"
                                             ? 20
                                             : settings.textSpeed === "slow"
                                             ? 50
                                             : 30
                                       }
                                    />
                                 ) : battle.state === BATTLE_STATES.VICTORY ? (
                                    <div className="p-8 text-center">
                                       <div className="text-box p-6 mb-4">
                                          <h2 className="text-xl font-bold mb-4">
                                             You won the battle!
                                          </h2>
                                          <div className="text-sm space-y-2">
                                             <p>Battles Won: {gameStats.wins + 1}</p>
                                             <p>Current Streak: {gameStats.currentStreak + 1}</p>
                                          </div>
                                       </div>
                                       <button
                                          onClick={() => {
                                             setGameState(GAME_STATES.MAIN_MENU);
                                             setBattle(null);
                                          }}
                                          className="action-button bg-gray-200 hover:bg-gray-300 text-black px-6 py-3 rounded-lg"
                                       >
                                          Return to Main Menu
                                       </button>
                                    </div>
                                 ) : battle.state === BATTLE_STATES.DEFEAT ? (
                                    <div className="p-8 text-center">
                                       <div className="text-box p-6 mb-4">
                                          <h2 className="text-xl font-bold mb-4">
                                             You lost the battle!
                                          </h2>
                                          <div className="text-sm space-y-2">
                                             <p>Total Battles: {gameStats.totalBattles + 1}</p>
                                             <p>Losses: {gameStats.losses + 1}</p>
                                          </div>
                                       </div>
                                       <button
                                          onClick={() => {
                                             setGameState(GAME_STATES.MAIN_MENU);
                                             setBattle(null);
                                          }}
                                          className="action-button bg-gray-200 hover:bg-gray-300 text-black px-6 py-3 rounded-lg"
                                       >
                                          Return to Main Menu
                                       </button>
                                    </div>
                                 ) : battle?.playerPokemon ? (
                                    <>
                                       {/* Debug info */}
                                       <div className="p-2 bg-red-100 text-xs">
                                          Debug: isAnimating={isAnimating.toString()}, battleState=
                                          {battle.state}, disabled=
                                          {(
                                             isAnimating ||
                                             battle.state !== BATTLE_STATES.PLAYER_TURN
                                          ).toString()}
                                       </div>
                                       <BattleControls
                                          battle={battle}
                                          pokemon={battle.playerPokemon}
                                          onMove={handlePlayerMove}
                                          onSwitch={handlePlayerSwitch}
                                          onRun={handleRun}
                                          onCoachToggle={() => setShowCoach((prev) => !prev)}
                                          disabled={
                                             isAnimating ||
                                             battle.state !== BATTLE_STATES.PLAYER_TURN
                                          }
                                       />
                                    </>
                                 ) : (
                                    <div className="p-4">
                                       <div className="text-center text-gray-500">
                                          Preparing battle...
                                       </div>
                                    </div>
                                 )}
                              </div>
                           </div>
                        </div>
                     )}

                     {showSettings && (
                        <>
                           <div
                              className="fixed inset-0 bg-black/50 z-50"
                              onClick={() => setShowSettings(false)}
                           />
                           <Settings
                              settings={settings}
                              onSettingsChange={(changes) =>
                                 setSettings({ ...settings, ...changes })
                              }
                              onClose={() => setShowSettings(false)}
                           />
                        </>
                     )}
                  </div>
               </GameContext.Provider>
            );
         }

         // Render the app
         const container = document.getElementById("root");
         const root = ReactDOM.createRoot(container);
         root.render(<App />);
      </script>
   </body>
</html>
